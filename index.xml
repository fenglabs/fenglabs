<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>晒春风的博客 - 春风十里不如你 - Ten miles of spring breeze is not as good as you</title>
    <link>https://shaichunfeng.com/</link>
    <description>Recent content on 晒春风的博客 - 春风十里不如你 - Ten miles of spring breeze is not as good as you</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>design &amp; develop by shaichunfeng &amp;copy;</copyright>
    <lastBuildDate>Thu, 31 Mar 2022 22:58:39 +0800</lastBuildDate><atom:link href="https://shaichunfeng.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>网络安全（六）| 路由器（Route）</title>
      <link>https://shaichunfeng.com/post/2022/03/31/what-is-a-router/</link>
      <pubDate>Thu, 31 Mar 2022 22:58:39 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2022/03/31/what-is-a-router/</guid>
      <description>路由器是连接两个或多个分组交换网络或子网络的设备。它有两个主要功能：通过将数据包转发到其预定的 IP 地址从而管理这些网络之间的流量，以及允许多个设备使用同一互联网连接。
路由器分为几种类型，但大多数路由器在 LAN（局域网）和 WAN（广域网）之间传递数据。LAN 是一组限制在特定地理区域的连接设备。一个 LAN 通常只需要一个路由器。
与之相反，WAN 是一个分布在广大地理区域的大型网络。例如，在全国各地多个地点运营的大型组织和公司将需要为每个地点建立单独的 LAN，然后与其他 LAN 连接，形成一个 WAN。由于 WAN 分布在一个大的区域内，它通常需要多个路由器和交换机*。
网络交换机在同一网络的设备组之间转发数据包，而路由器则在不同网络之间转发数据。
路由器如何工作？ 把路由器想象成一个空中交通指挥员，把数据包想象成飞往不同机场（或网络）的飞机。就像每架飞机都有一个唯一的目的地并遵循唯一的路线一样，每个数据包都需要被尽可能高效地引导到其目的地。与空中交通指挥员员确保飞机到达目的地而不迷路或沿途遭受重大干扰一样，路由器帮助引导数据包到达其目标 IP 地址。
为了有效地引导数据包，路由器使用一个内部路由表——一个通往不同网络目的地的路径列表。路由器读取数据包的标头以确定其去向，然后查阅路由表以找出通往该目的地的最有效路径。然后，它将数据包转发到该路径中的下一个网络。
路由器和调制解调器之间有什么区别？ 虽然一些互联网服务提供商 (ISP) 可能将路由器和调制解调器合并在一个设备中，但它们并不一样。两者在网络相互连接和连接到互联网方面发挥着不同但同等重要的作用。
路由器形成网络并管理这些网络内部和之间的数据流，而调制解调器将这些网络连接到互联网。调制解调器通过将来自 ISP 的信号转换为可由任何连接设备解释的数字信号，来建立与互联网的连接。一台设备可以插入到调制解调器中，以便连接到互联网。另外，路由器可以帮助将这一信号分发给一个已建立网络中的多个设备，使所有设备能够同时连接到互联网。
可以这样想：如果 Bob 有一个路由器，但没有调制解调器，他将能够创建一个 LAN 并在该网络上的设备之间发送数据。但是，他无法将该网络连接到互联网。另一方面，Alice 有一个调制解调器，但没有路由器。她将能够将单个设备连接到互联网（例如，她的工作笔记本电脑），但不能将该互联网连接分发到多个设备（比如说，她自己的笔记本电脑和智能手机）。与此同时，Carol 有一个路由器和一个调制解调器。使用这两种设备，她可以与她的台式电脑、平板电脑和智能手机组成一个 LAN，并将它们同时连接到互联网。
有哪些不同类型的路由器？ 要将 LAN 连接到互联网，路由器首先需要与调制解调器通信。有两种主要的方式来实现这一点：
无线路由器：无线路由器使用以太网电缆连接到调制解调器。它通过将数据包从二进制代码转换为无线电信号来分发数据，然后用天线无线广播信号。无线路由器不建立 LAN；相反，它创建 WLAN（无线局域网），使用无线通信连接多个设备。 有线路由器：与无线路由器一样，有线路由器也使用以太网电缆连接到调制解调器。然后它使用单独的电缆连接到网络内的一个或多个设备，创建一个 LAN，并将该网络内的设备连接到互联网。 除了适用于小型 LAN 的无线和有线路由器外，还有许多专门类型的路由器，用于提供特定的功能：</description>
    </item>
    
    <item>
      <title>网络安全（五）| IP 路由（IP Routing）</title>
      <link>https://shaichunfeng.com/post/2022/03/31/what-is-routing/</link>
      <pubDate>Thu, 31 Mar 2022 22:48:39 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2022/03/31/what-is-routing/</guid>
      <description>网络路由是选择一个或多个网络上的路径的过程。路由原理可以应用于从电话网络到公共交通的任何类型的网络。在诸如互联网等数据包交换网络中，路由选择互联网协议 (IP) 数据包从其起点到目的地的路径。这些互联网路由决定由称为路由器的专用网络硬件做出。
如上图所示，对于要从计算机 A 到达计算机 B 的数据包，它应该通过网络 1、3 和 5 还是通过网络 2 和 4？数据包通过网络 2 和 4 的路径会更短，但是网络 1、3 和 5 在转发数据包时可能比 2 和 4 更快。这些都是网络路由器不断做出的选择类型。
路由如何工作？ 路由器通过参考内部路由表来决定如何沿网络路径路由数据包。路由表记录了数据包应到达路由器负责的每个目的地的路径。类似于列车时刻表，乘客会查阅时刻表以决定搭乘哪趟列车。路由表也是如此，但是用于网络路径而不是列车。
路由器以下列方式工作：路由器接收到数据包时，会读取数据包的标头*以查看其预期的目的地，这种方式类似于列车票务员检查乘客的车票以确定他们应该乘坐的列车。然后，根据路由表中的信息确定将数据包路由到何处。
路由器以每秒数百万次的速度处理数百万个数据包。当数据包到达其目的地时，它可能会被不同的路由器路由多次。
路由表可以是静态的，也可以是动态的。静态路由表不变化。网络管理员手动设置静态路由表。除非管理员手动更新这些表，否则，路由表完全可以确定数据包在网络上的路由。
动态路由表会自动更新。动态路由器使用各种路由协议（请参阅下文）来确定最短和最快的路径。它们还根据数据包到达目的地所需的时间做出决定 - 类似于 Google Maps、Waze 和其他 GPS 服务根据过去的驾驶性能和当前的驾驶条件确定最佳驾驶路线的方式。
动态路由需要更多的计算能力，这就是为什么较小的网络可能依赖静态路由的原因。但是对于中型和大型网络，动态路由要高效得多。
数据包头是附加在数据包上的一小束数据，可提供有用的信息，包括数据包的来源和去向，类似于在邮件包裹外部加盖的装箱单。
主要的路由协议是什么？ 在网络中，协议是格式化数据的标准化方法，因此任何连接的计算机都可以理解数据。路由协议是用于标识或通知网络路径的协议。
以下协议可帮助数据包在 Internet 上找到自己的路线：
IP：Internet 协议（IP）明确每个数据包的起点和目的地。路由器检查每个数据包的 IP 标头，以确定将其发送到何处。 BGP：边界网关协议（BGP）路由协议用于通知哪些网络控制哪些 IP 地址以及哪些网络相互连接。（发出这些 BGP 通知的大型网络称为自治系统 。）BGP 是一种动态路由协议。 以下协议在 AS 中路由数据包：</description>
    </item>
    
    <item>
      <title>网络安全（四）| 网络安全（Network security）</title>
      <link>https://shaichunfeng.com/post/2022/03/31/network-security/</link>
      <pubDate>Thu, 31 Mar 2022 22:42:39 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2022/03/31/network-security/</guid>
      <description>网络安全是一类使内部网络免受攻击和数据泄露的实践和技术。它包括访问控制、网络攻击防护、恶意软件检测和其他安全措施。 “网络安全”最常用于指对大型企业网络的保护。
网络定义 网络是由两个或多个连接的计算设备组成的群体。网络的规模涵盖小型的个人区域网络 (PAN) 和局域网 (LAN) 到大型的广域网 (WAN)，这些网络跨越很远的距离连接小型网络。
如今，几乎所有企业都依赖某种类型的网络来提高生产力，无论是允许员工访问互联网的 LAN、连接各个办公地点的 WAN，还是在云中执行这些功能的网络即服务 (NaaS)。
有哪些常见的网络安全风险？ 像任何重要的企业资产一样，网络可能以各种方式受到损害。需要准备应对的威胁包括：
未经授权的访问：如果未经授权的用户进入网络，他们就可以查看本来可以保持私有的机密信息。他们还可能泄露机密数据或破坏内部系统。 DDoS 攻击：分布式拒绝服务 (DDoS) 攻击旨在通过用垃圾流量淹没网络或服务器来减缓或拒绝向合法用户提供服务。DDoS 攻击可能使网络不堪重负，从而使其不再运作。 漏洞利用：攻击者可以利用登录门户、应用程序、硬件或其他方面的漏洞渗透到网络中，达到各种恶意目的。 恶意软件感染：常见的恶意软件感染包括加密或破坏数据的勒索软件；可以在整个网络中快速复制的恶意软件——蠕虫；以及允许攻击者跟踪用户行动的间谍软件。恶意软件可以从一系列来源进入网络，包括不安全的网站、受感染的员工设备或有针对性的外部攻击。 内部威胁：内部雇员或承包商在不了解安全最佳实践的情况下，会无意中破坏网络安全或泄露数据。在其他情况下，用户可能因为自己的原因而故意破坏网络或泄露数据。 有哪些重要的网络安全技术？ 网络安全是一个广泛的领域。下面只是组织可以用来保护其网络的一些技术。为了减少复杂性，大多数组织尽量依靠少数供应商来实现网络安全；许多企业都在寻求能同时提供上述几种技术的供应商。
访问控制 访问控制限制对数据和用于操作该数据的软件的访问。这对于防止未经授权的访问和降低内部威胁的风险至关重要。身份和访问管理 (IAM) 解决方案可以在这个领域提供帮助。许多企业使用虚拟专用网络 (VPN) 来控制访问； 但如今，已经有了 VPN 的替代品。
用户身份验证 身份验证是访问控制的一个重要组成部分。使用双因素身份验证 (2FA) 而不是简单的密码，是使网络更安全的一个重要步骤。
防火墙 防火墙会从网络流量中过滤掉潜在威胁。它们可以阻止恶意软件攻击、漏洞利用、机器人攻击和其他威胁。传统的防火墙在企业的物理位置使用硬件设备运行。如今，许多防火墙可以在软件或云中运行，消除了对防火墙硬件的需求。
DDoS 保护 网站和网络基础设施都需要防御 DDoS 攻击以保持运作。特别是，网络基础设施需要在网络层而不是应用程序层进行 DDoS 缓解。
数据丢失防护（DLP） 防火墙和 DDoS 防护可以防止外部攻击进入网络，数据丢失防护 (DLP) 则阻止内部数据被带出网络。</description>
    </item>
    
    <item>
      <title>网络安全（三）| 安全访问服务边缘（SASE）</title>
      <link>https://shaichunfeng.com/post/2022/03/31/what-is-sase/</link>
      <pubDate>Thu, 31 Mar 2022 22:30:24 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2022/03/31/what-is-sase/</guid>
      <description>安全访问服务边缘简称 SASE，是一种基于云的 IT 模型，它将软件定义的网络与网络安全功能捆绑在一起，并从单一服务提供商交付。“SASE”一词由全球研究和咨询公司 Gartner 在 2019 年提出。
SASE 方法可以更好地控制和了解访问公司网络的用户、流量和数据，这些功能对于现代全球分布的组织来说至关重要。使用 SASE 构建的网络灵活且可扩展，能够通过任何设备连接分布在全球各地的员工和办公室。
SASE 包括哪些安全功能？ SASE 将软件定义的广域网 (SD-WAN) 功能与一些网络安全功能相结合，所有这些功能都从一个云平台提供。通过这种方式，SASE 让员工能够从任何地方进行身分验证并安全地连接到内部资源，让企业更好地控制进出其内部网络的流量和数据。
SASE 包括四个核心安全组件：
安全 Web 网关 (SWG)：SWG 可从 Web 流量中过滤不需要的内容，阻止未经授权的用户行为，并执行企业安全策略，从而预防网络威胁和数据泄露。SWG 可以部署在任何地方，因此是确保远程员工安全的理想选择。 云访问安全代理 (CASB)：CASB 为云托管服务执行多项安全功能，包括：揭示影子 IT（未经授权的公司系统）、通过访问控制和数据丢失防护 (DLP) 保护机密数据，以及确保符合数据隐私法规。 零信任网络访问 (ZTNA)：ZTNA 平台锁定内部资源，不允许公开查看，并要求对每个受保护应用程序的每个用户和每台设备进行实时验证，以助防止潜在的数据泄露。 防火墙即服务（FWaaS）：FWaaS 是指从云端作为服务交付的防火墙。FWaaS 保护云端平台、基础设施和应用程序免受网络攻击。与传统防火墙不同，FWaaS 不是物理设备，而是一组安全能力，其中包括 URL 过滤、入侵防御以及对所有网络流量的统一策略管理。 根据供应商和企业的需求，这些核心组件可能与其他安全服务捆绑在一起，包括 Web 应用程序和 API 保护 (WAAP)、远程浏览器隔离或 Wi-Fi 热点保护。</description>
    </item>
    
    <item>
      <title>网络安全（二）| 网络即服务（NaaS）</title>
      <link>https://shaichunfeng.com/post/2022/03/31/network-as-a-service-naas/</link>
      <pubDate>Thu, 31 Mar 2022 22:20:24 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2022/03/31/network-as-a-service-naas/</guid>
      <description>网络即服务 (NaaS) 是一种云服务模式，在这种模式中，客户从云供应商那里租用网络服务。NaaS 允许客户操作他们自己的网络，而不需要维护他们自己的网络基础设施。与其他云服务一样，NaaS 供应商使用软件运行网络功能，其本质上允许公司完全在没有硬件的情况下建立自己的网络。他们只要有互联网连接即可。
NaaS 可以取代虚拟专用网络 (VPN)、多协议标签交换 (MPLS) 连接或其他传统的网络配置。它还可以取代内部网络硬件，如防火墙设备和负载平衡器。作为一种较新的路由流量和应用安全策略的模式，NaaS 对企业网络架构产生了重大影响。
NaaS 的发展过程 当大多数企业配置他们的网络基础设施时，互联网本身并不被认为是开展业务的可信场所。因此，他们建立了自己的内部私有互联网版本，并通过租用链接将设施相互连接。他们需要配置自己的广域网 (WAN)，每个办公地点都需要自己的防火墙、DDoS 防护、负载平衡等硬件。企业还需要使用 MPLS 等方法在每个位置之间建立专用连接。
当员工连接到互联网而不是内部网络时，他们的流量必须先经由 VPN 通过公司网络基础设施，然后才能到达互联网。例如，如果一家公司的总部位于德克萨斯州奥斯汀，而路易斯安那州新奥尔良分公司的一名公司员工需要加载一个网站，他们对该网站的 HTTP 请求将通过公司 VPN，通过 MPLS 链接到位于奥斯汀的总部（距离约 800 公里），然后向外延伸到更广泛的互联网。
随着一些业务活动开始迁移到云中，这种模式很快变得低效。例如，假设新奥尔良的员工经常使用 SaaS 应用程序，这意味着他们需要不断地通过互联网加载内容。他们的请求以及其他员工的请求将成为奥斯汀数据中心的瓶颈，从而降低网络服务速度。
此外，随着云计算变得更加高效，更多的功能开始通过云来提供。如今，DDoS 缓解、防火墙、负载平衡和其他重要的网络功能都可以在云中运行，无需内部 IT 团队构建和维护这些服务。
出于这些原因，NaaS 是一种比依赖内部维护的 WAN 更有效的选择，后者需要不断维护并且经常为网络流量造成瓶颈。借助 NaaS，公司员工可以通过外部供应商管理和保护的虚拟网络直接连接到他们的云服务，而不是内部 IT 团队试图跟上对网络服务的需求。
如果我们的示例公司切换到 NaaS 模式，则位于新奥尔良的员工不再需要等待他们的网络流量通过所有内部公司基础设施。相反，他们只需连接到互联网并通过浏览器登录，就可以访问他们需要的所有云服务。同时，NaaS 提供商保护他们的浏览活动、保护他们的数据，并尽可能高效地将他们的 Web 流量路由到任何需要去的地方。
从许多方面来说，NaaS 是几十年来业务流程向云迁移的逻辑结果。如今，整个网络可以作为一种服务提供，而不仅仅是软件、基础设施或平台。</description>
    </item>
    
    <item>
      <title>网络安全（一）| 企业网络（Enterprise networking）</title>
      <link>https://shaichunfeng.com/post/2022/03/31/enterprise-networking/</link>
      <pubDate>Thu, 31 Mar 2022 22:02:24 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2022/03/31/enterprise-networking/</guid>
      <description>网络是一组相互连接的计算机，而企业网络就是这样一个为满足大型企业的需求而构建的组。企业网络由局域网 (LAN) 组成，局域网又连接到广域网 (WAN) 和云。
在企业环境中，数据中心、分支机构、公共和私有云、物联网 (IoT) 设备以及组织的个人员工都需要可靠的网络连接。这些连接让企业能够交换数据、运行业务流程并分析网络上发生的事情——从本质上讲，网络使运行业务成为可能。
与互联网不同，企业网络并非对所有想连接的人开放。企业网络将连接限制在特定的用户、设备和设施。它们通常使用虚拟专用网络 (VPN) 或传输层安全性 (TLS) 加密对通过它们的数据进行加密。
企业网络也因其规模而不同于其他类型的网络。一般人可以访问家庭 LAN，通过单个路由器将一些设备连接到互联网。但企业运行的内部网络将数千台设备相互连接并连接到互联网。
企业网络运作方式 多年来，企业网络的主要关注点是将所有人和物连接到本地自托管的集中式数据中心，在该数据中心保存数据并运行应用程序。这种访问是通过将用户和设备连接到公司办公室的 LAN 来提供的。每个办公室的 LAN 通过大型企业 WAN 连接到其他办公室，通常通过专用的多协议标签交换 (MPLS) 路由构建。
企业网络基础设施由物理设备组成，它们通过以太网电缆和 WiFi 信号的组合相互连接并连接到个人计算机、打印机和物联网设备。使用的网络设备包括：
路由器将数据从一个网络发送到另一个网络，实现网络到网络的连接和互联网访问。 交换机将网络内的数据转发给各个设备。 网关使用多种协议，在不同的网络之间以及在 OSI 模型的多个层之间提供连接。 防火墙处理进出网络的所有流量，以阻止潜在攻击。 负载平衡器在数据中心的多个服务器之间分配网络流量，以确保没有服务器过载（负载平衡器可以为 Web 应用程序做同样的事情）。 VPN 服务器建立和终止 VPN 连接，提供对内部网络的安全访问。 通常情况下，连接到企业网络需要连接到 VPN。VPN 加密用户和 VPN 服务器之间的流量，此时用户可以访问内部 LAN。
企业网络的发展变化历程 如今的企业网络与几年前企业网络的运作方式大不相同。云迁移和新的安全挑战相结合，使得上述企业网络模型不适合现代企业的需求，尽管许多组织仍在使用它。
如今的员工可能从办公室内部和外部连接到网络。他们连接到云和企业内部的数据中心（混合云模型），或者只连接到云。这使得集中式网络基础设施效率低下，因为网络成为进出云的流量的瓶颈。</description>
    </item>
    
    <item>
      <title>Golang设计模式（二） | 工厂模式</title>
      <link>https://shaichunfeng.com/post/2022/03/26/golang-design-patten-for-factory/</link>
      <pubDate>Sat, 26 Mar 2022 15:20:29 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2022/03/26/golang-design-patten-for-factory/</guid>
      <description>工厂模式（Factory Pattern）是面向对象编程中的常用模式。在 Golang 项目开发中，你可以通过使用简单工厂模式、抽象工厂模式、工厂方法模式，来使代码更简洁明了。 简单工厂模式返回结构体类型；而抽象工厂模式返回接口类型；工厂方法返回一个闭包，下面具体的看看每一种工厂模式的使用。
Golang 中的结构体，可以理解为面向对象编程中的类，例如 Student 结构体（类）实现了 SayHello 方法。
1 2 3 4 5 6 7 8 9 type Student struct { name string // 可以使用uint8类型表示例sex别，这里为了仅仅只是为了直观可视 sex string } func (s Student) SayHello() { fmt.Printf(&amp;#34;Hi! My name is %s, %s&amp;#34;, s.name, s.sex) } 有了 Student 结构体（类），就可以创建 Student 实例。我们可以通过简单工厂模式、抽象工厂模式、工厂方法模式这三种方式，来创建一个 Student 实例。</description>
    </item>
    
    <item>
      <title>Golang设计模式（一） | 单例模式</title>
      <link>https://shaichunfeng.com/post/2022/03/26/golang-design-patten-for-singleten/</link>
      <pubDate>Sat, 26 Mar 2022 15:02:24 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2022/03/26/golang-design-patten-for-singleten/</guid>
      <description>单例模式（Singleton Pattern），是最简单的一个模式。在 Go 中，单例模式指的是全局只有一个实例，并且它负责创建自己的对象。单例模式不仅有利于减少内存开支，还有减少系统性能开销、防止多个实例产生冲突等优点。
因为单例模式保证了实例的全局唯一性，而且只被初始化一次，所以比较适合『全局共享一个实例，且只需要被初始化一次的场景』，例如数据库实例、全局配置、全局任务池等。
单例模式又分为饿汉方式和懒汉方式。饿汉方式指全局的单例实例在包被加载时创建，而懒汉方式指全局的单例实例在第一次被使用时创建。你可以看到，这种命名方式非常形象地体现了它们不同的特点。
接下来，我就来分别介绍下这两种方式。先来看饿汉方式。
饿汉方式 下面是一个饿汉方式的单例模式代码：
1 2 3 4 5 6 7 8 9 10 package singleton type singleton struct { } var instance *singleton = &amp;amp;singleton{} func GetInstanceOr() *singleton { return instance } 你需要注意，因为实例是在包被导入时初始化的，所以如果初始化操作比较耗时，会导致程序加载时间比较长。
懒汉方式 懒汉方式是开源项目中使用最多的，但它的缺点是非并发安全，在实际使用时需要加锁。以下是懒汉方式不加锁的一个实现：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 package singleton type singleton struct { } var instance *singleton func GetInstanceOr() *singleton { if instance == nil { instance = &amp;amp;singleton{} } return instance } 可以看到，在创建 @@instance@@ 时，如果 @@instance==nil@@，就会再创建一个 @@instance@@ 实例，这时候单例就会有多个实例。</description>
    </item>
    
    <item>
      <title>Linux服务器设置时间</title>
      <link>https://shaichunfeng.com/post/2021/09/19/linux-server-settings-time/</link>
      <pubDate>Sun, 19 Sep 2021 16:38:01 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/09/19/linux-server-settings-time/</guid>
      <description>Linux服务器新安装系统时区有可能不正确，直接导致的结果就是所有产生的数据所使用的时间都不是本地时间，对数据的影响比较大，因为时区不正嘛，所以也就会出来这种情况。Linux服务器的时间设置，可以通过手动配置也可以通过网络进行同步，还可以通过修改系统的时区来达到我们的预期。
修改时区 通过修改时区的方式有两种方式，一种是即时生效，一种是重启生效。
即时生效 可以使用系统预置的时区文件中的 Shanghai 文件，对 /etc/localtime 文件进行覆盖操作：
1 $ sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 修改之后可以通过date命令进行确认是否生效：
1 2 $ sudo date 2021年 09月 19日 星期日 16:58:43 CST 重启生效 再一种方式是通过修改系统时钟配置文件@@/etc/sysconfig/clock@@来修改系统时间配置。</description>
    </item>
    
    <item>
      <title>MacOS使用VMware安装rockylinux</title>
      <link>https://shaichunfeng.com/post/2021/09/16/mac-use-vmware-install-rackylinux/</link>
      <pubDate>Thu, 16 Sep 2021 11:54:58 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/09/16/mac-use-vmware-install-rackylinux/</guid>
      <description>在MacOS系统下安装rockylinux首先就是需要安装一个虚拟机，MacOS系统虚拟机产品有 VMware、VirtualBox、PD可供选择使用，VirtualBox 是开源免费产品，不过在MacOS下个人使用的过程中感觉不够完美，PD 和 VMware 是收费产品，现阶段 PD 对 M1 处理器支持的比较好，不过好在 VMware 有一个 VMware Fusion Player 版本，可供个人使用，一直在使用感觉还不错，并且可以使用 vmrun 终端工具管理虚拟机非常方便。安装 VMware Fusion Player 之后需要安装 rockylinux，虚拟机安装@@Linux@@操作系统跟物理机没有什么差别，下面操作步骤中会说。最后想简单说明一下 vmware 虚拟机软件提供的 vmrun 终端工具如何使用，接下来进行详情说明~
Step1、安装VMware VMware Fusion Player 可以到 VMware 官网进行下载。
下载需要登录用户，如果没有账号请先注册一个，登录之后可以看到如下页面:
单点下载 Manually Download 下载就可以了，并且还有一个 LICENSE KEYS 拷贝下来保存到本地文件中或其它存储介质均可。
安装的话也比较简单只需要双击下载下来的 VMware-Fusion-12.1.2-17964953.dmg 文件，一直点击 next 即可，然后到输入 LICENSE KEYS 的页面时，将拷贝下来的 LICENSE KEYS 内容粘贴输入框激活即可。</description>
    </item>
    
    <item>
      <title>撞库攻击</title>
      <link>https://shaichunfeng.com/post/2021/08/20/credential-stuffing-attacks/</link>
      <pubDate>Fri, 20 Aug 2021 12:12:35 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/08/20/credential-stuffing-attacks/</guid>
      <description>撞库攻击可能会使个人和企业数据面临严重风险。在这里，我们将进一步了解撞库攻击，如何进行检测和防范，以及为什么它们对企业和个人都构成如此大的威胁。
什么是撞库？ 撞库攻击是网络犯罪分子试图使用一组帐密同时访问多个帐户。撞库之所以如此有效，是因为近三分之二的互联网用户重复使用他们的密码。网络犯罪分子在几分钟或几个小时的时间内即可将被盗的帐密输入数千个网站，从社交媒体帐户到公司专有软件等，都会受到影响。
撞库攻击的原理是什么？ 撞库攻击取决于密码的重复使用。由于有很多人将密码重复用于多个帐户，因此仅凭一组帐密足以暴露其大部分或全部帐户。网络犯罪分子利用僵尸网络等工具在多个设备上执行多条战线攻击，只需一组帐密即可扩展攻击能力。
据估计，大约 80% 的数据入侵 都与泄露密码有关，这就引出了一个问题：为什么这么多人仍然使用一个密码来管理他们的帐户？
当攻击者成功进行撞库攻击后，他们就有可能可以控制用户的银行信息、社交媒体帐户等。这可能直接导致金钱或其他资产被盗、敲诈勒索或身份盗窃。
撞库与密码喷洒 撞库和密码喷洒类似，但密码喷洒取决于用户名，而不是整套帐密。密码喷洒涉及使用经过验证的用户名，并将其与一些不同的常见密码组合尝试用于多个帐户。如果用户没有养成良好的密码习惯，则通过猜测常见密码可能会危及其大多数或全部帐户。
如何检测撞库攻击 及早检测到撞库攻击可以给您足够的时间做出反应并保护您的帐户。方法如下：
对于个人用户 检测撞库攻击非常简单，只需对每个帐户进行两步验证/多步验证即可。如果您的帐户可能被篡改，您将收到警报，并且要求提供一组额外的凭据才能登录帐户。
对于企业用户 用于机器人流量的异常检测器。 这些工具有助于检测传入网络流量的异常情况，并在有机器人程序传入时通知您。撞库依赖于能够快速输入帐密的自主机器人，因此检测它们可及早采取措施。 定期扫描泄露数据库检查共用登录。 执行包括扫描数据库在内的常规系统维护可以提供预警，并可能减少数据泄露造成的损失。 使用设备和浏览器指纹。 生物识别凭据可提供高强度的唯一登录。密码与生物识别帐密相结合可以使帐户安全性强 10 倍。 监视 VPN。 如何防范撞库攻击 对于个人用户 尽可能使用多步验证/两步验证 了解密码安全 使用密码管理程序自动生成高强度随机密码，确保登录帐密安全 不要重复使用密码 使用复杂的安全问题和可靠的登录帐密 对于企业用户 为所有公司帐户实施多步验证/两步验证 在登录页面使用 CAPTCHA 在全公司范围提升密码和网络安全教育 制定严格的网络安全政策 限制源于自主系统编号的流量 使用 Web 应用防火墙 (WAF) 使用 IP 块列表限制身份验证请求/登录尝试 从 Web 信息/历史记录中保留已知不良 IP 的运行列表/块 相关参考 Keeper 撞库攻击指南 </description>
    </item>
    
    <item>
      <title>漏洞原理</title>
      <link>https://shaichunfeng.com/post/2021/08/20/exploits-principle/</link>
      <pubDate>Fri, 20 Aug 2021 10:30:37 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/08/20/exploits-principle/</guid>
      <description>文件上传漏洞 导致该漏洞的原因在于代码作者没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。
1、前端JavaScript过滤绕过
如果想要在一个开启了JavaScript验证的网站上传一句话木马，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-&amp;gt;打开intercept(拦截)-&amp;gt;将木马的后缀名改为jpg格式-&amp;gt;点击forward将数据包发回，这样就可以上传成功。最后用菜刀连接。 还有一种方法就是在地址栏输入：about:config，搜索javascript:enabled,双击关闭，也可以成功。
2、Content-Type绕过
Content-Type一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件。 如果想要在一个有type验证的网站上传一句话木马，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-&amp;gt;打开intercept(拦截)-&amp;gt;修改包内的Content-Type值：将application/octet-stream修改为image/jpeg。-&amp;gt;点击forward将数据包发回，这样就可以上传成功。
3、扩展名绕过
如果想要绕过有扩展名验证的网站上传一句话木马，这个很简单，可以把后缀换成大小写的方式绕过。
4、00截断绕过
想通过00%截断来绕过有验证的网站上传一句话木马。将上传的文件名命名为test.php%00.jpg格式，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-&amp;gt;打开intercept(拦截)-&amp;gt;修改包内的Content-Type值：将%00右击选择Covert selection选项中的URL进行编码-&amp;gt;点击forward将数据包发回，这样就可以上传成功。注：系统在对文件名的读取时，如果遇到%00，就会认为读取已结束，不在读取后面的内容。
解析漏洞 文件包含漏洞 XSS跨站脚本攻击 CSRF 目录遍历漏洞 命令执行漏洞 代码执行漏洞 反序列化漏洞 参考链接 常见漏洞原理简介 </description>
    </item>
    
    <item>
      <title>Go 私有库访问设置</title>
      <link>https://shaichunfeng.com/post/2021/08/07/go-private-library-access-settings/</link>
      <pubDate>Sat, 07 Aug 2021 17:57:25 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/08/07/go-private-library-access-settings/</guid>
      <description>私有库是那些不想公开的库，不开源或不共享的存储库，比如公司内部开发的go包，或自己个人Github服务器上的私有go包，通过go get直接下载私有包是不被允许的，要通过一些设置才可以访问私有存储库。
配置Git 1 $ git config --global url.git@github.com:.insteadOf https://github.com/ 最终会将上面执行的命令添加到git配置文件中，具体如下所示：
1 2 3 $ cat ~/.gitconfig [url &amp;#34;git@github.com:&amp;#34;] insteadOf = https://github.com/ 配置Go环境 为了让 Go 模块工作（使用 Go 1.11 或更新版本），您还需要设置 GOPRIVATE 变量，以避免使用公共服务器来获取代码：
1 $ go env -w GOPRIVATE=github.com/private/repo 如果需要访问多个存储库则需要多次添加，并以逗号分隔
1 $ go env -w GOPRIVATE=github.com/private/repo-a,github.com/private/repo-b 下载私有库 1 $ go get github.com/private/repo </description>
    </item>
    
    <item>
      <title>Slice 具体使用</title>
      <link>https://shaichunfeng.com/post/2021/07/26/slice-use/</link>
      <pubDate>Mon, 26 Jul 2021 18:22:09 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/26/slice-use/</guid>
      <description>删除Slice的一个元素 1 2 3 func remove(slice []int, index int) []int { return append(slice[:index], slice[index+1:]...) } 清空Slice的所有元素 1 2 3 func remove(slice []int) []int { return slice[:0] } </description>
    </item>
    
    <item>
      <title>Go系列教程（三十六） | 写入文件(Write File)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/36-write-file/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:36 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/36-write-file/</guid>
      <description>在这一章我们将学习如何使用 Go 语言将数据写到文件里面。并且还要学习如何同步的写到文件里面。
这章教程包括如下几个部分：
将字符串写入文件 将字节写入文件 将数据一行一行的写入文件 追加到文件里 并发写文件 请在本地运行所有本教程的程序，因为 playground 对文件的操作支持的并不好。
将字符串写入文件 最常见的写文件就是将字符串写入文件。这个写起来非常的简单。这个包含以下几个阶段。
创建文件 将字符串写入文件 我们将得到如下代码。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { f, err := os.</description>
    </item>
    
    <item>
      <title>Go系列教程（三十五） | 读取文件(Read file)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/35-read-file/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:35 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/35-read-file/</guid>
      <description>文件读取是所有编程语言中最常见的操作之一。本教程我们会学习如何使用 Go 读取文件。
本教程分为如下小节。
将整个文件读取到内存 使用绝对文件路径 使用命令行标记来传递文件路径 将文件绑定在二进制文件中 分块读取文件 逐行读取文件 将整个文件读取到内存 将整个文件读取到内存是最基本的文件操作之一。这需要使用 ioutil 包中的 ReadFile 函数。
让我们在 Go 程序所在的目录中，读取一个文件。我已经在 GOPATH（译注：原文是 GOROOT，应该是笔误）中创建了文件夹，在该文件夹内部，有一个文本文件 test.txt，我们会使用 Go 程序 filehandling.go 来读取它。test.txt 包含文本 “Hello World. Welcome to file handling in Go”。我的文件夹结构如下：
1 2 3 4 src filehandling filehandling.go test.txt 接下来我们来看看代码。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; ) func main() { data, err := ioutil.</description>
    </item>
    
    <item>
      <title>Go系列教程（三十四） | 反射(Reflection)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/34-reflection/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:34 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/34-reflection/</guid>
      <description>反射是 Go 语言的高级主题之一。我会尽可能让它变得简单易懂。
本教程分为如下小节。
什么是反射？ 为何需要检查变量，确定变量的类型？ reflect 包 reflect.Type 和 reflect.Value reflect.Kind NumField() 和 Field() 方法 Int() 和 String() 方法 完整的程序 我们应该使用反射吗？ 让我们来逐个讨论这些章节。
什么是反射？ 反射就是程序能够在运行时检查变量和值，求出它们的类型。你可能还不太懂，这没关系。在本教程结束后，你就会清楚地理解反射，所以跟着我们的教程学习吧。
为何需要检查变量，确定变量的类型？ 在学习反射时，所有人首先面临的疑惑就是：如果程序中每个变量都是我们自己定义的，那么在编译时就可以知道变量类型了，为什么我们还需要在运行时检查变量，求出它的类型呢？没错，在大多数时候都是这样，但并非总是如此。
我来解释一下吧。下面我们编写一个简单的程序。
1 2 3 4 5 6 7 8 9 10 package main import ( &amp;#34;fmt&amp;#34; ) func main() { i := 10 fmt.</description>
    </item>
    
    <item>
      <title>Go系列教程（三十三） | 函数是一等公民(Functions Are First Class Citizens)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/33-functions-are-first-class-citizens/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:14 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/33-functions-are-first-class-citizens/</guid>
      <description>什么是头等（第一类）函数？ 支持头等函数（First Class Function）的编程语言，可以把函数赋值给变量，也可以把函数作为其它函数的参数或者返回值。Go 语言支持头等函数的机制。
本教程我们会讨论头等函数的语法和用例。
匿名函数 我们来编写一个简单的示例，把函数赋值给一个变量。
1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := func() { fmt.Println(&amp;#34;hello world first class function&amp;#34;) } a() fmt.Printf(&amp;#34;%T&amp;#34;, a) } 在 playground 上运行
在上面的程序中，我们将一个函数赋值给了变量 a（第 8 行）。这是把函数赋值给变量的语法。你如果观察得仔细的话，会发现赋值给 a 的函数没有名称。由于没有名称，这类函数称为匿名函数（Anonymous Function）。</description>
    </item>
    
    <item>
      <title>Go系列教程（三十二） | panic 和 recover(Panic and Recover)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/32-panic-and-recover.md/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:13 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/32-panic-and-recover.md/</guid>
      <description>什么是 panic？ 在 Go 语言中，程序中一般是使用错误来处理异常情况。对于程序中出现的大部分异常情况，错误就已经够用了。
但在有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 panic 来终止程序。当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪（Stack Trace），最后程序终止。在编写一个示例程序后，我们就能很好地理解这个概念了。
在本教程里，我们还会接着讨论，当程序发生 panic 时，使用 recover 可以重新获得对该程序的控制。
可以认为 panic 和 recover 与其他语言中的 try-catch-finally 语句类似，只不过一般我们很少使用 panic 和 recover。而当我们使用了 panic 和 recover 时，也会比 try-catch-finally 更加优雅，代码更加整洁。
什么时候应该使用 panic？ 需要注意的是，你应该尽可能地使用错误，而不是使用 panic 和 recover。只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制。
panic 有两个合理的用例。
发生了一个不能恢复的错误，此时程序不能继续运行。 一个例子就是 web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 panic，因为如果不能绑定端口，啥也做不了。 发生了一个编程上的错误。 假如我们有一个接收指针参数的方法，而其他人使用 nil 作为参数调用了它。在这种情况下，我们可以使用 panic，因为这是一个编程错误：用 nil 参数调用了一个只能接收合法指针的方法。 panic 示例 内建函数 panic 的签名如下所示：</description>
    </item>
    
    <item>
      <title>Go系列教程（三十一） | 自定义错误(Custom Error)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/31-custom-error/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:12 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/31-custom-error/</guid>
      <description>在上一教程里，我们学习了 Go 中的错误是如何表示的，并学习了如何处理标准库里的错误。我们还学习了从标准库的错误中提取更多的信息。
在本教程中，我们会学习如何创建我们自己的自定义错误，并在我们创建的函数和包中使用它。我们会使用与标准库中相同的技术，来提供自定义错误的更多细节信息。
使用 New 函数创建自定义错误 创建自定义错误最简单的方法是使用 errors 包中的 New 函数。
在使用 New 函数 创建自定义错误之前，我们先来看看 New 是如何实现的。如下所示，是 errors 包 中的 New 函数的实现。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Package errors implements functions to manipulate errors. package errors // New returns an error that formats as the given text.</description>
    </item>
    
    <item>
      <title>Go系列教程（三十） | 错误处理(Error Handle)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/30-error-handle.md/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:11 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/30-error-handle.md/</guid>
      <description>什么是错误？ 错误表示程序中出现了异常情况。比如当我们试图打开一个文件时，文件系统里却并没有这个文件。这就是异常情况，它用一个错误来表示。
在 Go 中，错误一直是很常见的。错误用内建的 error 类型来表示。
就像其他的内建类型（如 int、float64 等），错误值可以存储在变量里、作为函数的返回值等等。
示例 现在我们开始编写一个示例，该程序试图打开一个并不存在的文件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { f, err := os.Open(&amp;#34;/test.txt&amp;#34;) if err != nil { fmt.Println(err) return } fmt.Println(f.Name(), &amp;#34;opened successfully&amp;#34;) } 在 playground 中运行</description>
    </item>
    
    <item>
      <title>Go系列教程（二十九） | 延迟调用(Defer) </title>
      <link>https://shaichunfeng.com/post/2021/07/19/29-defer/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:10 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/29-defer/</guid>
      <description>什么是 defer？ defer 语句的用途是：含有 defer 语句的函数，会在该函数将要返回之前，调用另一个函数。这个定义可能看起来很复杂，我们通过一个示例就很容易明白了。
示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( &amp;#34;fmt&amp;#34; ) func finished() { fmt.Println(&amp;#34;Finished finding largest&amp;#34;) } func largest(nums []int) { defer finished() fmt.</description>
    </item>
    
    <item>
      <title>Go系列教程（二十八） | 多态(Polymorphism)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/28-polymorphism/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:09 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/28-polymorphism/</guid>
      <description>Go 通过接口来实现多态。我们已经讨论过，在 Go 语言中，我们是隐式地实现接口。一个类型如果定义了接口所声明的全部方法，那它就实现了该接口。现在我们来看看，利用接口，Go 是如何实现多态的。
使用接口实现多态 一个类型如果定义了接口的所有方法，那它就隐式地实现了该接口。
所有实现了接口的类型，都可以把它的值保存在一个接口类型的变量中。在 Go 中，我们使用接口的这种特性来实现多态。
通过一个程序我们来理解 Go 语言的多态，它会计算一个组织机构的净收益。为了简单起见，我们假设这个虚构的组织所获得的收入来源于两个项目：fixed billing 和 time and material。该组织的净收益等于这两个项目的收入总和。同样为了简单起见，我们假设货币单位是美元，而无需处理美分。因此货币只需简单地用 int 来表示。（我建议阅读 https://forum.golangbridge.org/t/what-is-the-proper-golang-equivalent-to-decimal-when-dealing-with-money/413 上的文章，学习如何表示美分。感谢 Andreas Matuschek 在评论区指出这一点。）
我们首先定义一个接口 Income。
1 2 3 4 type Income interface { calculate() int source() string } 上面定义了接口 Interface，它包含了两个方法：calculate() 计算并返回项目的收入，而 source() 返回项目名称。
下面我们定义一个表示 FixedBilling 项目的结构体类型。
1 2 3 4 type FixedBilling struct { projectName string biddedAmount int } 项目 FixedBillin 有两个字段：projectName 表示项目名称，而 biddedAmount 表示组织向该项目投标的金额。</description>
    </item>
    
    <item>
      <title>Go系列教程（二十七） | 组合替代继承(Combination Replaces Inheritance)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/27-combination-replaces-inheritance/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:08 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/27-combination-replaces-inheritance/</guid>
      <description>Go 不支持继承，但它支持组合（Composition）。组合一般定义为“合并在一起”。汽车就是一个关于组合的例子：一辆汽车由车轮、引擎和其他各种部件组合在一起。
通过嵌套结构体进行组合 在 Go 中，通过在结构体内嵌套结构体，可以实现组合。
组合的典型例子就是博客帖子。每一个博客的帖子都有标题、内容和作者信息。使用组合可以很好地表示它们。通过学习本教程后面的内容，我们会知道如何实现组合。
我们首先创建一个 author 结构体。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( &amp;#34;fmt&amp;#34; ) type author struct { firstName string lastName string bio string } func (a author) fullName() string { return fmt.Sprintf(&amp;#34;%s %s&amp;#34;, a.</description>
    </item>
    
    <item>
      <title>Go系列教程（二十六） | 结构体(Struct)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/26-struct/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:07 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/26-struct/</guid>
      <description>Go 支持面向对象吗？ Go 并不是完全面向对象的编程语言。Go 官网的 FAQ 回答了 Go 是否是面向对象语言，摘录如下。
可以说是，也可以说不是。虽然 Go 有类型和方法，支持面向对象的编程风格，但却没有类型的层次结构。Go 中的“接口”概念提供了一种不同的方法，我们认为它易于使用，也更为普遍。Go 也可以将结构体嵌套使用，这与子类化（Subclassing）类似，但并不完全相同。此外，Go 提供的特性比 C++ 或 Java 更为通用：子类可以由任何类型的数据来定义，甚至是内建类型（如简单的“未装箱的”整型）。这在结构体（类）中没有受到限制。
在接下来的教程里，我们会讨论如何使用 Go 来实现面向对象编程概念。与其它面向对象语言（如 Java）相比，Go 有很多完全不同的特性。
使用结构体，而非类 Go 不支持类，而是提供了结构体。结构体中可以添加方法。这样可以将数据和操作数据的方法绑定在一起，实现与类相似的效果。
为了加深理解，我们来编写一个示例吧。
在示例中，我们创建一个自定义包，它帮助我们更好地理解，结构体是如何有效地取代类的。
在你的 Go 工作区创建一个名为 oop 的文件夹。在 opp 中再创建子文件夹 employee。在 employee 内，创建一个名为 employee.go 的文件。
文件夹结构会是这样：
1 workspacepath -&amp;gt; oop -&amp;gt; employee -&amp;gt; employee.go 请将 employee.</description>
    </item>
    
    <item>
      <title>Go系列教程（二十五） | Go互斥锁(Mutex)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/25-go-mutex/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:06 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/25-go-mutex/</guid>
      <description>本教程我们学习 Mutex。我们还会学习怎样通过 Mutex 和信道来处理竞态条件（Race Condition）。
临界区 在学习 Mutex 之前，我们需要理解并发编程中临界区（Critical Section）的概念。当程序并发地运行时，多个 Go 协程不应该同时访问那些修改共享资源的代码。这些修改共享资源的代码称为临界区。例如，假设我们有一段代码，将一个变量 x 自增 1。
1 x = x + 1 如果只有一个 Go 协程访问上面的代码段，那都没有任何问题。
但当有多个协程并发运行时，代码却会出错，让我们看看究竟是为什么吧。简单起见，假设在一行代码的前面，我们已经运行了两个 Go 协程。
在上一行代码的内部，系统执行程序时分为如下几个步骤（这里其实还有很多包括寄存器的技术细节，以及加法的工作原理等，但对于我们的系列教程，只需认为只有三个步骤就好了）：
获得 x 的当前值 计算 x + 1 将步骤 2 计算得到的值赋值给 x 如果只有一个协程执行上面的三个步骤，不会有问题。
我们讨论一下当有两个并发的协程执行该代码时，会发生什么。下图描述了当两个协程并发地访问代码行 x = x + 1 时，可能出现的一种情况。
我们假设 x 的初始值为 0。而协程 1 获取 x 的初始值，并计算 x + 1。而在协程 1 将计算值赋值给 x 之前，系统上下文切换到了协程 2。于是，协程 2 获取了 x 的初始值（依然为 0），并计算 x + 1。接着系统上下文又切换回了协程 1。现在，协程 1 将计算值 1 赋值给 x，因此 x 等于 1。然后，协程 2 继续开始执行，把计算值（依然是 1）复制给了 x，因此在所有协程执行完毕之后，x 都等于 1。</description>
    </item>
    
    <item>
      <title>Go系列教程（二十四） | Go Select</title>
      <link>https://shaichunfeng.com/post/2021/07/19/24-go-select/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:05 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/24-go-select/</guid>
      <description>什么是 select？ select 语句用于在多个发送/接收信道操作中进行选择。select 语句会一直阻塞，直到发送/接收操作准备就绪。如果有多个信道操作准备完毕，select 会随机地选取其中之一执行。该语法与 switch 类似，所不同的是，这里的每个 case 语句都是信道操作。我们好好看一些代码来加深理解吧。
示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func server1(ch chan string) { time.</description>
    </item>
    
    <item>
      <title>Go系列教程（二十三） | Go缓冲信道和工作池(Buffered Channels and Worker Pools)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/23-buffered-channels-and-worker-pools/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:04 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/23-buffered-channels-and-worker-pools/</guid>
      <description>什么是缓冲信道？ 在上一教程里，我们讨论的主要是无缓冲信道。我们在信道的教程里详细讨论了，无缓冲信道的发送和接收过程是阻塞的。
我们还可以创建一个有缓冲（Buffer）的信道。只在缓冲已满的情况，才会阻塞向缓冲信道（Buffered Channel）发送数据。同样，只有在缓冲为空的时候，才会阻塞从缓冲信道接收数据。
通过向 make 函数再传递一个表示容量的参数（指定缓冲的大小），可以创建缓冲信道。
1 ch := make(chan type, capacity) 要让一个信道有缓冲，上面语法中的 capacity 应该大于 0。无缓冲信道的容量默认为 0，因此我们在上一教程创建信道时，省略了容量参数。
我们开始编写代码，创建一个缓冲信道。
示例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( &amp;#34;fmt&amp;#34; ) func main() { ch := make(chan string, 2) ch &amp;lt;- &amp;#34;naveen&amp;#34; ch &amp;lt;- &amp;#34;paul&amp;#34; fmt.</description>
    </item>
    
    <item>
      <title>Go系列教程（二十二） | Go信道(channels)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/22-golang-channel/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:03 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/22-golang-channel/</guid>
      <description>在上一教程里，我们探讨了如何使用 Go 协程（Goroutine）来实现并发。我们接着在本教程里学习信道（Channel），学习如何通过信道来实现 Go 协程间的通信。
什么是信道？ 信道（通道）可以想像成 Go 协程之间通信的管道。如同管道中的水会从一端流到另一端，通过使用信道，数据也可以从一端发送，在另一端接收。
信道的声明 所有信道都关联了一个类型。信道只能运输这种类型的数据，而运输其他类型的数据都是非法的。
chan T 表示 T 类型的信道。
信道的零值为 nil。信道的零值没有什么用，应该使用 make 内置函数，来像对 Map 和 Slice 初始化那样，来定义信道。
定义：指对标志符声明并初始化，声明可以通俗的理解为指定标志符所表示的具体类型，初始化可以理解为开辟内存空间。只声明并没有对其初始化的标志符在Go语言中其默认值为类型零值。
下面编写代码，定义一个信道。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import &amp;#34;fmt&amp;#34; func main() { // 变量声明 var a chan int if a == nil { fmt.</description>
    </item>
    
    <item>
      <title>Go系列教程（二十一） | Go协程(goroutine)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/21-golang-goroutine/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:02 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/21-golang-goroutine/</guid>
      <description>在前面的教程里，我们探讨了并发，以及并发与并行的区别。本教程则会介绍在 Go 语言里，如何使用 Go 协程（Goroutine）来实现并发。
Go 协程是什么？ Go 协程是与其他函数或方法一起并发运行的函数或方法。Go 协程可以看作是轻量级线程。与线程相比，创建一个 Go 协程的成本很小。因此在 Go 应用中，常常会看到有数以千计的 Go 协程并发地运行。
Go 协程相比于线程的优势 相比线程而言，Go 协程的成本极低。堆栈大小只有若干 kb，并且可以根据应用的需求进行增减。而线程必须指定堆栈的大小，其堆栈是固定不变的。 Go 协程会复用（Multiplex）数量更少的 OS 线程。即使程序有数以千计的 Go 协程，也可能只有一个线程。如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），那么系统会再创建一个 OS 线程，并把其余 Go 协程都移动到这个新的 OS 线程。所有这一切都在运行时进行，作为程序员，我们没有直接面临这些复杂的细节，而是有一个简洁的 API 来处理并发。 Go 协程使用信道（Channel）来进行通信。信道用于防止多个协程访问共享内存时发生竞态条件（Race Condition）。信道可以看作是 Go 协程之间通信的管道。我们会在下一教程详细讨论信道。 如何启动一个 Go 协程？ 调用函数或者方法时，在前面加上 go 关键字，就可以让一个新的 Go 协程并发地运行。</description>
    </item>
    
    <item>
      <title>Go系列教程（二十） | 并发入门(Concurrency Getting Started)</title>
      <link>https://shaichunfeng.com/post/2021/07/19/20-getting-started-with-concurrency/</link>
      <pubDate>Mon, 19 Jul 2021 08:00:01 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/19/20-getting-started-with-concurrency/</guid>
      <description>Go 是并发式语言，而不是并行式语言。 在讨论 Go 如何处理并发之前，我们必须理解何为并发，以及并发与并行的区别。
并发是什么？ 并发是指立即处理多个任务的能力。举个例子就能很好地说明这一点。
我们可以想象一个人正在跑步。假如在他晨跑时，鞋带突然松了。于是他停下来，系一下鞋带，接下来继续跑。这个例子就是典型的并发。这个人能够一下搞定跑步和系鞋带两件事，即立即处理多个任务。
并行是什么？并行和并发有何区别？ 并行是指同时处理多个任务。这听起来和并发差不多，但其实完全不同。
我们同样用这个跑步的例子来帮助理解。假如这个人在慢跑时，还在用他的 iPod 听着音乐。在这里，他是在跑步的同时听音乐，也就是同时处理多个任务。这称之为并行。
从技术上看并发和并行 通过现实中的例子，我们已经明白了什么是并发，以及并发与并行的区别。作为一名极客，我们接下来从技术的角度来考察并发和并行。🤣
假如我们正在编写一个 web 浏览器。这个 web 浏览器有各种组件。其中两个分别是 web 页面的渲染区和从网上下载文件的下载器。假设我们已经构建好了浏览器代码，各个组件也都可以相互独立地运行（通过像 Java 里的线程，或者通过即将介绍的 Go 语言中的 Go 协程来实现）。当浏览器在单核处理器中运行时，处理器会在浏览器的两个组件间进行上下文切换。它可能在一段时间内下载文件，转而又对用户请求的 web 页面进行渲染。这就是并发。并发的进程从不同的时间点开始，分别交替运行。在这里，就是在不同的时间点开始进行下载和渲染，并相互交替运行的。
如果该浏览器在一个多核处理器上运行，此时下载文件的组件和渲染 HTML 的组件可能会在不同的核上同时运行。这称之为并行。
并行不一定会加快运行速度，因为并行运行的组件之间可能需要相互通信。在我们浏览器的例子里，当文件下载完成后，应当对用户进行提醒，比如弹出一个窗口。于是，在负责下载的组件和负责渲染用户界面的组件之间，就产生了通信。在并发系统上，这种通信开销很小。但在多核的并行系统上，组件间的通信开销就很高了。所以，并行不一定会加快运行速度！
Go 对并发的支持 Go 编程语言原生支持并发。Go 使用 Go 协程（Goroutine） 和信道（Channel）来处理并发。在接下来的教程里，我们还会详细介绍它们。
并发的介绍到此结束。请留下你的反馈和评论。感谢你的阅读。祝你过得愉快。</description>
    </item>
    
    <item>
      <title>Wireshark文档 | Wireshark 过滤器</title>
      <link>https://shaichunfeng.com/post/2021/07/13/wireshark-related-use/</link>
      <pubDate>Tue, 13 Jul 2021 15:34:42 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/13/wireshark-related-use/</guid>
      <description>Wireshark 和 TShark 共享一个强大的过滤引擎，有助于消除数据包跟踪中的噪音，让您只看到您感兴趣的数据包。如果数据包满足过滤器中表达的要求，则它会显示在数据包列表中。显示过滤器让您可以将协议中的字段与特定值进行比较，将字段与字段进行比较，并检查指定的字段或协议是否存在。
检查字段或协议是否存在 最简单的过滤器允许您检查协议或字段是否存在。如果您想查看所有包含 IP 协议的数据包，过滤器将是ip。要查看包含令牌环 RIF 字段的所有数据包，请使用tr.rif。
将过滤器中的协议或字段视为隐式具有“存在”运算符。
比较运算符 字段也可以与值进行比较。比较运算符可以通过类似英文的缩写或类似 C 语言的符号表示：
1 2 3 4 5 6 7 8 运算符 描述 ——————————————————————————————————————————— eq, == (等于)Equal ne, != (不等于)Not Equal gt, &amp;gt; (大于)Greater Than lt, &amp;lt; (小于)Less Than ge, &amp;gt;= (大于等于)Greater than or Equal to le, &amp;lt;= (小于等于)Less than or Equal to 搜索和匹配操作符 其他运算符仅以英语表达，而不是类似 C 语言的语法：</description>
    </item>
    
    <item>
      <title>CentOS7 安装 Git LFS</title>
      <link>https://shaichunfeng.com/post/2021/07/07/centos7-install-git-lfs/</link>
      <pubDate>Wed, 07 Jul 2021 14:50:27 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/07/centos7-install-git-lfs/</guid>
      <description>Git 大文件存储 (LFS) 使用 Git 内部的文本指针替换音频样本、视频、数据集和图形等大文件，同时将文件内容存储在 GitHub.com 或 GitHub Enterprise 等远程服务器上。
1 $ curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash 执行这个命令将会自动为您系统添加YUM源，具体的安装过程如下所示：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Detected operating system as centos/7.</description>
    </item>
    
    <item>
      <title>CentOS7 安装 Docker</title>
      <link>https://shaichunfeng.com/post/2021/07/05/centos-install-docker/</link>
      <pubDate>Mon, 05 Jul 2021 09:33:49 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/05/centos-install-docker/</guid>
      <description>要在 CentOS 上开始使用 Docker Engine，请确保满足先决条件，然后安装 Docker。
先决条件 操作系统要求 要安装 Docker 引擎，您需要 CentOS 7 或 8 的维护版本。不支持或测试存档版本。 必须启用 centos-extras 储存库。默认情况下启用此存储库，但如果您已禁用它，则需要重新启用它。 推荐使用 overlay2 存储驱动。 卸载旧版本 旧版本的 Docker 被称为 docker 或 docker-engine。如果安装了这些，请卸载它们以及相关的依赖项。
1 2 3 4 5 6 7 8 $ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 如果yum报告没有安装这些软件包，这是可以的。</description>
    </item>
    
    <item>
      <title>MYSQL创建新用户并赋于权限</title>
      <link>https://shaichunfeng.com/post/2021/07/03/mysql-creates-a-new-user-and-grants-permissions/</link>
      <pubDate>Sat, 03 Jul 2021 19:30:17 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/03/mysql-creates-a-new-user-and-grants-permissions/</guid>
      <description>为应用程序创建特定的用户特定的数据库，不要直接使用root用户直接在应用程序中执行数据库操作，如果条件允许请将root用户设置为禁止远程登录，以提高系统的安全性，通常情况下，在开发或测试时可以将环境中的MYSQL设置为允许远程登录，以提高开发或上线效率，生产环境下是严禁MYSQL数据库远程登录的，应用程序应该通过内部网络进行通信完成数据的相关操作。特定的用户只对特定数据库有权限，退一万步讲，即使特定用户的密码被破解，也不会对同一节点下的数据库造成什么影响，还有千万不要使用弱口令，下文中的 @@helloworld@@ 是演示说明使用，可以忽略不计~
Step1.以root用户登录MYSQL 1 2 3 4 5 6 7 8 9 10 11 12 13 $ mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 16 Server version: 8.0.23 MySQL Community Server - GPL Copyright (c) 2000, 2021, Oracle and/or its affiliates.</description>
    </item>
    
    <item>
      <title>Docker环境构建Gitea版本库服务</title>
      <link>https://shaichunfeng.com/post/2021/07/03/docker-environment-builds-the-gitea-repository-service/</link>
      <pubDate>Sat, 03 Jul 2021 17:26:11 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/07/03/docker-environment-builds-the-gitea-repository-service/</guid>
      <description>Gitea是一个开源软件包，用于托管使用Git以及其他协作特性(如bug跟踪、wiki和代码审查)的软件开发版本控制。它支持自托管，但也提供一个免费的公共第一方实例托管在滴滴的中国云，它是Gogs的分支，Gitea使用Go语言编写，可以托管在Go支持的所有平台上，包括Linux、macOS和Windows。项目由Open Collective资助。以上来自维基百科
建立一个管理Gitea服务的项目 项目目录结构如下：
1 2 3 4 5 $ tree ├── docker-compose.yaml └── etc ├── localtime └── timezone 项目目录正如你所见是不是特别的简单呀！有一个docker-compose.yaml文件和一个etc目录，docker-compose.yaml这个文件是定义具体的容器服务，而etc目录则是为了保障容器环境时区为北京时间，添加的两个文件配置文件，localtime文件是拷贝于我本机Mac，而timezone是我手动添加的，这个timezone文件的具体内容为Asia/Shanghai，这个可以根据你的国家进行设置。
docker-compose.yaml 这个docker-compose.yaml是docker compose工具在运行容器服务时默认加载的配置文件，当然你也可以是其它的文件名，不过还是使用官方的建立吧，就叫docker-compose.yaml，遵守规则还是很有必要的，会省去很多麻烦，如果你非得不叫这个文件名，你在使用docker-compose运行容器服务时要指明配置文件。再来说一下何为docker compose? 说白了它就是对一组容器统一管理，而不用单个的运行容器，可以使用build、up、down来快速的管理容器服务，当然还有其它的一些命令，常用的就这几个，具体可以参数官方文档进行更深入的了解。这个文件定义如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 version: &amp;#34;3.</description>
    </item>
    
    <item>
      <title>Git 推送LSF（大文件）到远程</title>
      <link>https://shaichunfeng.com/post/2021/06/28/git-push-contain-lsf-file/</link>
      <pubDate>Mon, 28 Jun 2021 12:31:07 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/28/git-push-contain-lsf-file/</guid>
      <description>项目中包含大上件时
推送已有项目到新仓库时报错 1 2 3 4 5 6 7 8 9 10 11 12 $ git push -u origin master 枚举对象中: 1585, 完成. 对象计数中: 100% (1585/1585), 完成. 使用 4 个线程进行压缩 压缩对象中: 100% (1466/1466), 完成. 写入对象中: 100% (1585/1585), 13.66 MiB | 6.49 MiB/s, 完成. 总共 1585（差异 667），复用 0（差异 0），包复用 0 remote: Resolving deltas: 100% (667/667), done.</description>
    </item>
    
    <item>
      <title>Mac下使用FreeRDP</title>
      <link>https://shaichunfeng.com/post/2021/06/23/mac-use-freerdp/</link>
      <pubDate>Wed, 23 Jun 2021 11:33:41 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/23/mac-use-freerdp/</guid>
      <description>FreeRDP是一个远程桌面协议(RDP)的实现，开源免费软件，在Apache许可下发布。要在MacOS系统下安装使用还是有些特别需要注意的地方，记录一下在Mac系统的安装具体步骤方便遇到类似问题的开发者进行参考。
Section1.安装openssl并配置环境变量 如果没有安装openssl请打开 terminal 或 item2 （以下统称终端）执行以下brew命令安装：
1 $ brew install openssl 配置openssl库包配置路径环境变量 编辑 ~/.bashrc 或 ~/.zshrc 配置文件，导出PKG_CONFIG_PATH环境变量，具体如下：
1 export PKG_CONFIG_PATH=$(brew --prefix)/opt/openssl/lib/pkgconfig 保存之后要记得source一下配置文件，否则在当前终端下不生效：
1 $ source ~/.bashrc // 或 source ~/.zshrc Section2.安装X11及配置环境变量 在终端下执行如下命令，安装xquartz(X11)：
1 $ brew install xquartz 设置X11的环境变量 在/tmp/com.apple.launchd.XXXXX目录下找到包含 org.xquartz:0 文件的具体路径。
1 2 $ ls /tmp/com.apple.launchd.7M2pVCoBMU/org.xquartz:0 /tmp/com.apple.launchd.7M2pVCoBMU/org.xquartz:0 将这个路径添加到 ~/.bashrc 或 ~/.</description>
    </item>
    
    <item>
      <title>Go语言调用C语言代码</title>
      <link>https://shaichunfeng.com/post/2021/06/21/go-call-c/</link>
      <pubDate>Mon, 21 Jun 2021 15:51:11 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/21/go-call-c/</guid>
      <description>Go 语言除了语法精炼、并发支持好外，还有一个优点就是可以调用 C 代码。可以直接在 Go 源代码里写 C 代码，也可以引 C 语言的外部库。这样在性能遇到瓶颈的地方可以重写，或者某些功能 Go 和第三方还缺失，但 C 语言有现成的库就可以直接用了。官方 Cgo 这块目前有一篇博客 https://blog.golang.org/c-go-cgo 和 命令行文档 https://golang.org/cmd/cgo/ 对 Cgo 进行了说明，其中某些地方还不够明确或者没有提到的地方。
Section1：Go语言内联C语言代码 下面例子是直接将 C 代码内嵌在 Go 源代码里，引入了一个不存在的包 “C”, 然后将 C 代码写在了引入上面，注意只能写在 “C” 包上面。这里定义了一个sum函数, 然后通过 C.sum 在 Go 代码里使用。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main /* 内联C语言代码 Start */ // // sum calc a and b sum value.</description>
    </item>
    
    <item>
      <title>Golang 字符串处理，删除文件中的指定行</title>
      <link>https://shaichunfeng.com/post/2021/06/19/golang-string-processing/</link>
      <pubDate>Sat, 19 Jun 2021 13:33:35 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/19/golang-string-processing/</guid>
      <description>在Go语言中字符串处理操作，可用的内建包有strings、bytes、strconv、regexp、fmt等等吧，不管在任何语言中字符串处理、数组处理在日常开发中都是非常频繁的，当然了，Go语言中用的最多的是不数组而是slice切片，写这篇文章的目的不是记录标准库的常规操作，而是记录一些配合标准库处理字符串的技巧性操作，这篇文章不会一下记录所有的字符串处理场景，但是会持续性的更新，希望我这些遇到的字符串处理案例可以对您的开发工作有所帮助~
完成这个字符串场景处理需要使用到正则表达式，Go语言提供的标准库为regexp，以及文件操作。具体思路这样子的，读取文件内容，使用正则表达式去匹配指定字符串所在的行，然后删除即可，最后将处理后的字符串保存到文件，这个字符串处理场景需要也就完成了，来看具体的代码如何实现。
现在，在demo目录下有一个文本文件，如helloshaohua.txt内容如下：
1 2 3 4 $ cat ./demo/helloshaohua.txt helloshaohua WillDeleteLine wu.shaohua@foxmail.com 可以看到，现在这个文件有3行，比如说想要删除 WillDeleteLine 这个特定字符串所在的行，让这个文件变为2行，最终的文件内容应该如下：
1 2 3 $ cat ./demo/helloshaohua.txt helloshaohua wu.shaohua@foxmail.com 这是我们预期想要达到的目标，有了这个简单的小场景需求，来编写具体的代码实现，在demo目录下创建demo.go具体如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package demo import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;os&amp;#34; &amp;#34;regexp&amp;#34; ) // DeleteFileSpecificContentLine Deletes lines of a file that contain specific content.</description>
    </item>
    
    <item>
      <title>正则表达式用例</title>
      <link>https://shaichunfeng.com/post/2021/06/18/regular-expression-use-case/</link>
      <pubDate>Fri, 18 Jun 2021 22:53:56 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/18/regular-expression-use-case/</guid>
      <description>匹配多个字符 匹配多个空格 1 \s+ 可以将包含一个或多个的空格统一处理为一个空格，如有如下字符串：
1 2 $ ll drwx------@ 3 helloshaohua staff 96B 1 29 09:48 Applications </description>
    </item>
    
    <item>
      <title>Docker镜像Push到阿里云</title>
      <link>https://shaichunfeng.com/post/2021/06/17/docker-image-pull-aliyun/</link>
      <pubDate>Thu, 17 Jun 2021 19:40:18 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/17/docker-image-pull-aliyun/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>JSON 转换到 Go 结构体类型</title>
      <link>https://shaichunfeng.com/post/2021/06/17/json-to-go-structure/</link>
      <pubDate>Thu, 17 Jun 2021 15:17:04 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/17/json-to-go-structure/</guid>
      <description>json-to-go 该工具立即将 JSON 转换为 Go 类型定义。在左侧粘贴一个 JSON 结构，右侧将生成等效的 Go 类型，您可以将其粘贴到您的程序中。该脚本必须做出一些假设，因此请仔细检查输出！
服务地址 JSON-TO-GO
示例截图 </description>
    </item>
    
    <item>
      <title>Golang Float64和字节数组之间的交换</title>
      <link>https://shaichunfeng.com/post/2021/06/17/golang-and-interchange-between-bytes/</link>
      <pubDate>Thu, 17 Jun 2021 11:08:46 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/17/golang-and-interchange-between-bytes/</guid>
      <description>Go语言是强类型语言，不支持类型的隐式类型转换，所有类型都需要显示进行转换，那么bytes数组如何转换为Float64，以及Float64将转换为bytes数组，也就是它们之间的互相转换如何做到。这两种类型的转换不能直接转换需要转换为中间类型然后再转换为对应的类型。
bytes数组转换为Float64 1 2 3 4 5 6 7 8 9 10 11 12 package converter import ( &amp;#34;encoding/binary&amp;#34; &amp;#34;math&amp;#34; ) func BytesToFloat64(bytes []byte) float64 { bits := binary.LittleEndian.Uint64(bytes) float := math.Float64frombits(bits) return float } float64转换为bytes数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package converter import ( &amp;#34;encoding/binary&amp;#34; &amp;#34;math&amp;#34; ) func Float64ToBytes(float float64) []byte { bits := math.</description>
    </item>
    
    <item>
      <title>Linux 卸载 RPM 安装包</title>
      <link>https://shaichunfeng.com/post/2021/06/13/linux-uninstall-rpm/</link>
      <pubDate>Sun, 13 Jun 2021 17:33:47 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/13/linux-uninstall-rpm/</guid>
      <description>Step1、执行以下命令发现安装包的名称 1 $ rpm -qa | grep package_name 例如要卸载LibreOffice软件的RPM安装包，首先需要执行上面的命令进行查看已经安装了哪些包
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ rpm -qa | grep &amp;#34;libreoffice&amp;#34; libreoffice7.0-freedesktop-menus-7.0.6-2.noarch libreoffice7.0-7.0.6.2-2.x86_64 libreoffice7.0-math-7.0.6.2-2.x86_64 libreoffice7.0-calc-7.0.6.2-2.x86_64 libreoffice7.0-dict-es-7.0.6.2-2.x86_64 libreoffice7.0-draw-7.0.6.2-2.x86_64 libreoffice7.0-impress-7.0.6.2-2.x86_64 libreoffice7.0-zh-CN-7.0.6.2-2.x86_64 libobasis7.0-libreofficekit-data-7.0.6.2-2.x86_64 libreoffice7.0-ure-7.0.6.2-2.x86_64 libreoffice7.0-base-7.0.6.2-2.x86_64 libreoffice7.0-dict-en-7.0.6.2-2.x86_64 libreoffice7.0-dict-fr-7.0.6.2-2.x86_64 libreoffice7.0-en-US-7.0.6.2-2.x86_64 libreoffice7.0-writer-7.0.6.2-2.x86_64 这将返回 PackageName，这是 LibreOffice 产品的 RPM 名称，用于标识安装包。</description>
    </item>
    
    <item>
      <title>Linux 安装 LibreOffice</title>
      <link>https://shaichunfeng.com/post/2021/06/13/linux-install-libreoffice/</link>
      <pubDate>Sun, 13 Jun 2021 12:04:58 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/13/linux-install-libreoffice/</guid>
      <description>LibreOffice是由文档基金会开发的自由及开放源代码的办公室套件。LibreOffice套件包含文字处理器、电子表格、演示文稿程序、矢量图形编辑器和图表工具、数据库管理程序及创建和编辑数学公式的应用程序。
Section1、下载LibreOffice 到LibreOffice官网进行下载。
如上图所示选择操作系统类型为Linux(64-bit)(rpm)，然后下载 7.0.6 LTS 版本，然后上传到服务。如果您不想这么操作，可以在跳转的下载页面复制下载链接到服务器上使用wget工具进行下载，都是可以的，怎么方便怎么来嘛~
1 bash-4.4# wget https://download.documentfoundation.org/libreoffice/stable/7.0.6/rpm/x86_64/LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz 下载后的LibreOffice软件RPM安装如下所示：
1 2 3 bash-4.4# ll -h 总用量 251M -rw-r--r-- 1 root root 251M 5月 7 19:37 LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz Section2、下载内建帮助RPM包 1 bash-4.4# tar -zxvf LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz 解压后的目录结构如下，会将 LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz 归案文件解压到 LibreOffice_7.0.6.2_Linux_x86-64_rpm 目录。
1 2 3 4 bash-4.4# ll -h 总用量 251M drwxr-xr-x 4 root root 4.</description>
    </item>
    
    <item>
      <title>从Linux转换PDF到Word</title>
      <link>https://shaichunfeng.com/post/2021/06/13/convert-pdf-to-word-from-linux/</link>
      <pubDate>Sun, 13 Jun 2021 11:13:43 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/13/convert-pdf-to-word-from-linux/</guid>
      <description>如果您在 GNU / Linux 上将其与 Wine 一起使用，那么您肯定已经知道如何使用 Microsoft 办公套件中包含的功能将原生 Microsoft Office 文档转换为 PDF。即使您使用 LibreOffice 或其他办公套件，由于已经包含此类套件的工具，您也可以轻松地将文档转换为 PDF 以更舒适的方式共享它。在您不得不使用其他工具来执行此操作之前，某些插件已经出现，最后它们已经集成到套件中。
但这不是我们在本文中将要解释的，而是我们感兴趣的是相反的过程，即将 PDF 转换为 Word 文档或 LibreOffice，无论是 .doc、.docx 等。 虽然它不是典型的作为我在第一段中解释的反向转换，有很多人需要将PDF文档转换为更友好的格式来编辑它们。这就是为什么我们要解释将 PDF 转换为 Word 的简单步骤。
PDF 和其他格式有什么区别： PDF 代表 Portable Document Format，即一种可移植的文档格式。它由 Adob​​e Systems 开发，目前是最流行的格式之一，因为它独立于我们使用的软件和硬件平台，因此是可移植的。这意味着我们将能够可视化来自几个非常不同的操作系统和程序的内容，这使得它成为访问现有异构计算机的互联网之王。
它变得如此重要，以至于它在 2008 年在 ISO 32000-1 下标准化，但并非所有优点，如便携性、易于查看、小尺寸和个性化配置，它也有其隐藏的面孔。例如，这些 PDF 文件的版本涉及购买付费软件，例如专业版的 Adob​​e Acrobat 产品。如果没有特定软件，很难编辑或不可能进行编辑，因此很难使用它，这就是为什么我们将在本教程中教您将其转换为可编辑文档的原因。</description>
    </item>
    
    <item>
      <title>Golang交叉编译</title>
      <link>https://shaichunfeng.com/post/2021/06/13/golang-cross-compile/</link>
      <pubDate>Sun, 13 Jun 2021 01:29:24 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/13/golang-cross-compile/</guid>
      <description>Golang项目开发完成后最终是要放到服务器上去跑的，那么就需要编译出对应平台及CPU构架类型的可执行程序上传到服务器。由于业务需要构建多个平台，每一次都需要多次构建，非常不方便，于是乎可以将其在Shell脚本中自动化的快速构建多个不台平台程序，这样可以省去不必要的没有意义的操作。
查看Golang支持的平台及CPU框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 $ go tool dist list aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/amd64 darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm freebsd/arm64 illumos/amd64 js/wasm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x netbsd/386 netbsd/amd64 netbsd/arm netbsd/arm64 openbsd/386 openbsd/amd64 openbsd/arm openbsd/arm64 plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64 windows/arm 可以看到当前系统安装的Go语言支持的操作类型及CPU构架详情列表信息，注意，每一行是一种平台及CPU构架描述，非常直观一看就会明白，不用让我们一个一个去到对应服务器上去查看平台类型及CPU构架，非常方便。</description>
    </item>
    
    <item>
      <title>Mac使用技巧</title>
      <link>https://shaichunfeng.com/post/2021/06/12/mac-using-skills/</link>
      <pubDate>Sat, 12 Jun 2021 10:09:55 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/12/mac-using-skills/</guid>
      <description>MacOS使用过程中遇到的各种问题汇总。
Mac Big Sur 清除DNS缓存 1 $ sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder </description>
    </item>
    
    <item>
      <title>MacOS环境在终端使用Libreoffice的soffice命令</title>
      <link>https://shaichunfeng.com/post/2021/06/11/make-soffice-of-libreoffice-work-on-macos/</link>
      <pubDate>Fri, 11 Jun 2021 19:27:40 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/06/11/make-soffice-of-libreoffice-work-on-macos/</guid>
      <description>由于业务需要，需要将PDF文档转换为Word文档，这种类似的工具软件比较多，如OpenOffice、LibreOffice、Abiword等，都是可以的，使用的话主要是在服务器上使用，本地一般用个WPSOffice就够用了，因为要在本地开发调试，所以为了方便起见需要在MacOS系统安装 LibreOffice ，安装之后你会发现这个工具，没有默认支持终端下使用命令的功能。在程序中完成文档的格式转换就需要调用命令，需要手动去设置shell脚本访问 soffice 这个命令，当然，你也可以使用全路径就调用这个 soffice 命令，当然，话有说回来既然就能看到这篇博文说明你也在找类型的解决方案，来吧，来看一下具体怎么设置，其实也非常简单~
创建Shell脚本 在 /usr/local/bin 目录下创建一个名为 soffice 的Shell脚本，并添加以下内容：
1 2 3 4 5 #!/bin/bash # 需要这样做，因为符号链接不起作用， # 因为它抱怨包含了一些 .plist 文件。 /Applications/LibreOffice.app/Contents/MacOS/soffice &amp;#34;#@&amp;#34; 赋予可执行权限 1 $ sudo chmod +x /usr/local/bin/soffice 用法 </description>
    </item>
    
    <item>
      <title>ElasticSearch日常开发使用</title>
      <link>https://shaichunfeng.com/post/2021/05/27/elasticsearch-use-logging/</link>
      <pubDate>Thu, 27 May 2021 10:42:40 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/27/elasticsearch-use-logging/</guid>
      <description>:::tip 在CentOS上安装Headless Chromium的分步指南。 :::
索引操作 索引(也就是index)的常用的相关操作包括：新建索引、删除索引、
如何新建索引? 新建索引， 可以直接向 ElasticSearch 服务器发送 PUT 请求。例如，下面的例子是新建一个名为 users 的索引。
1 curl -XPUT &amp;#34;http://localhost:9200/users?pretty=true&amp;#34; 服务器将返回一个JSON对象，其中 acknowledged 代表是否操作成功，shards_acknowledged 是否分片成功，index 表示操作的索引名称，当前就是 users。
1 2 3 4 5 { &amp;#34;acknowledged&amp;#34; : true, &amp;#34;shards_acknowledged&amp;#34; : true, &amp;#34;index&amp;#34; : &amp;#34;users&amp;#34; } 如何删除索引？ 删除索引，直接向 ElasticSearch 服务器发送 DELETE 请求，即可删除索引。例如，下面的例子是删除一个名为 users 的索引。
1 curl -XDELETE &amp;#34;http://localhost:9200/users?</description>
    </item>
    
    <item>
      <title>CentOS安装无头Chrome</title>
      <link>https://shaichunfeng.com/post/2021/05/27/centos-install-headless-chrome/</link>
      <pubDate>Thu, 27 May 2021 10:17:21 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/27/centos-install-headless-chrome/</guid>
      <description>无头Chrome就像是在没有UI（浏览器）的情况下运行chrome浏览器一样，也就是说，它在无头环境中运行，这对于运行自动化测试非常有用。
那么，无头Chrome可以为我们做些什么呢？
最令人兴奋的事情之一就是能够测试最新和最强大的Web平台功能，例如ES6模块，服务工作者和流。使用无头chrome，您可以编写应用程序并使用最新的渲染功能测试这些应用程序。它解锁的另一件事是这些很棒的功能，例如网络限制，设备仿真和代码覆盖。 使用无头chrome，您甚至无需编写任何代码即可执行测试，那不是很爽！
您可以仅通过命令行执行它们。
1 2 3 4 $ google-chrome-stable \ --headless \ --disable-gpu \ --print-to-pdf=www.meipian.cn.pdf https://www.meipian.cn/ 1 2 3 4 $ google-chrome-stable \ --headless \ --disable-gpu \ --screenshot=www.meipian.cn.png https://www.meipian.cn/ 1 2 3 4 5 $ google-chrome-stable \ --headless \ --disable-gpu \ --dump-dom \ https://www.meipian.cn/ &amp;gt;&amp;gt; www.meipian.cn.html 以上是一些常用的功能！更多功能可以学习Chrome浏览器功能具体列表。
Step1:更新CentOS 使用以下命令更新CentOS系统。</description>
    </item>
    
    <item>
      <title>Makefile快速入门</title>
      <link>https://shaichunfeng.com/post/2021/05/27/makefile-simple-use/</link>
      <pubDate>Thu, 27 May 2021 10:09:51 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/27/makefile-simple-use/</guid>
      <description>可以这么理解Makefile是用于管理项目的一种工具，它来自GNU，比如您呢好在项目下使用docker-compose工具运行容器，这个时候呢，您一般会输入docker-compose -f docker-compose.yaml up -d 进行项目容器的启动，如果您要把这个容器及网卡等一系列与这个容器服务相关的服务也停止掉的话，您会执行 docker-compose down 命令进行操作，这很好，您如果不嫌麻烦的话您可以先停止掉依赖的网卡了（如果有的话），然后再停止掉容器，这样也是可以的，不过呢，您有没有感觉这么一来，就会很麻烦，Makefile给我们来解决这些个麻烦，您只需要在项目目录下添加一个Makefile即可给您带来极大的方便，如果我们有多个容器要管理的话这个方便之处简直会让您为之大叫~
二、如何编写Makefile？ 我们来说一下就上面我们使用docker-compose管理容器时执行的一系列命令如果让Makefile为我们执行，废话不多话，写一个Makefile，来说明！
2.1、添加Makefile 在您的项目目录下添加一个Makefile
1 $ touch Makefile 2.2、编写Makefile命令 在这个Makefile中我们编写以下代码：
1 2 3 4 5 6 7 .PHONY: docker-compose-up docker-compose-up: docker-compose -f docker-compose.yaml up -d .PHONY: docker-compose-down docker-compose-down: docker-compose down 以上呢我们添加了两个伪命令，这两个伪命令就可以为我们执行容器的启动与停止操作。定义一个伪命令以 .PHONY: 开头，后面就是伪命令名称，然后另起一行，顶格声明这个伪命令以冒号:结尾，然后再另起一行输入这个伪命令要执行的命令，注意要有一个TAB键的缩进，每一个要执行的命令要占一行！这样就声明了一个Makefile伪命令了！
注意：我们一直说它是伪命令，这是相对于系统级别命令而言的命令，所以它在Makefile也只能算是伪命令了！
三、如果使用？ 这些在Makefile文件中定义的伪命令不能像系统级别的命令那样直接输入：
1 $ docker-compose-up 这样执行，系统它不认识它哦！要使用 make 加伪命令的形式才可以：</description>
    </item>
    
    <item>
      <title>格式化curl返回的JSON数据</title>
      <link>https://shaichunfeng.com/post/2021/05/27/format-the-json-data-returned-by-curl/</link>
      <pubDate>Thu, 27 May 2021 10:01:05 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/27/format-the-json-data-returned-by-curl/</guid>
      <description>在开发的过程中会使用CURL命令请求API接口，而一般情况下API接口也是返回JSON数据，但是如果直接使用 curl -X GET https://news-at.zhihu.com/api/4/news/latest 这种方式访问API接口的话，你会发现终端输出的是一行JSON数据，如果可以美化一下JSON数据在终端输出岂不美哉~
二、格式化CURL返回的JSON数据有两种方式 分别是 PYTHON格式化 和 NODEJS格式化。
2.1、PYTHON格式化 在CURL命令后面添加 | python -m json.tool 即可。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 $ curl -X GET https://news-at.</description>
    </item>
    
    <item>
      <title>Git如何删除远程分支</title>
      <link>https://shaichunfeng.com/post/2021/05/27/how-does-git-delete-a-remote-branch/</link>
      <pubDate>Thu, 27 May 2021 09:53:38 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/27/how-does-git-delete-a-remote-branch/</guid>
      <description>当远程分支不再使用或者需要废弃时，你可以通过登录到远程仓库进行删除分支操作，但是这样不够方便快捷，我们可以通过在本地执行一个Git命令即可快速将远程分支删除掉。
Step1、查看远程分支 要删除远程分支首先要查询一下远程到底有哪些分支可以执行以下命令，进行查询：
1 $ git branch -r 具体输出如下所示：
1 2 3 4 5 6 $ git branch -r origin/gin origin/master origin/middleware origin/step1 (END) 在清楚的知道了远程有哪分支后，就可以执行删除命令了，请参考 。
Step2、删除远程分支 具体的命令如下：
1 $ git push origin --delete &amp;lt;origin-branch-name&amp;gt; 请您记住喽，删除远程分支的过程就是在推送的过程中添加 --delete 参数 并指定分支名称，具体如下所示：
1 2 3 4 5 $ git push origin --delete step1 remote: .</description>
    </item>
    
    <item>
      <title>使用Shell脚本新建博文生成多个语言Markdown文件</title>
      <link>https://shaichunfeng.com/post/2021/05/26/shell-scirpt-code-structure/</link>
      <pubDate>Tue, 25 May 2021 01:34:23 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/26/shell-scirpt-code-structure/</guid>
      <description>在使用Hugo写博客的时候，添加一遍博文，如果内容是支持多语言的话，添加每种语言markdown文件都需要执行一次Hugo命令，着实非常不方便，于是乎写一个Shell脚本就可以解决这个非常不愉快的操作体验，具体可以写一个Shell脚本去一次性的完成这个重复而没有任何意义的操作。仔细分析一下这个要写的Shell脚本，其实非常简单就可以实现: 定义一个目录常量，定义一语言数组，让用户输入三个参数，其中前两个是必传参数，最后一个参数是可选参数，依次表示，要生成的markdown文件存放目录，markdown文件名，以及是否要使用日期目录。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #!</description>
    </item>
    
    <item>
      <title>解决Github打不开问题</title>
      <link>https://shaichunfeng.com/post/2021/05/23/solve-the-issue-of-github-not-being-able-to-open/</link>
      <pubDate>Sun, 23 May 2021 22:47:53 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/23/solve-the-issue-of-github-not-being-able-to-open/</guid>
      <description>解决过程 通过 https://www.ipaddress.com/ 查询获取Github官方的CDN地址，分别查询 github.com，assets-cdn.github.com，github.global.ssl.fastly.net 这几个域名对应的DNS解析地址，添加到 /etc/hosts 文件。例如：
1 2 3 4 5 6 7 # Github.com 140.82.114.3	github.com 199.232.69.194	github.global.ssl.fastly.net 185.199.108.153	assets-cdn.github.com 185.199.109.153	assets-cdn.github.com 185.199.110.153	assets-cdn.github.com 185.199.111.153	assets-cdn.github.com 更多可以参考：解决Github打不开问题 </description>
    </item>
    
    <item>
      <title>Docker日常开发使用</title>
      <link>https://shaichunfeng.com/post/2021/05/23/docker-users-problem-logging/</link>
      <pubDate>Sun, 23 May 2021 22:44:18 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/23/docker-users-problem-logging/</guid>
      <description>Section1.容器操作 Section1.1.如何将容器保存为镜像 1 $ docker commit -m &amp;lt;Version Description&amp;gt; -a &amp;lt;Author&amp;gt; &amp;lt;容器ID|容器名称&amp;gt; &amp;lt;组织名称&amp;gt;/&amp;lt;镜像名称&amp;gt;:&amp;lt;版本号&amp;gt; Section1.2.如何查看容器前10行实时日志？ 1 $ docker logs -f -t --tail 10 &amp;lt;容器ID|容器名称&amp;gt; Section1.3.如何批量删除所有已停止运行的容器 方式有很多，来看一种比较常见也比较好理解的方式：
1 $ docker rm `docker ps -a | grep &amp;#34;Exited&amp;#34; | awk &amp;#39;{print $1}&amp;#39;` Section1.4.容器环境如何使用宿主机网络 容器环境没有梯子你是访问不了Github的，那么在宿主机已经搬了一把梯子，这个时候你就不用再在Docker容器搬梯子了，只需要让Docker容器环境内的网络使用宿主机网络环境就可以了，你需要在运行容器时加上 &amp;ndash;network 选项，值为 host 即可:
1 $ docker run -it --privileged=true -d --name=centos --network host centos:8 /bin/bash Docker容器运行的时候有host、bridge、none三种网络可供配置。默认是bridge，即桥接网络，以桥接模式连接到宿主机；host是宿主网络，即与宿主机共用网络；none则表示无网络，容器将无法联网。</description>
    </item>
    
    <item>
      <title>TCPDUMP抓包工具</title>
      <link>https://shaichunfeng.com/post/2021/04/29/tcpdump-climbing-package/</link>
      <pubDate>Sun, 23 May 2021 22:23:35 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/04/29/tcpdump-climbing-package/</guid>
      <description>Feature1、抓取默认网卡的所有数据包 1 $ tcpdump Feature2、抓取指定IP的所有数据包 1 $ tcpdump host 10.10.11.215 意思是抓取本服务器与IP10.10.11.215设备之间的通信数据包.
Feature3、抓取指定IP及端口的所有数据包 1 $ tcpdump host 10.10.11.215 and port 7001 意思是抓取本服务器与IP 10.10.11.215 设备的 7001 端口之间的通信数据包.
Feature4、抓取指定IP及端口的所有数据包并保存为文件以供wireshark工具分析 1 $ tcpdump host 10.10.11.215 and port 7001 -w 10.10.11.215.machine.port.7001.cap 意思是抓取本服务器与IP 10.10.11.215 设备的 7001 端口之间的通信数据包，并将数据包保存到文件 10.10.11.215.machine.port.7001.cap.</description>
    </item>
    
    <item>
      <title>Golang项目Git忽略文件配置</title>
      <link>https://shaichunfeng.com/post/2021/05/19/go-gitignore/</link>
      <pubDate>Wed, 19 May 2021 23:19:11 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/19/go-gitignore/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Editor files. .idea # Binaries for programs and plugins *.exe *.exe~ *.dll *.so *.dylib # Test binary, built with `go test -c` *.test # Output of the go coverage tool, specifically when used with LiteIDE *.</description>
    </item>
    
    <item>
      <title>shell编程快速入门</title>
      <link>https://shaichunfeng.com/post/2021/05/19/post-9/</link>
      <pubDate>Wed, 19 May 2021 23:19:11 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2021/05/19/post-9/</guid>
      <description>变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash # 1. 变量的定义和使用 username=helloshaohua echo &amp;#34;1. $username&amp;#34; # 2. 另一种定义方式 course=&amp;#34;linux shell program&amp;#34; echo 2. ${course} # 3. 只读变量 readonly course # course=&amp;#34;Go program&amp;#34; # available.sh: line 13: course: readonly variable.</description>
    </item>
    
    <item>
      <title>如何用Docker优雅地管理你的Nginx</title>
      <link>https://shaichunfeng.com/post/2020/05/23/how-to-gracefully-manage-your-nginx-with-docker/</link>
      <pubDate>Sat, 23 May 2020 23:53:43 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/23/how-to-gracefully-manage-your-nginx-with-docker/</guid>
      <description>如果你只有一台服务器，并且有多个服务需要NGINX代理提供服务，还想使用Docker服务跑你的NGINX服务器，那么你就应该单独管理你的NGINX服务容器，而不应该在其它应用部署时强耦合到项目下的docker-compose.yaml进行相应的部署，那应该如何优雅的管理你的NGINX服务呢? 那既然你能看到这篇博文，相信它必定对你管理NGINX服务容器有一定的启发~
单独建立一个Docker下的NGINX管理项目 例如你可以建立一个如下目录结构的项目，项目名称随意，如docker-nginx
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ tree . ├── config // 配置目录 │ ├── Dockerfile // Dockerfile │ ├── nginx.conf // NGINX配置文件 │ ├── ca // SSL证书目录 │ │ ├── api.wumoxi.com │ │ │ ├── cert.</description>
    </item>
    
    <item>
      <title>Golang请求第三方API接口发送POST请求的几种方式</title>
      <link>https://shaichunfeng.com/post/2020/05/23/go-requests-third-party-api-interfaces-to-send-post-requests-in-several-ways/</link>
      <pubDate>Sat, 23 May 2020 00:00:55 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/23/go-requests-third-party-api-interfaces-to-send-post-requests-in-several-ways/</guid>
      <description>在项目中如果要用到第三方服务，第三方服务肯定会有一服务接口文档，难免不会有一些API接口是必须要通过POST方式请求，那么在Golang中如何发送POST请求到其它第三服务呢? 如果说有3种或4种方式，这种说法也不太确切，这个具体要看第三方服务接口接收数据的格式，如果只接收XML数据格式那你也就只能通过XML格式发送请求数据到第三方API接口，来看几种常用的POST请求方式~
模拟第三方服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) type Product struct { Name string `json:&amp;#34;name&amp;#34; form:&amp;#34;name&amp;#34; xml:&amp;#34;name&amp;#34; binding:&amp;#34;required&amp;#34;` Number int `json:&amp;#34;number&amp;#34; form:&amp;#34;number&amp;#34; xml:&amp;#34;number&amp;#34; binding:&amp;#34;required&amp;#34;` } func main() { r := gin.</description>
    </item>
    
    <item>
      <title>Nuxt部署到Docker环境</title>
      <link>https://shaichunfeng.com/post/2020/05/22/nuxt-is-deployed-to-the-docker-environment/</link>
      <pubDate>Fri, 22 May 2020 23:49:34 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/22/nuxt-is-deployed-to-the-docker-environment/</guid>
      <description>记录一下Nuxt博客项目部署到Docker环境的过程，这可能对将要部署Nuxt应用到Docker环境的你有所帮助~
编写Dockerfile文件 在你的Nuxt项目目录下编写Dockerfile如下示例：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 FROM node:12.16.2 # 创建容器工作目录 RUN mkdir -p /app WORKDIR /app # 拷贝package.json文件到容器工作目录， # 注意这个地方为什么没有拷贝yarn.lock或package-lock.json文件呢? # 原因是这样子的，如果你本地不是使用的淘宝的镜像源，而是使用的默认镜像源， # 这个时候你将它拷贝进来安装依赖的时候会有一个很大彩蛋，安装不成功！ # 拷贝不拷贝yarn.</description>
    </item>
    
    <item>
      <title>修改Docker容器时区</title>
      <link>https://shaichunfeng.com/post/2020/05/21/change-the-docker-container-timezone/</link>
      <pubDate>Thu, 21 May 2020 23:36:08 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/21/change-the-docker-container-timezone/</guid>
      <description>在启动Docker时并且上生产环境的时候必须要修改容器时区，要不然你产生的数据记录时间是比北京时间晚了8个小时的，因为Docker容器内默认采用的是UTC时间，但是时间是不对的，所以要修改容器时区为北京时间，时区为 Asia/shanghai，才可以~
修改Docker容器时区的方式有三种：第一种使用Dockerfile制作镜像时配置，第二种启动单个容器时配置，第三种你的容器已经启动的情况进行修改。
第一种、使用Dockerfile制作镜像时配置时区 优点是使用该镜像启动的新容器不需要再次修改，其原理就是将宿主主机的时区文件软链到容器内并且在容器内重写时区文件。在编写Dockerfile时添加如下代码：
1 2 ENV TIMEZONE=Asia/Shanghai RUN ln -snf /usr/share/zoneinfo/$TIMEZONE /etc/localtime &amp;amp;&amp;amp; echo $TIMEZONE &amp;gt; /etc/timezone 第二种、启动单个容器时配置时区 例如启动一个MYSQL容器进行挂载宿主主机本地时区，这个是参考：STACK OVERFLOW，经过测试/etc/timezone不会改变，固而这种方式不可取，你有好的想法? 说说看?
1 2 3 4 5 6 7 docker run --name mysql_tester \ --restart always \ -p 53306:3306 \ -v /etc/localtime:/etc/localtime:ro \ -e TZ=Asia/Shanghai \ -e MYSQL_ROOT_PASSWORD=hello \ -d mysql 第三种、你的容器已经启动的情况进行修改时区 这种方式，你每次启动新容器时都需要修改时区，那如果这个已经修改了时区的容器一直使用，或者说重启都没有什么问题。具体操作，首先进入到容器环境内部</description>
    </item>
    
    <item>
      <title>如何解决Go测试相对路径问题？来来掰扯掰扯</title>
      <link>https://shaichunfeng.com/post/2020/05/20/how-to-solve-the-relative-path-problem-of-go-test/</link>
      <pubDate>Wed, 20 May 2020 23:25:35 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/20/how-to-solve-the-relative-path-problem-of-go-test/</guid>
      <description>写这篇文章的初衷是想总结一下Go项目开发中关于解决测试相对路径问题的思考，你可能在Go项目中遇到了这个问题，测试通过了运行服务之后，访问已运行的服务发现它依然存在问题找不到相关资源，那你简单的将资源路径改对了，去重启服务之后资源也能找到了，好开心有木有? 不好意思你不要开心这早好不好，敢不敢不再跑跑你的测试，咦~ 怎么又找不到资源了，what the hell，怎么搞好嘛~ 来来一起搞搞看好了~
为什么会出现这种情况 原因是这样子的，比如这么说吧，在你的项目目录下有一个api目录，其中有一个markdown.go这个Go文件，在这个Go文件中定义了名为GetMarkdown的API接口，这个接口要访问项目目录下的static/markdown目录下的静态文件，那你可能在读取文件的时候直接给了一个文件路径如./static/markdown/article_1.md，你又在api目录下定义了一个测试文件markdown_test.go用于测试markdown相关的API接口，当你运行测试方法，测试GetMarkdown这个接口时，那么问题来了，当你跑测试的时候那当前测试程序是在项目api目录下，那这个测试程序它在访问资源的时候是以当前测试程序所在目录api为起点去查找相关资源的，这个时候你的api目录下并没有./static/markdown/article_1.md这个文件，所以它就找不到这个资源了，所以这个时候你有严谨的错误处理机制它就会被执行，把错误返回，告诉你 open ./static/markdown/article_1.md: no such file or directory。所以当你运行main.go的时候，访问GetMarkdown这个API接口它查找资源是在项目目录内，所以也就找到了static/markdown/article_1.md这个文件。这么说可能比较抽象，下面通过一个简单的示例项目说明这个问题。
示例项目目录结构 这个简单示例项目目录结构如下所示，hello-demo为项目名称：
1 2 3 4 5 6 7 8 9 10 11 $ tree . ├── api │ ├── markdown.go │ └── markdown_test.go ├── main.go └── static └── markdown ├── article_1.md ├── article_2.md └── article_3.</description>
    </item>
    
    <item>
      <title>如何解决Golang包循环引入问题？</title>
      <link>https://shaichunfeng.com/post/2020/05/19/how-do-i-solve-the-go-package-loop-introduction-problem/</link>
      <pubDate>Tue, 19 May 2020 23:14:53 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/19/how-do-i-solve-the-go-package-loop-introduction-problem/</guid>
      <description>Go不允许存在包的循环引入，你是不是也在项目开发时遇到过 import cycle not allowed 编译错误呢? 你找到好的解决方案了没有呢? 下文也许可能会对你解决这个问题有所帮助~
何为包的循环引入 如在项目中有bar包和foo包，假如bar包用到了foo包代码，并且foo包也用到了bar包代码，那么这时就会产生编译错误import cycle not allowed意为&amp;quot;不允许循环引入&amp;quot;。
假定示例项目结构如下：
1 2 3 4 5 6 7 8 9 $ depend git:(master) tree . ├── bar │ └── bar.go ├── foo │ └── foo.go └── main.go 2 directories, 3 files bar/bar.go代码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package bar import ( &amp;#34;depend/foo&amp;#34; &amp;#34;fmt&amp;#34; ) type Bar struct { Name string Description string } func NewBar(name string, description string) *Bar { return &amp;amp;Bar{Name: name, Description: description} } func (b *Bar) Info() { fmt.</description>
    </item>
    
    <item>
      <title>Golang 搭建的服务器局域网不能访问?</title>
      <link>https://shaichunfeng.com/post/2020/05/18/can-not-access-the-server-lan-built-by-go/</link>
      <pubDate>Mon, 18 May 2020 23:01:53 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/18/can-not-access-the-server-lan-built-by-go/</guid>
      <description>在Go项目中如果你想在局域网访问Go运行的服务器，那么就不应该指定其地址为 localhost:port 或者 127.0.0.1:port，应该指定为 :port 或 0.0.0.0:port 的形式！为什么呢？
说整明白这是怎么回事，这时候就是考验你网络基础的时候了，上大学的时候计算机专业都是有学过的哦(《计算机网络》想起来了吧)，来复习一下几个概念：
本地环回地址 域名解析 默认路由 何为本地环回地址 运用本地环回机制，便可在主机上运行网络服务，期间不须安装实体网络接口卡(也就是物理网卡)，也无须将该服务开放予主机所在的网络。例如，在设置好本地安装的网站后，可通过 http://localhost 这一网址，来访问本地网站！
域名解析一般会将localhost解析为IPv4本地环回地址 127.0.0.1 和IPv6本地环回地址 [::1]。
localhost是一个在计算机网络中用于表示 &amp;ldquo;此计算机&amp;rdquo; 的主机名。它被用于通过本地环回网络接口，来访问本机运行的服务，并且将会绕过任何物理网络接口硬件。—维基百科
何为域名解析 简单粗暴的解释就是从IP到域名转换。
由以上概念可知，localhost或127.0.0.1只能在本地主机里玩耍，玩的再嗨别的主机也不知道你玩什么，那么怎么也让别的主机知道你在玩什么呢? 或者说访问本地主机跑的服务，那这个时候就需要在复习一下什么是默认路由哦~
何为默认路由 默认路由(Default route)，是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由。目的地不丰路由器的路由表里的所有数据包都会使用默认路由。这条路由一般会连去另一个路由器，而这个路由器也同样处理数据包；如果知道应该怎么路由这个数据包，则数据包会被转发到已知的路由；否则，数据包会被转发到默认路由，从而到达另一个路由器。每次转发，路由都增加了一跳的距离。当到达了一个知道如何到达目的地址的路由器时，这个路由器就会根据最长前缀匹配来选择有效的路由。子网掩码匹配目的IP地址而且又最长的网络会被选择。用无类别域间路由标记表示的IPv4默认路由是0.0.0.0/0。—维基百科
由上可知 0.0.0.0 为默认路由，要想局域网内的其它主机访问当前主机要必须使用默认路由而不能使用localhost或127.0.0.1， :port 表示的就是0.0.0.0、localhost、127.0.0.1 之和，所示说，当前启动一个Go服务器的时候，要么明确指定 0.0.0.0:port 要么指定 :port 局域网内的其它主机方可访问到~
Go服务示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( &amp;#34;github.</description>
    </item>
    
    <item>
      <title>RESTFul接口设计时，添加记录时已存在资源应该返回什么状态码?</title>
      <link>https://shaichunfeng.com/post/2020/05/17/what-status-code-should-an-existing-resource-return-when-adding-a-record/</link>
      <pubDate>Sun, 17 May 2020 22:55:15 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/17/what-status-code-should-an-existing-resource-return-when-adding-a-record/</guid>
      <description>RESTFul接口设计时，添加记录时如果已存在资源时应该返回什么状态码比较合适? 400? 合适吗?
添加记录 RESTFul接口设计时，对于添加记录或者说是资源时，HTTP请求类型应该是POST方式，那么如果这个资源同名了，应该返回409比较合适，原意为资源冲突，当然话又说过来，对于添加资源更加严谨的流程应该是前端用户输入资源名称后去调用后端API接口检测是否存在同名资源，这样也有利于提高用户体验(这个要看具体的设计，不过一般也都会采用这样机制)，这里仅仅讨论的是后端处理已有资源时应该返回什么样的状态码比较合适的问题~，个人觉得 Conflict 还是比较合适的，你有更好的想法，请留言一起探讨哦~/:ok</description>
    </item>
    
    <item>
      <title>RESTFul接口设计时，退出登录是使用GET请求还是使用POST请求?</title>
      <link>https://shaichunfeng.com/post/2020/05/16/whether-to-logout-using-a-get-request-or-a-post-request/</link>
      <pubDate>Sat, 16 May 2020 22:45:38 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/16/whether-to-logout-using-a-get-request-or-a-post-request/</guid>
      <description>退出登录就是用户注销其在系统中的登录身份(或者说状态)，那么在开发的时候这个退出(logout)接口应该定义成什么样的请求类型呢？是GET还是POST?
关于注销登录 在各个系统中对于处理注销登录的机制也大同小异，说到注销登录就不得不说一下登录的机制，登录的机制在早期的后端开发中一般情况下是使用SESSION机制，进行标识一个用户登录状态。时下最流行的前后端分离开发模式，后端程序一般都会使用JWT做为认证机制，不管怎么说吧，这些登录机制就是在系统中进行标识用户登录状态，用户注销登录的时候，请求注销接口携带一个用户唯一标识如用户手机号，后端程序根据这个唯一标识去找到登录时在系统签发的唯一标识(一般存放在Redis这种内存级数据库)，将其进行过期或者删除登录标识，这个流程也就完毕了，用户也就退出了系统！
注销接口是该使用GET还是POST 这个问题从安全角度考虑应该使用POST，为什么这么说呢，那就应该从POST请求方式的本质来可虑了，我们都知道它是通过HTTP-Body进行数据携带而不是通过URL，所以应该使用POST请求方式做用户注销接口的定义，那为什么不用GET请求方式做用户注销登录接口的定义呢？原因主要是GET请求浏览器会进行URL缓存操作，所以使用GET请求不够安全！你也可以去验证一下大公司在做用户注销登录的时候，使用什么HTTP请求方式，如：京东，淘宝 之类的！</description>
    </item>
    
    <item>
      <title>[转载]Mysql Explain</title>
      <link>https://shaichunfeng.com/post/2020/05/15/mysql-explain/</link>
      <pubDate>Fri, 15 May 2020 00:10:43 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/15/mysql-explain/</guid>
      <description>在日常工作中，我们有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。（QEP：sql生成一个执行计划query Execution plan）。
1 2 3 4 5 6 7 mysql&amp;gt; explain select * from servers; +----+-------------+---------+------+---------------+------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+------+---------------+------+---------+------+------+-------+ | 1 | SIMPLE | servers | ALL | NULL | NULL | NULL | NULL | 1 | NULL | +----+-------------+---------+------+---------------+------+---------+------+------+-------+ row in set (0.</description>
    </item>
    
    <item>
      <title>Goland 代码自动换行</title>
      <link>https://shaichunfeng.com/post/2020/05/14/goland-code-wraps-automatically/</link>
      <pubDate>Thu, 14 May 2020 23:57:05 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/14/goland-code-wraps-automatically/</guid>
      <description>IntelliJ家族的IDE在设置代码自动换行时菜单是一致的，你如果用过其中一个特定的IDE如 IDEA，那么对于其它的IntelliJ家族编辑器也同样适用~
代码自动换行 分为单个文件或整个项目！
单个文件 设置菜单依次是: View -&amp;gt; Active Editor -&amp;gt; Soft-Wrap
整个项目 设置菜单依次是: Goland -&amp;gt; Preferences... -&amp;gt; Editor -&amp;gt; General -&amp;gt; Soft-Wrap，这个可以个性化定制对特定扩展名的文件进行设置自动换行！</description>
    </item>
    
    <item>
      <title>NuxtJS读取.env配置文件</title>
      <link>https://shaichunfeng.com/post/2020/05/13/nuxt-reads-the-env-configuration-file/</link>
      <pubDate>Wed, 13 May 2020 23:47:52 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/13/nuxt-reads-the-env-configuration-file/</guid>
      <description>在VUE项目中读取项目根目录下的.env文件可以直接通过 process.env.VUE_APP_EXAMPLE 的访问读取到 .env 配置文件的中 VUE_APP_EXAMPLE 配置项的具体值，在Nuxt项目中还直接这么干是读取不到滴~
那么在Nuxt项目中怎么读取 .env 的配置项呢？直接安装一个 dotenv 依赖包就可以解决！
安装dotenv 1 $ yarn add dotenv 加载env配置文件 修改nuxt.config.js，引入dotenv模块
1 const env = require(&amp;#39;dotenv&amp;#39;).config(); 在 module.exports 对象中添加如下属性即可
1 2 3 4 5 6 7 8 module.exports = { //...... // Setting env env: env.parsed, //...... } 好了，这样你就可以像在VUE项目中那样使用 process.env.VUE_APP_EXAMPLE 读取配置项啦~</description>
    </item>
    
    <item>
      <title>获取当前查询记录的上一条记录和下一条记录ID</title>
      <link>https://shaichunfeng.com/post/2020/05/12/gets-the-previous-record-and-the-next-record-id-of-the-current-query-record/</link>
      <pubDate>Tue, 12 May 2020 23:28:49 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/12/gets-the-previous-record-and-the-next-record-id-of-the-current-query-record/</guid>
      <description>比如有这么一个需求，获取当前文章记录数据并且返回当前记录的上一条记录ID和下一条记录ID，用于前端文章详情页的上一篇和下一篇文章获取，其实也特别的简单，顺便记录一下！
简略数据源如下：
查询分析 要获取当前查询记录ID为1000的记录的上一条记录ID: 999，可以在ID小于1000的范围内获取ID最大值；获取下一条记录ID: 1001，可以在大于1000的范围内获取ID最小值，那么这个事件也就算是完成了！
注意：获取上一条记录ID和下一条记录ID的临界点就是当前查询记录ID为1000的记录哦~
获取上一条记录ID 1 2 3 4 5 6 7 mysql&amp;gt; select max(id) as last_id from article where id &amp;lt; 1000; +---------+ | last_id | +---------+ | 999 | +---------+ 1 row in set (0.00 sec) 获取下一条记录ID 1 2 3 4 5 6 7 mysql&amp;gt; select min(id) as next_id from article where id &amp;gt; 1000; +---------+ | next_id | +---------+ | 1001 | +---------+ 1 row in set (0.</description>
    </item>
    
    <item>
      <title>Golang JSON RPC 使用</title>
      <link>https://shaichunfeng.com/post/2020/05/11/golang-json-rpc-use/</link>
      <pubDate>Mon, 11 May 2020 23:20:55 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/11/golang-json-rpc-use/</guid>
      <description>JSON-RPC，是一个无状态且轻量级的远程过程调用传送协议，其传递内容主要以JSON数据为主，相较于一般的 RESTFul 通过 URL 地址，如 GET /student 调用远程服务器，JSON-RPC直接在内容中定义了想要调用的方法名称如，@@{&amp;ldquo;id&amp;rdquo;: 123456, &amp;ldquo;method&amp;rdquo;: &amp;ldquo;Service.Division&amp;rdquo;, &amp;ldquo;params&amp;rdquo;: [{&amp;ldquo;A&amp;rdquo;: 88, &amp;ldquo;B&amp;rdquo;: 6}]}@@，这也令开发者不会陷于该使用 PUT 还是 POST 的问题中。在RPC服务定义中主要定义一些数据结构及其相关的处理规则。在Golang中所有注册的RPC服务方法需要满足三个条件，第一方法有一个输入参数，第二方法有一个指针类型的输出参数，第三方法返回一个error类型的返回值，满足这三个条件即可注册为RPC服务方法。在Golang中如何使用请看以下内容&amp;hellip;
示例项目目录结构 1 2 3 4 5 6 7 8 9 10 11 12 $ tree . ├── README.md ├── client │ └── demo │ └── demo.go ├── server │ └── demo │ └── demo.</description>
    </item>
    
    <item>
      <title>axios如何获取HTTP响应头数据?</title>
      <link>https://shaichunfeng.com/post/2020/05/10/how-does-axios-get-http-response-header-data/</link>
      <pubDate>Sun, 10 May 2020 23:12:49 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/10/how-does-axios-get-http-response-header-data/</guid>
      <description>说到如何获取HTTP响应头数据，就不得到说一下对于CORS请求，默认情况下，浏览器只能访问 Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma 这些Header头，那如果想访问服务器端自定义的Header头应该如何处理呢？
如果像axios这种请求工具想获取到HTTP自定义响应头如 X-Access-Token， 那么服务端首先应该对响应头 Access-Control-Expose-Headers 字段进行定义，如：Access-Control-Expose-Headers: X-Access-Token，axios就可以根据headers属性获取到HTTP自定义响应头数据。</description>
    </item>
    
    <item>
      <title>Golang格式化文件大小到可视化大小</title>
      <link>https://shaichunfeng.com/post/2020/05/09/golang-formats-file-size-to-visual-size/</link>
      <pubDate>Sat, 09 May 2020 22:59:44 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/09/golang-formats-file-size-to-visual-size/</guid>
      <description>在Golang中一个文件大小一般是int64类型的整数，这个类型的对程序而言是好的，不过如果提供前端展示性的数据的话，直接返回过去多少有点太那什么了&amp;hellip;&amp;hellip;这个还需要你和前端同学协商，不官怎么说总得有一方去处理，那这么Go在如何优雅的处理这个转换过程序呢？
可定义如下函数以进行转换操作：
1 2 3 4 5 6 7 8 9 10 11 12 13 // ByteCountBinary format byte size to human readable format. func ByteCountBinary(size int64) string { const unit int64 = 1024 if size &amp;lt; unit { return fmt.Sprintf(&amp;#34;%dB&amp;#34;, size) } div, exp := unit, 0 for n := size / unit; n &amp;gt;= unit; n /= unit { div *= unit exp++ } return fmt.</description>
    </item>
    
    <item>
      <title>MacOS 检测远程服务端口是否可用</title>
      <link>https://shaichunfeng.com/post/2020/05/06/mac-detects-if-the-remote-service-port-is-available/</link>
      <pubDate>Wed, 06 May 2020 22:52:38 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/05/06/mac-detects-if-the-remote-service-port-is-available/</guid>
      <description>远程服务开放端口是否是可用，比如说阿里云ECS有一个自定义端口8859对外开放服务，但是如果说只在ECS中使用 firewall 开放了端口，ECS的安全组没有配置其8859规则的话，外部网络是无法访问到ECS内部8859提供的服务的，也就是说对于阿里云ECS来说开放一个端口，你需要做两件事情，第一是在ECS内部添加开放商品，第二是在阿里云控制台对ECS实例添加安全组规则！
如果你在ECS内部开放了端口，你可以会忘记到阿里云ECS安全组添加开放端口无则，这时候你在本地系统中怎么连接都不能成功，你这时可能会非常之疑惑，唉，我明明在ECS内部开放了端口为什么就是不行呢？真是见鬼了，哈哈😄，稍安勿躁，只需 nc 命令去检测一下远程端口号是否可被访问，这个问题也就会明了多了，比如说远程服务器的IP地址为 10.8.9.256，你在ECS上添加了一个开放端口 8859，这时可以执行：
1 nc -z -w 1 10.8.9.256 8859 如果可以访问的话会提示如下：
1 Connection to 10.8.9.256 port 8859 [tcp/armcenterhttps] succeeded! 否则，端口不可访问，这时你也许会想到阿里云ECS还有一个东东叫实例安全组，添加对应的安全组规则之后，再次使用 nc 检测，这个问题也就解决了！
说明 nc 命令是一个 Linux 命令，在 Mac 系统中可以通过 brew 进行安装，在类UNIX系统中内置该命令！
参考 Linux nc command</description>
    </item>
    
    <item>
      <title>NGINX服务器如何配置HTTPS</title>
      <link>https://shaichunfeng.com/post/2020/04/08/how-does-nginx-server-configure-https/</link>
      <pubDate>Wed, 08 Apr 2020 22:18:41 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/04/08/how-does-nginx-server-configure-https/</guid>
      <description>超文本传输协议安全（HTTPS）是HTTP的安全版本，HTTP是用于在Web浏览器和网站之间发送数据的主要协议。HTTPS被加密，以提高数据传输的安全性。当用户传输敏感数据（例如通过登录银行帐户，电子邮件服务或健康保险提供商）时，这一点尤其重要。
任何网站，尤其是那些需要登录凭据的网站，都应使用HTTPS。在现代网络浏览器（例如Chrome）中，未使用HTTPS的网站与带有HTTPS的网站的标记有所不同。在网址栏中寻找绿色的挂锁，以表示该网页是安全的。Web浏览器非常重视HTTPS。Google Chrome浏览器和其他浏览器将所有非HTTPS网站标记为不安全。
获取证书 你可以到阿里云获取赛门铁克免费证书，亦或购买安全级别高的SSL证书！
配置NGINX 在你的nginx配置目录(如: server.d|servers)下，添加如example.com.conf文件，内容配置如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 server { listen 443 ssl; server_name example.com; # SSL signature. ssl_certificate /etc/nginx/ca/example.com/cert.pem; ssl_certificate_key /etc/nginx/ca/example.com/cert.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; # Http response body max size.</description>
    </item>
    
    <item>
      <title>CentOS7 相关操作</title>
      <link>https://shaichunfeng.com/post/2020/04/05/centos7-related-operations/</link>
      <pubDate>Sun, 05 Apr 2020 22:34:24 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/04/05/centos7-related-operations/</guid>
      <description>记录一下CentOS7日常操作，以便后期查看，温故之用，好记性不如烂笔头哦！🎉🎉🎉
开机启动服务 添加服务到chkconfig配置 1 $ chkconfig --add servername 开启服务开机启动 1 $ chkconfig docker on 资源管理 查看系统内存大小及使用情况 1 $ free -h 查看系统磁盘大小及使用情况 1 $ df -h 文件处理 查看文件的前几行 1 $ head -n number file 查看文件的后几行 1 $ tail -n number file 从文件后几行开始实时查看文件内容 这个很常用，一般文件都是追加写，而不是从头插入写，尤其是调试、监控时很有用
1 $ tail -f -n number file 查看文件的中间部分行 1 $ sed -n &amp;#39;StartNumber,EndNumber(p)&amp;#39; filename 用户管理 查看所有用户 1 $ cat /etc/passwd 查看所有用户组 1 $ cat /etc/group 端口占用 netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。</description>
    </item>
    
    <item>
      <title>CentOS7开放端口号</title>
      <link>https://shaichunfeng.com/post/2020/03/28/centos7-open-port-number/</link>
      <pubDate>Sat, 28 Mar 2020 22:29:03 +0800</pubDate>
      
      <guid>https://shaichunfeng.com/post/2020/03/28/centos7-open-port-number/</guid>
      <description>在基于RHEL7的服务器，提供了一个firewall的动态管理的防火墙，其支持IPv4和IPv6，还支持以太网桥，并有分离运行时间和永久性配置选择。它还具备一个通向服务或者应用程序以直接增加防火墙规则的接口。
加入开放端口到配置文件 1 $ firewall-cmd --zone=public --add-port=80/tcp --permanent 参数说明：
--zone=public: 添加时区 --add-port=80/tcp: 添加端口 --permanent: 永久生效 重新加载防火墙配置文件 以 root 身份输入以下命令，重新加载防火墙，并不中断用户连接，即不丢失状态信息.
1 $ firewall-cmd --reload </description>
    </item>
    
    <item>
      <title>Homepage Full</title>
      <link>https://shaichunfeng.com/homepage/full/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/full/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Homepage Full Left</title>
      <link>https://shaichunfeng.com/homepage/full-left/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/full-left/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Homepage Full Right</title>
      <link>https://shaichunfeng.com/homepage/full-right/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/full-right/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Homepage Grid</title>
      <link>https://shaichunfeng.com/homepage/grid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/grid/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Homepage Grid Left</title>
      <link>https://shaichunfeng.com/homepage/grid-left/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/grid-left/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Homepage Grid Right</title>
      <link>https://shaichunfeng.com/homepage/grid-right/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/grid-right/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Homepage List</title>
      <link>https://shaichunfeng.com/homepage/list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/list/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Homepage List Left</title>
      <link>https://shaichunfeng.com/homepage/list-left/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/list-left/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Homepage List Right</title>
      <link>https://shaichunfeng.com/homepage/list-right/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/homepage/list-right/</guid>
      <description></description>
    </item>
    
    <item>
      <title>No Search Found</title>
      <link>https://shaichunfeng.com/404/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/404/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Search Results</title>
      <link>https://shaichunfeng.com/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/search/</guid>
      <description></description>
    </item>
    
    <item>
      <title>标签</title>
      <link>https://shaichunfeng.com/summaries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/summaries/</guid>
      <description></description>
    </item>
    
    <item>
      <title>分类</title>
      <link>https://shaichunfeng.com/singles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/singles/</guid>
      <description></description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://shaichunfeng.com/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>晒春风</title>
      <link>https://shaichunfeng.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/about/</guid>
      <description>&amp;ldquo;当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。&amp;rdquo;
————威斯敏斯特教堂的碑文
我清晰的记着这是我在大一军训的时候，别的同学都在累的要死要活的体训后午休时，我在热追的一部剧《北京青年》，对我影响最深的一段话。
那是12年的8月份，该剧刚开播时，好像是还没有开学，那个时候每天凌晨都会等着爱奇艺更新，看完才睡觉，开了学我也想每天凌晨去追剧，可是时间不允许，因为紧接着就是要大一新生军训，所以要每天早睡，不睡也没办法因为同学们都累的跟哈巴狗似的，当然我也不例外，哈哈，所以中午军训，待中午军训结束后我就和同学赶紧跑到东餐厅吃午饭，当然，为了追剧我吃饭真是不要太快呦，回到宿舍别人都要睡觉，我还是要兴致勃勃的把刚更新的最新一集给看完，基本上等我看完一集也就开始下午的军训了，那个时候真没有因为看剧而觉得身体特别的累，可能是自己那个时候就非常憧憬剧中的情节了吧，从内心得了共鸣。当然，《北京青年》这部剧最能冲击我灵魂的一段话就是上面那段，那段话是 『何东』在到了深圳之后和那群借着重走青春之路美名的『青年们』开了『青春酒吧』后，被知名青年『王越』给拐跑，在爬雪山的时候『王越』对『何东』说的一段话，这段话真的意义非凡，毫不夸张地说，基本上可以影响到了我的人生吧。
大学生活 大学其实我的个人觉得每一个人都应该去读，有很多人都会在上完初中或高中就不上了，选择提前进入社会，如果今天你看到了我这么说，并且你也是其中的一位，或者说你打算这么干，我真的好像反问您一句『您真的就差这么几年？』等你真正意识到了，年龄也基本上过去了，后悔吧？晚了，真真的晚了，因为你在本该学习的年龄干了本不应该干的事，而恰恰是这几年可能会豪不夸张的改变你的人生轨迹，除非说你家庭条件好，有矿！
大学学习的是软件技术，上大学期间除了对编程语言感性趣，每天下午上完课回到宿舍鼓捣的最多的就是Linux操作系统，那个时候天天拿着我的ThinkPad E430，通过VMWare创建的虚拟机进行鼓捣，那个时候用的Linux发行版本有 Ubuntu、CentOS、Fedora 这些，不过后来在上社区注意到国内的这些互联网大佬企业们用的最大的还是 CentOS，再有就是 RedHat，CentOS后被RedHat收购，CentOS是社区版免费，所以用的也就比较多。本着学以至用的原则从此用上了 CentOS，说实话当真正习惯了 Linux 系统后，真心觉得 Windows 不好用，所以慢慢的想拥有一台MacPro的想法愈加强烈（工作之后才入手，哈哈，大学都是口袋空空的穷学生哪有钱买，16G内存、512固态硬盘，价格1万八左右，这个话给爸妈实在张不开嘴，反正是我没脸，你有吗？😄）。
进入社会 上大学那会真不知道工作都要求会那些技术，只是依稀的记着当初的目标就是毕业了就做个开发，当时比较火的语言是PHP，也不管了三七二十一先学了再说，在 windows 环境下有比较多的一键安装包，如wamp，当时用的就是wamp，是可参加了工作之后我发现这个wamp环境一般都不是使用集成环境，每次都要搭建一遍，因为集成环境可定制的空间比较小，公司每来一个新人都基本是先在自己本地机器上按好wamp环境才能进行开发工作，后来才觉得有些繁琐。后来真正让我有放弃从事PHP相关开发工作的原因是因为PHP本身是动态语言，总是被别人鄙视，让我印象最为深刻的是当时在中关村在线工作的时候，有一次技术分享会，一位之前从事JAVA开发的同学说像PHP这样的动态脚本解析性语言怎么怎么样，而JAVA怎么怎么的牛B，反正就是就是怎么也看不上PHP，但是最为搞笑的是他当时也在从事PHP相关的开发工作，哈哈。从那之后我就思考了被他这么说的原由，之后我得到的结论是PHP这种语言从为公司创造价值来说，开发项目比较快，产品可以快速实现。但是从执行效率上很显然不能与静态语言进行媲美，是时候考虑学习一门静态语言了，当时对比了JAVA、Go之后，毅然决然的选择了Go，为什么呢？JAVA大学学过相比与Go来说语法不够简洁，并且Go原生支持并发编程，号称是21世纪的C语言。做了这个确定之后就每天下班或周末就开始学习Go，从学习语法到做项目，在到工作中有项目要用到使用Go进行高并发核心业务处理，最终成功转型Go，之后再也没有用过PHP，也不会再用PHP，用Go之后你会发现，程序可以做到如此雅美。
人生充满各种不确定性，在有限的时光时我们不应该去虚度，学习这个小件事情其实是非常有意义的（当然了每一个人的人生规则是不同的，有的人向往在路上，有的人向往生活多姿多彩等等吧），往往你解决不了的大部分问题别人有可能早已攻克，多读书多实践，你会发现自己成长的合适方法，这些方式方法可能会成为我们人生中的无形财富。明天的你会感激今天努力的自己！这真真的并非是句空话，努力让自己变的优秀，我觉得应该是每一个有自我约束力的强者，一直走在这个过程的道路上（哈哈，当然你可能已经是啦）！
————晒春风</description>
    </item>
    
    <item>
      <title>晒春风</title>
      <link>https://shaichunfeng.com/author/%E6%99%92%E6%98%A5%E9%A3%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/author/%E6%99%92%E6%98%A5%E9%A3%8E/</guid>
      <description>Golang 开发者，一个灵魂无处安放的北漂。</description>
    </item>
    
    <item>
      <title>提交任何疑问或建议</title>
      <link>https://shaichunfeng.com/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/contact/</guid>
      <description></description>
    </item>
    
    <item>
      <title>隐私政策</title>
      <link>https://shaichunfeng.com/privacy-policy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shaichunfeng.com/privacy-policy/</guid>
      <description>在用户未授权的情况下，不获取用户数据。</description>
    </item>
    
  </channel>
</rss>
