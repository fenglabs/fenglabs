
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  
  

  [{"categories":["Golang"],"contents":"\n在@@Golang@@项目开发中，有时会有比较结构体是否相等的情况，通过@@Golang@@的语言特性可以总结为两点结论：只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关；结构体是相同的，但是结构体属性中有不可以比较的类型，如 @@map@@, @@slice@@, @@channel@@, @@function@@ 则结构体不能用 == 比较。下面通过一个示例来看看，结构体哪些可以比较哪些不可以比较。\n先来看一段示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import \u0026#34;fmt\u0026#34; func main() { sn1 := struct { age int name string }{age: 11, name: \u0026#34;tom\u0026#34;} sn2 := struct { age int name string }{age: 11, name: \u0026#34;tom\u0026#34;} if sn1 == sn2 { fmt.Println(\u0026#34;sn1 == sn2\u0026#34;) } sm1 := struct { age int m map[string]string }{age: 11, m: map[string]string{\u0026#34;a\u0026#34;: \u0026#34;1\u0026#34;}} sm2 := struct { age int m map[string]string }{age: 11, m: map[string]string{\u0026#34;a\u0026#34;: \u0026#34;1\u0026#34;}} if sm1 == sm2 { fmt.Println(\u0026#34;sm1 == sm2\u0026#34;) } } 上面这段代码将会编译不通过，上面我们也给出了结论，下面来说明：\n结论一：只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。\n1 2 3 4 5 6 7 8 9 sn1 := struct { age int name string }{age: 11, name: \u0026#34;tom\u0026#34;} sn3 := struct { name string age int }{age: 11, name: \u0026#34;tom\u0026#34;} 上面的 @@sn1@@ 与 @@sn3@@ 就是不同的结构体，所以不能进行比较。@@sn1@@ 与 @@sn2@@ 可以比较。\n结论二：结构体是相同的，但是结构体属性中有不可以比较的类型，如 @@map@@, @@slice@@, @@channel@@, @@function @@则结构体不能用 == 比较。但是可以使用 @@reflect.DeepEqual@@ 进行比较。\n1 2 3 4 5 if reflect.DeepEqual(sm1, sm2) { fmt.Println(\u0026#34;sm1 == sm2\u0026#34;) } else { fmt.Println(\u0026#34;sm1 != sm2\u0026#34;) } 以上就是结构体是否可以比较的相关说明，祝您阅读愉快~\n","date":"2022-04-03","image":null,"permalink":"https://shaichunfeng.com/post/2022/04/03/structure-comparison/","tags":["Struct"],"title":"结构体是否可以比较"},{"categories":["网络"],"contents":"路由器是连接两个或多个分组交换网络或子网络的设备。它有两个主要功能：通过将数据包转发到其预定的 IP 地址从而管理这些网络之间的流量，以及允许多个设备使用同一互联网连接。\n路由器分为几种类型，但大多数路由器在 LAN（局域网）和 WAN（广域网）之间传递数据。LAN 是一组限制在特定地理区域的连接设备。一个 LAN 通常只需要一个路由器。\n与之相反，WAN 是一个分布在广大地理区域的大型网络。例如，在全国各地多个地点运营的大型组织和公司将需要为每个地点建立单独的 LAN，然后与其他 LAN 连接，形成一个 WAN。由于 WAN 分布在一个大的区域内，它通常需要多个路由器和交换机*。\n网络交换机在同一网络的设备组之间转发数据包，而路由器则在不同网络之间转发数据。\n路由器如何工作？ 把路由器想象成一个空中交通指挥员，把数据包想象成飞往不同机场（或网络）的飞机。就像每架飞机都有一个唯一的目的地并遵循唯一的路线一样，每个数据包都需要被尽可能高效地引导到其目的地。与空中交通指挥员员确保飞机到达目的地而不迷路或沿途遭受重大干扰一样，路由器帮助引导数据包到达其目标 IP 地址。\n为了有效地引导数据包，路由器使用一个内部路由表——一个通往不同网络目的地的路径列表。路由器读取数据包的标头以确定其去向，然后查阅路由表以找出通往该目的地的最有效路径。然后，它将数据包转发到该路径中的下一个网络。\n路由器和调制解调器之间有什么区别？ 虽然一些互联网服务提供商 (ISP) 可能将路由器和调制解调器合并在一个设备中，但它们并不一样。两者在网络相互连接和连接到互联网方面发挥着不同但同等重要的作用。\n路由器形成网络并管理这些网络内部和之间的数据流，而调制解调器将这些网络连接到互联网。调制解调器通过将来自 ISP 的信号转换为可由任何连接设备解释的数字信号，来建立与互联网的连接。一台设备可以插入到调制解调器中，以便连接到互联网。另外，路由器可以帮助将这一信号分发给一个已建立网络中的多个设备，使所有设备能够同时连接到互联网。\n可以这样想：如果 Bob 有一个路由器，但没有调制解调器，他将能够创建一个 LAN 并在该网络上的设备之间发送数据。但是，他无法将该网络连接到互联网。另一方面，Alice 有一个调制解调器，但没有路由器。她将能够将单个设备连接到互联网（例如，她的工作笔记本电脑），但不能将该互联网连接分发到多个设备（比如说，她自己的笔记本电脑和智能手机）。与此同时，Carol 有一个路由器和一个调制解调器。使用这两种设备，她可以与她的台式电脑、平板电脑和智能手机组成一个 LAN，并将它们同时连接到互联网。\n有哪些不同类型的路由器？ 要将 LAN 连接到互联网，路由器首先需要与调制解调器通信。有两种主要的方式来实现这一点：\n无线路由器：无线路由器使用以太网电缆连接到调制解调器。它通过将数据包从二进制代码转换为无线电信号来分发数据，然后用天线无线广播信号。无线路由器不建立 LAN；相反，它创建 WLAN（无线局域网），使用无线通信连接多个设备。 有线路由器：与无线路由器一样，有线路由器也使用以太网电缆连接到调制解调器。然后它使用单独的电缆连接到网络内的一个或多个设备，创建一个 LAN，并将该网络内的设备连接到互联网。 除了适用于小型 LAN 的无线和有线路由器外，还有许多专门类型的路由器，用于提供特定的功能：\n核心路由器：与家庭或小型企业 LAN 内使用的路由器不同，核心路由器由大型公司和企业使用，用于在其网络内传输大量的数据包。核心路由器在网络的“核心”运作，不与外部网络通信。 边缘路由器：核心路由器专门管理大规模网络内的数据流量，而边缘路由器则同时与核心路由器和外部网络进行通信。边缘路由器位于网络“边缘”，使用 BGP（边界网关协议）发送和接收来自其他 LAN 和 WAN 的数据。 虚拟路由器：虚拟路由器是一种软件应用程序，其功能与标准硬件路由器相同。它可以使用虚拟路由器冗余协议 (VRRP) 来建立主要和备用的虚拟路由器（当主要路由器出现故障时使用）。 ","date":"2022-03-31","image":null,"permalink":"https://shaichunfeng.com/post/2022/03/31/what-is-a-router/","tags":["网络安全"],"title":"网络安全（六）| 路由器（Route）"},{"categories":["网络"],"contents":"网络路由是选择一个或多个网络上的路径的过程。路由原理可以应用于从电话网络到公共交通的任何类型的网络。在诸如互联网等数据包交换网络中，路由选择互联网协议 (IP) 数据包从其起点到目的地的路径。这些互联网路由决定由称为路由器的专用网络硬件做出。\n如上图所示，对于要从计算机 A 到达计算机 B 的数据包，它应该通过网络 1、3 和 5 还是通过网络 2 和 4？数据包通过网络 2 和 4 的路径会更短，但是网络 1、3 和 5 在转发数据包时可能比 2 和 4 更快。这些都是网络路由器不断做出的选择类型。\n路由如何工作？ 路由器通过参考内部路由表来决定如何沿网络路径路由数据包。路由表记录了数据包应到达路由器负责的每个目的地的路径。类似于列车时刻表，乘客会查阅时刻表以决定搭乘哪趟列车。路由表也是如此，但是用于网络路径而不是列车。\n路由器以下列方式工作：路由器接收到数据包时，会读取数据包的标头*以查看其预期的目的地，这种方式类似于列车票务员检查乘客的车票以确定他们应该乘坐的列车。然后，根据路由表中的信息确定将数据包路由到何处。\n路由器以每秒数百万次的速度处理数百万个数据包。当数据包到达其目的地时，它可能会被不同的路由器路由多次。\n路由表可以是静态的，也可以是动态的。静态路由表不变化。网络管理员手动设置静态路由表。除非管理员手动更新这些表，否则，路由表完全可以确定数据包在网络上的路由。\n动态路由表会自动更新。动态路由器使用各种路由协议（请参阅下文）来确定最短和最快的路径。它们还根据数据包到达目的地所需的时间做出决定 - 类似于 Google Maps、Waze 和其他 GPS 服务根据过去的驾驶性能和当前的驾驶条件确定最佳驾驶路线的方式。\n动态路由需要更多的计算能力，这就是为什么较小的网络可能依赖静态路由的原因。但是对于中型和大型网络，动态路由要高效得多。\n数据包头是附加在数据包上的一小束数据，可提供有用的信息，包括数据包的来源和去向，类似于在邮件包裹外部加盖的装箱单。\n主要的路由协议是什么？ 在网络中，协议是格式化数据的标准化方法，因此任何连接的计算机都可以理解数据。路由协议是用于标识或通知网络路径的协议。\n以下协议可帮助数据包在 Internet 上找到自己的路线：\nIP：Internet 协议（IP）明确每个数据包的起点和目的地。路由器检查每个数据包的 IP 标头，以确定将其发送到何处。 BGP：边界网关协议（BGP）路由协议用于通知哪些网络控制哪些 IP 地址以及哪些网络相互连接。（发出这些 BGP 通知的大型网络称为自治系统 。）BGP 是一种动态路由协议。 以下协议在 AS 中路由数据包：\nOSPF：网络路由器通常使用开放式最短路径优先（OSPF）协议来动态识别最快和最短的可用路由，以将数据包发送到目的地。 RIP：路由信息协议（RIP）使用“跃点计数”来查找从一个网络到另一网络的最短路径，其中“跃点计数”表示数据包在途中必须经过的路由器数量。（当数据包从一个网络到达另一个网络时，这种情况称为“跃点”。） 其他内部路由协议包括 EIGRP（增强型内部网关路由协议，主要用于 Cisco 路由器）和 IS-IS（中间系统到中间系统）。\n什么是路由器？ 路由器是一种网络硬件，负责将数据包转发到目的地。路由器连接到两个或多个 IP 网络或子网，并根据需要在它们之间传递数据包。路由器在家庭和办公室中用于建立本地网络连接。功能更强大的路由器在整个 Internet 上运行，从而帮助数据包到达目的地。\n参考 What is routing? | IP routing ","date":"2022-03-31","image":null,"permalink":"https://shaichunfeng.com/post/2022/03/31/what-is-routing/","tags":["网络安全"],"title":"网络安全（五）| IP 路由（IP Routing）"},{"categories":["网络"],"contents":"网络安全是一类使内部网络免受攻击和数据泄露的实践和技术。它包括访问控制、网络攻击防护、恶意软件检测和其他安全措施。 “网络安全”最常用于指对大型企业网络的保护。\n网络定义 网络是由两个或多个连接的计算设备组成的群体。网络的规模涵盖小型的个人区域网络 (PAN) 和局域网 (LAN) 到大型的广域网 (WAN)，这些网络跨越很远的距离连接小型网络。\n如今，几乎所有企业都依赖某种类型的网络来提高生产力，无论是允许员工访问互联网的 LAN、连接各个办公地点的 WAN，还是在云中执行这些功能的网络即服务 (NaaS)。\n有哪些常见的网络安全风险？ 像任何重要的企业资产一样，网络可能以各种方式受到损害。需要准备应对的威胁包括：\n未经授权的访问：如果未经授权的用户进入网络，他们就可以查看本来可以保持私有的机密信息。他们还可能泄露机密数据或破坏内部系统。 DDoS 攻击：分布式拒绝服务 (DDoS) 攻击旨在通过用垃圾流量淹没网络或服务器来减缓或拒绝向合法用户提供服务。DDoS 攻击可能使网络不堪重负，从而使其不再运作。 漏洞利用：攻击者可以利用登录门户、应用程序、硬件或其他方面的漏洞渗透到网络中，达到各种恶意目的。 恶意软件感染：常见的恶意软件感染包括加密或破坏数据的勒索软件；可以在整个网络中快速复制的恶意软件——蠕虫；以及允许攻击者跟踪用户行动的间谍软件。恶意软件可以从一系列来源进入网络，包括不安全的网站、受感染的员工设备或有针对性的外部攻击。 内部威胁：内部雇员或承包商在不了解安全最佳实践的情况下，会无意中破坏网络安全或泄露数据。在其他情况下，用户可能因为自己的原因而故意破坏网络或泄露数据。 有哪些重要的网络安全技术？ 网络安全是一个广泛的领域。下面只是组织可以用来保护其网络的一些技术。为了减少复杂性，大多数组织尽量依靠少数供应商来实现网络安全；许多企业都在寻求能同时提供上述几种技术的供应商。\n访问控制 访问控制限制对数据和用于操作该数据的软件的访问。这对于防止未经授权的访问和降低内部威胁的风险至关重要。身份和访问管理 (IAM) 解决方案可以在这个领域提供帮助。许多企业使用虚拟专用网络 (VPN) 来控制访问； 但如今，已经有了 VPN 的替代品。\n用户身份验证 身份验证是访问控制的一个重要组成部分。使用双因素身份验证 (2FA) 而不是简单的密码，是使网络更安全的一个重要步骤。\n防火墙 防火墙会从网络流量中过滤掉潜在威胁。它们可以阻止恶意软件攻击、漏洞利用、机器人攻击和其他威胁。传统的防火墙在企业的物理位置使用硬件设备运行。如今，许多防火墙可以在软件或云中运行，消除了对防火墙硬件的需求。\nDDoS 保护 网站和网络基础设施都需要防御 DDoS 攻击以保持运作。特别是，网络基础设施需要在网络层而不是应用程序层进行 DDoS 缓解。\n数据丢失防护（DLP） 防火墙和 DDoS 防护可以防止外部攻击进入网络，数据丢失防护 (DLP) 则阻止内部数据被带出网络。\n浏览器隔离 从网络内部访问互联网会带来风险，因为 Web 浏览涉及到在用户设备上执行来自外部不可信源（如各种网络服务器）的代码。浏览器隔离通过在组织的内部网络之外执行代码（通常是在云服务器上执行），消除了这种风险。\n企业还应该采取哪些措施来保障其网络安全？ 虽然不可能完全不受攻击，但以下步骤可以进一步降低风险：\n维持数据备份：即使是防御最严密的网络也会受到攻击。失去对内部数据和系统的部分或全部访问，对企业来说是毁灭性的；保持数据的备份有助于减轻这种攻击的影响。 用户教育：许多数据泄露和恶意软件感染的发生仅仅只是因为用户犯了一个错误，无论是意外打开了不安全的电子邮件附件，还是由于网络钓鱼攻击而提供了登录凭据，或者以其他方式允许外部访问。内部员工和承包商应了解如何保持安全和保护网络。 应用“零信任”理念：零信任安全是指默认不信任任何用户或设备的原则。 参考 What is network security? ","date":"2022-03-31","image":null,"permalink":"https://shaichunfeng.com/post/2022/03/31/network-security/","tags":["网络安全"],"title":"网络安全（四）| 网络安全（Network security）"},{"categories":["网络"],"contents":"安全访问服务边缘简称 SASE，是一种基于云的 IT 模型，它将软件定义的网络与网络安全功能捆绑在一起，并从单一服务提供商交付。“SASE”一词由全球研究和咨询公司 Gartner 在 2019 年提出。\nSASE 方法可以更好地控制和了解访问公司网络的用户、流量和数据，这些功能对于现代全球分布的组织来说至关重要。使用 SASE 构建的网络灵活且可扩展，能够通过任何设备连接分布在全球各地的员工和办公室。\nSASE 包括哪些安全功能？ SASE 将软件定义的广域网 (SD-WAN) 功能与一些网络安全功能相结合，所有这些功能都从一个云平台提供。通过这种方式，SASE 让员工能够从任何地方进行身分验证并安全地连接到内部资源，让企业更好地控制进出其内部网络的流量和数据。\nSASE 包括四个核心安全组件：\n安全 Web 网关 (SWG)：SWG 可从 Web 流量中过滤不需要的内容，阻止未经授权的用户行为，并执行企业安全策略，从而预防网络威胁和数据泄露。SWG 可以部署在任何地方，因此是确保远程员工安全的理想选择。 云访问安全代理 (CASB)：CASB 为云托管服务执行多项安全功能，包括：揭示影子 IT（未经授权的公司系统）、通过访问控制和数据丢失防护 (DLP) 保护机密数据，以及确保符合数据隐私法规。 零信任网络访问 (ZTNA)：ZTNA 平台锁定内部资源，不允许公开查看，并要求对每个受保护应用程序的每个用户和每台设备进行实时验证，以助防止潜在的数据泄露。 防火墙即服务（FWaaS）：FWaaS 是指从云端作为服务交付的防火墙。FWaaS 保护云端平台、基础设施和应用程序免受网络攻击。与传统防火墙不同，FWaaS 不是物理设备，而是一组安全能力，其中包括 URL 过滤、入侵防御以及对所有网络流量的统一策略管理。 根据供应商和企业的需求，这些核心组件可能与其他安全服务捆绑在一起，包括 Web 应用程序和 API 保护 (WAAP)、远程浏览器隔离或 Wi-Fi 热点保护。\nSASE 框架有哪些优点？ 与传统的基于数据中心的网络安全模型相比，SASE 具有多个优点：\n基于身份的零信任网络访问。SASE 高度依赖于零信任安全模型，在用户身份得到验证之前，该模型不会授予用户访问应用程序和数据的权限 —— 即使他们已经在私有网络的边界内也不例外。在建立访问策略时，SASE 方法不仅仅考虑实体的身份；它还考虑用户的位置、所处时段、企业安全标准、合规性策略以及对风险/信任的持续评估等因素。 阻止对网络基础设施的攻击。SASE 的防火墙和 CASB 组件有助于防止外部攻击（如 DDoS 攻击和漏洞利用）进入并损害内部资源。SASE 方法可以保护本地网络和基于云的网络。 防止恶意活动。通过过滤 URL、DNS 查询以及其他传出和传入网络流量，SASE 有助于防止基于恶意软件的攻击、数据泄露和针对公司数据的其他威胁。 实施和管理更简单。SASE 将单点安全解决方案合并到单一云端服务中，企业可与更少的供应商进行交互，并节省配置物理基础设施所需的时间、金钱和内部资源。 策略管理更简单。SASE 允许组织在单一门户上设置、调整和实施覆盖所有位置、用户、设备和应用程序的访问策略，而不必为不同解决方案处理多种策略。 延迟优化的路由。SASE 通过一个全球边缘网络来路由网络流量，在尽可能靠近用户的位置进行处理，从而帮助减少延迟。路由优化可以根据网络拥塞和其他因素帮助确定最快的网络路径。 SASE 与传统网络相比有何不同？ 在传统的网络模型中，数据和应用程序位于核心数据中心内。为了访问这些资源，用户、分支机构和应用程序从本地私有网络或二级网络（其一般通过安全租用线路或 VPN 连接到主要网络）连接到数据中心。\n事实证明，这种模式无法应对软件即服务 (SaaS) 等基于云的服务带来的复杂性以及分布式劳动力的兴起。如果应用程序和数据托管在云中，则通过集中式数据中心重新路由所有流量不再可行。\n相比之下，SASE 将网络控制置于云端边缘，而不是企业数据中心。与需要单独配置和管理的分层云服务不同，SASE 简化了网络和安全服务，以创建安全的网络边缘。通过在边缘网络上实施基于身份的零信任访问策略，企业可以将其网络边界扩展到任何远程用户、分支机构、设备或应用程序。\n组织如何实施 SASE 许多组织对 SASE 实施采取逐一进行的方法。事实上，有些人可能已经在不知不觉中采用了某些 SASE 元素。要全面采用 SASE 模型，组织可采取以下关键步骤：\n保护远程员工 将分支机构置于云边界内 将 DDoS 保护移到边缘 将自我托管的应用程序迁移到云端 用统一的云原生政策执行取代安全设备 这些步骤在白皮书《SASE 入门》中进行了进一步细分，可在此处下载。\n参考 What is SASE? | Secure access service edge ","date":"2022-03-31","image":null,"permalink":"https://shaichunfeng.com/post/2022/03/31/what-is-sase/","tags":["网络安全"],"title":"网络安全（三）| 安全访问服务边缘（SASE）"},{"categories":["网络"],"contents":"网络即服务 (NaaS) 是一种云服务模式，在这种模式中，客户从云供应商那里租用网络服务。NaaS 允许客户操作他们自己的网络，而不需要维护他们自己的网络基础设施。与其他云服务一样，NaaS 供应商使用软件运行网络功能，其本质上允许公司完全在没有硬件的情况下建立自己的网络。他们只要有互联网连接即可。\nNaaS 可以取代虚拟专用网络 (VPN)、多协议标签交换 (MPLS) 连接或其他传统的网络配置。它还可以取代内部网络硬件，如防火墙设备和负载平衡器。作为一种较新的路由流量和应用安全策略的模式，NaaS 对企业网络架构产生了重大影响。\nNaaS 的发展过程 当大多数企业配置他们的网络基础设施时，互联网本身并不被认为是开展业务的可信场所。因此，他们建立了自己的内部私有互联网版本，并通过租用链接将设施相互连接。他们需要配置自己的广域网 (WAN)，每个办公地点都需要自己的防火墙、DDoS 防护、负载平衡等硬件。企业还需要使用 MPLS 等方法在每个位置之间建立专用连接。\n当员工连接到互联网而不是内部网络时，他们的流量必须先经由 VPN 通过公司网络基础设施，然后才能到达互联网。例如，如果一家公司的总部位于德克萨斯州奥斯汀，而路易斯安那州新奥尔良分公司的一名公司员工需要加载一个网站，他们对该网站的 HTTP 请求将通过公司 VPN，通过 MPLS 链接到位于奥斯汀的总部（距离约 800 公里），然后向外延伸到更广泛的互联网。\n随着一些业务活动开始迁移到云中，这种模式很快变得低效。例如，假设新奥尔良的员工经常使用 SaaS 应用程序，这意味着他们需要不断地通过互联网加载内容。他们的请求以及其他员工的请求将成为奥斯汀数据中心的瓶颈，从而降低网络服务速度。\n此外，随着云计算变得更加高效，更多的功能开始通过云来提供。如今，DDoS 缓解、防火墙、负载平衡和其他重要的网络功能都可以在云中运行，无需内部 IT 团队构建和维护这些服务。\n出于这些原因，NaaS 是一种比依赖内部维护的 WAN 更有效的选择，后者需要不断维护并且经常为网络流量造成瓶颈。借助 NaaS，公司员工可以通过外部供应商管理和保护的虚拟网络直接连接到他们的云服务，而不是内部 IT 团队试图跟上对网络服务的需求。\n如果我们的示例公司切换到 NaaS 模式，则位于新奥尔良的员工不再需要等待他们的网络流量通过所有内部公司基础设施。相反，他们只需连接到互联网并通过浏览器登录，就可以访问他们需要的所有云服务。同时，NaaS 提供商保护他们的浏览活动、保护他们的数据，并尽可能高效地将他们的 Web 流量路由到任何需要去的地方。\n从许多方面来说，NaaS 是几十年来业务流程向云迁移的逻辑结果。如今，整个网络可以作为一种服务提供，而不仅仅是软件、基础设施或平台。\nNaaS 有哪些挑战？ 兼容性：NaaS 供应商的基础设施可能与仍然存在的旧系统（旧硬件、基于本地的应用程序等）不兼容。\n传统数据中心：在许多企业中，重要的应用程序和流程仍然在内部数据中心运行，而不是在云中。这使得向 NaaS 模式的迁移略显困难。\n供应商锁定：迁移到云服务总是会带来风险，即企业可能会变得过于依赖特定的服务提供商。如果服务提供商的基础设施出现故障，或者他们提高价格，供应商锁定就会产生重大影响。\nNaaS 有什么优势？ 灵活性：云服务提供更大的灵活性和更大的定制化。通过软件而不是硬件对网络进行更改。IT 团队通常能够按需重新配置他们的公司网络。\n可扩展性：像 NaaS 这样的云服务天生比基于硬件的传统服务更具可扩展性。企业 NaaS 客户可以简单地从供应商处购买更多容量，而不是购买、插入并开启更多硬件。\n从任何地方访问：根据云网络的配置方式，用户可以使用任何设备从任何地方访问它，而无需使用 VPN，尽管这带来了对强大的访问控制的需求。理想情况下，用户只需互联网连接和登录凭据即可。\n无需维护：云提供商维护网络并管理软件和硬件升级。\n与安全捆绑在一起：NaaS 使单一提供商可以同时提供网络服务和防火墙等安全服务。这使网络和网络安全之间能够更紧密的集成。\n节省成本：这种优势取决于供应商。但是，购买云服务而不是构建自己的服务通常会节省成本：云客户不需要购买和维护硬件，供应商已经拥有提供服务所需的服务器。\nNaaS 与 SASE 有何关系？ 安全访问服务边缘 (SASE) 结合了软件定义的网络和网络安全功能，所有这些都通过单一的服务提供商提供。与 NaaS 一样，SASE 将网络功能托管在云中，并将它们与安全功能结合起来。在许多方面，NaaS 和 SASE 都是当今越来越多企业采用的运营模式。\n参考 What is NaaS (network-as-a-service)? ","date":"2022-03-31","image":null,"permalink":"https://shaichunfeng.com/post/2022/03/31/network-as-a-service-naas/","tags":["网络安全"],"title":"网络安全（二）| 网络即服务（NaaS）"},{"categories":["网络"],"contents":"网络是一组相互连接的计算机，而企业网络就是这样一个为满足大型企业的需求而构建的组。企业网络由局域网 (LAN) 组成，局域网又连接到广域网 (WAN) 和云。\n在企业环境中，数据中心、分支机构、公共和私有云、物联网 (IoT) 设备以及组织的个人员工都需要可靠的网络连接。这些连接让企业能够交换数据、运行业务流程并分析网络上发生的事情——从本质上讲，网络使运行业务成为可能。\n与互联网不同，企业网络并非对所有想连接的人开放。企业网络将连接限制在特定的用户、设备和设施。它们通常使用虚拟专用网络 (VPN) 或传输层安全性 (TLS) 加密对通过它们的数据进行加密。\n企业网络也因其规模而不同于其他类型的网络。一般人可以访问家庭 LAN，通过单个路由器将一些设备连接到互联网。但企业运行的内部网络将数千台设备相互连接并连接到互联网。\n企业网络运作方式 多年来，企业网络的主要关注点是将所有人和物连接到本地自托管的集中式数据中心，在该数据中心保存数据并运行应用程序。这种访问是通过将用户和设备连接到公司办公室的 LAN 来提供的。每个办公室的 LAN 通过大型企业 WAN 连接到其他办公室，通常通过专用的多协议标签交换 (MPLS) 路由构建。\n企业网络基础设施由物理设备组成，它们通过以太网电缆和 WiFi 信号的组合相互连接并连接到个人计算机、打印机和物联网设备。使用的网络设备包括：\n路由器将数据从一个网络发送到另一个网络，实现网络到网络的连接和互联网访问。 交换机将网络内的数据转发给各个设备。 网关使用多种协议，在不同的网络之间以及在 OSI 模型的多个层之间提供连接。 防火墙处理进出网络的所有流量，以阻止潜在攻击。 负载平衡器在数据中心的多个服务器之间分配网络流量，以确保没有服务器过载（负载平衡器可以为 Web 应用程序做同样的事情）。 VPN 服务器建立和终止 VPN 连接，提供对内部网络的安全访问。 通常情况下，连接到企业网络需要连接到 VPN。VPN 加密用户和 VPN 服务器之间的流量，此时用户可以访问内部 LAN。\n企业网络的发展变化历程 如今的企业网络与几年前企业网络的运作方式大不相同。云迁移和新的安全挑战相结合，使得上述企业网络模型不适合现代企业的需求，尽管许多组织仍在使用它。\n如今的员工可能从办公室内部和外部连接到网络。他们连接到云和企业内部的数据中心（混合云模型），或者只连接到云。这使得集中式网络基础设施效率低下，因为网络成为进出云的流量的瓶颈。\n此外，上述许多硬件设备现在都可以作为软件或作为虚拟化云服务。对于使用基于硬件的基础设施的网络，如要扩大规模，则需要购买和激活更多的硬件。但对于使用基于软件的基础设施（如 SD-WAN）的网络，使用便宜的商品硬件即可扩大规模，而无需特定于供应商的硬件。而且，使用云基础设施扩大规模（例如，如果使用 NaaS），就像从云供应商处购买更多服务一样简单。\n在所有这些不断发展的趋势下，一个高效、现代的企业网络架构可能看起来更像是这样：\n全球研究和咨询公司 Gartner 创造了安全访问服务边缘 (SASE) 一词来描述这种新的网络模型。在 SASE 中，网络服务与安全服务紧密集成，网络访问不再集中在少数几个物理位置。\nSASE 将几种技术和服务纳入一个平台：\n软件定义的广域网 (SD-WAN)：除了 MPLS 外，SD-WAN 还允许使用几种不同的连接方法。 安全 Web 网关 (SWG)：SWG 可以过滤掉 Web 流量中的威胁，无论员工从哪里连接。 防火墙即服务 (FWaaS)：FWaaS 是一种基于云的防火墙，取代了传统企业网络使用的基于硬件的旧防火墙。 云访问安全代理 (CASB)：CASB 结合了基于云的应用程序和基础设施的几个安全功能。 零信任网络访问 (ZTNA)：ZTNA 通过不断地验证用户和设备，以及仅基于需求允许访问，来防止数据泄露。 这些技术加在一起，使有效的当代企业网络成为可能。然而，如今的大多数企业仍然夹在新旧模式之间，因此市场全面采用 SASE 尚需时日。\n由于许多企业仍然部分依赖于传统的本地基础设施，因此他们需要确保实施一个可以与传统数据中心和云一起使用的 SASE 平台。\n参考 What is enterprise networking? ","date":"2022-03-31","image":null,"permalink":"https://shaichunfeng.com/post/2022/03/31/enterprise-networking/","tags":["网络安全"],"title":"网络安全（一）| 企业网络（Enterprise networking）"},{"categories":["Golang","设计模式"],"contents":"工厂模式（Factory Pattern）是面向对象编程中的常用模式。在 Golang 项目开发中，你可以通过使用简单工厂模式、抽象工厂模式、工厂方法模式，来使代码更简洁明了。 简单工厂模式返回结构体类型；而抽象工厂模式返回接口类型；工厂方法返回一个闭包，下面具体的看看每一种工厂模式的使用。\nGolang 中的结构体，可以理解为面向对象编程中的类，例如 Student 结构体（类）实现了 SayHello 方法。\n1 2 3 4 5 6 7 8 9 type Student struct { name string // 可以使用uint8类型表示例sex别，这里为了仅仅只是为了直观可视 sex string } func (s Student) SayHello() { fmt.Printf(\u0026#34;Hi! My name is %s, %s\u0026#34;, s.name, s.sex) } 有了 Student 结构体（类），就可以创建 Student 实例。我们可以通过简单工厂模式、抽象工厂模式、工厂方法模式这三种方式，来创建一个 Student 实例。\n简单工厂模式 这三种工厂模式中，简单工厂模式是最常用、最简单的。它是一个接受一些参数，然后返回 Student 实例的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Student struct { name string // 可以使用uint8类型表示例sex别，这里为了仅仅只是为了直观可视 sex string } func (s Student) SayHello() { fmt.Printf(\u0026#34;Hi! My name is %s, %s\u0026#34;, s.name, s.sex) } func NewStudent(name, sex string) *Student { return \u0026amp;Student{ name: name, sex: sex, } } 相比 s := \u0026amp;Student{} 这种创建实例的方式而言，简单工厂模式可以确保创建的实例具有需要的参数，进而保证实例的方法可以按预期执行。例如，通过 @@NewStudent@@ 创建 @@Student@@ 实例时，可以确保实例的 name 和 sex 字段（属性）被设置。\n抽象工厂模式 下面来看抽象工厂模式，抽象工厂模式和简单工厂模式相比唯一的区别，就是它返回的是接口（interface{}）而不是结构体。通过返回接口，可以在你不公开内部实现的情况下让调用者使用你提供的各种功能，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Student interface { SayHello() } type student struct { name string sex string } func (s student) SayHello() { fmt.Printf(\u0026#34;Hi! My name is %s, %s\u0026#34;, s.name, s.sex) } // NewStudent returns an interface func NewStudent(name, sex string) Student { return student{ name: name, sex: sex, } } 上面代码，定义了一个不可导出的结构体 student，在通过 NewStudent 创建实例的时返回的是接口，而不是结构体。 通过返回接口的好处是，我们还可以实现多个不同的工厂函数，来返回接口的不同实现，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package factory import \u0026#34;fmt\u0026#34; type Student interface { SayHello() } // 中学生 type middle struct { name string sex string } func (s middle) SayHello() { fmt.Printf(\u0026#34;Hi! My name is %s, %s, middle student\\n\u0026#34;, s.name, s.sex) } // NewMiddleStudent 返回一个Student接口类型的中学生实现。 func NewMiddleStudent(name, sex string) Student { return middle{ name: name, sex: sex, } } // 大学生 type college struct { name string sex string } func (s college) SayHello() { fmt.Printf(\u0026#34;Hi! My name is %s, %s, college student\\n\u0026#34;, s.name, s.sex) } // NewCollegeStudent 返回一个Student接口类型的大学生实现。 func NewCollegeStudent(name, sex string) Student { return college{ name: name, sex: sex, } } // SayHello 接受一个 Student 接口类型，这其实一种动态类型，DuckTyping func SayHello(student Student) { student.SayHello() } @@NewCollegeStudent@@和@@NewMiddleStudent@@都返回了同一个接口类型@@Student@@，这使得二者可以互换使用。在上面代码中我们还定义了一个@@SayHello@@函数，该函数接受一个@@Student@@接口类型实现，这样我们仅仅只需要调用@@Student@@接口的@@SayHello@@方法即可，我们并不关心你是 \u0026ldquo;中学生\u0026rdquo; 还是 \u0026ldquo;大学生\u0026rdquo;，只要你实现了@@SayHello@@方法，你也就实现了这个接口。\n下面这段代码是上面这段代码的测试用例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func Test_Student(t *testing.T) { var student Student // 中学生 student = NewMiddleStudent(\u0026#34;tom\u0026#34;, \u0026#34;male\u0026#34;) // Hi! My name is tom, male, middle student student.SayHello() // 大学生 student = NewCollegeStudent(\u0026#34;kitty\u0026#34;, \u0026#34;female\u0026#34;) // Hi! My name is kitty, female, college student student.SayHello() } func Test_SayHello(t *testing.T) { // 中学生 Hi! My name is tom, male, middle student SayHello(NewMiddleStudent(\u0026#34;tom\u0026#34;, \u0026#34;male\u0026#34;)) // 大学生 Hi! My name is kitty, female, college student SayHello(NewCollegeStudent(\u0026#34;kitty\u0026#34;, \u0026#34;female\u0026#34;)) } 第一个测试用例@@Test_Student@@，因为@@NewMiddleStudent@@和@@NewCollegeStudent@@都返回的是@@Student@@同一个接口，所有它们可以赋值给@@student@@变量。\n第二个测试用例@@Test_SayHello@@我想说明的是@@DuckTyping@@问题，这也是面向接口开发的一个好处，我们不需要关心是 \u0026ldquo;小学生\u0026rdquo; 还是 \u0026ldquo;中学生\u0026rdquo; 异或是 \u0026ldquo;大学生\u0026rdquo;，只要你能 \u0026ldquo;问好(实现了@@SayHello@@方法)\u0026rdquo; 我们就让你 \u0026ldquo;上车\u0026rdquo;，否则不好意思。\n工厂方法模式 在简单工厂模式中，依赖于唯一的工厂对象，如果我们需要实例化一个产品，就要向工厂中传入一个参数，获取对应的对象；如果要增加一种产品，就要在工厂中修改创建产品的函数。这会导致耦合性过高，这时我们就可以使用工厂方法模式。\n在工厂方法模式中，依赖工厂接口，我们可以通过实现工厂接口来创建多种工厂，将对象创建从由一个对象负责所有具体类的实例化，变成由一群子类来负责对具体类的实例化，从而将过程解耦。\n下面是工厂方法模式的一个代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Student struct { name string sex string } func NewStudentFactory(sex string) func(name string) Student { return func(name string) Student { return Student{ name: name, sex: sex, } } } 然后，我们可以使用此功能来创建具有默认性别的工厂：\n1 2 3 4 5 6 7 8 // 默认性别（男） maleStudent := NewStudentFactory(\u0026#34;male\u0026#34;) tom := maleStudent(\u0026#34;tom\u0026#34;) david := maleStudent(\u0026#34;david\u0026#34;) // 默认性别（女） femaleStudent := NewStudentFactory(\u0026#34;female\u0026#34;) kitty := femaleStudent(\u0026#34;kitty\u0026#34;) 本博文到此结束，祝你愉快~\n","date":"2022-03-26","image":null,"permalink":"https://shaichunfeng.com/post/2022/03/26/golang-design-patten-for-factory/","tags":["设计模式"],"title":"Golang设计模式（二） | 工厂模式"},{"categories":["Golang","设计模式"],"contents":"单例模式（Singleton Pattern），是最简单的一个模式。在 Go 中，单例模式指的是全局只有一个实例，并且它负责创建自己的对象。单例模式不仅有利于减少内存开支，还有减少系统性能开销、防止多个实例产生冲突等优点。\n因为单例模式保证了实例的全局唯一性，而且只被初始化一次，所以比较适合『全局共享一个实例，且只需要被初始化一次的场景』，例如数据库实例、全局配置、全局任务池等。\n单例模式又分为饿汉方式和懒汉方式。饿汉方式指全局的单例实例在包被加载时创建，而懒汉方式指全局的单例实例在第一次被使用时创建。你可以看到，这种命名方式非常形象地体现了它们不同的特点。\n接下来，我就来分别介绍下这两种方式。先来看饿汉方式。\n饿汉方式 下面是一个饿汉方式的单例模式代码：\n1 2 3 4 5 6 7 8 9 10 package singleton type singleton struct { } var instance *singleton = \u0026amp;singleton{} func GetInstanceOr() *singleton { return instance } 你需要注意，因为实例是在包被导入时初始化的，所以如果初始化操作比较耗时，会导致程序加载时间比较长。\n懒汉方式 懒汉方式是开源项目中使用最多的，但它的缺点是非并发安全，在实际使用时需要加锁。以下是懒汉方式不加锁的一个实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package singleton type singleton struct { } var instance *singleton func GetInstanceOr() *singleton { if instance == nil { instance = \u0026amp;singleton{} } return instance } 可以看到，在创建 @@instance@@ 时，如果 @@instance==nil@@，就会再创建一个 @@instance@@ 实例，这时候单例就会有多个实例。\n为了解决懒汉方式并发安全的问题，需要对实例进行加锁，下面是带检查锁的一个实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import \u0026#34;sync\u0026#34; type singleton struct { } var instance *singleton var mu sync.Mutex func GetInstance() *singleton { if instance == nil { mu.Lock() if instance == nil { instance = \u0026amp;singleton{} } mu.Unlock() } return instance } 通过，上述代码只有在创建时才会加锁，既提高了代码效率，又保证了并发安全。\n除了饿汉方式和懒汉方式，在 Golang 中，还有一种更优雅的实现方式，在实际的应用中建议采用这种方式，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package singleton import ( \u0026#34;sync\u0026#34; ) type singleton struct { } var instance *singleton var once sync.Once func GetInstanceOr() *singleton { once.Do(func() { instance = \u0026amp;singleton{} }) return instance } 在@@Golang@@的项目开发中，单例模式是使用的相对较多的一种设计模式，前文也提到了，单例保证了实例的全局唯一性，在数据库实例、全局配置、全局任务池等场景需要使用到单例模式。\n本博文到此结束，祝你愉快~\n","date":"2022-03-26","image":null,"permalink":"https://shaichunfeng.com/post/2022/03/26/golang-design-patten-for-singleten/","tags":["设计模式"],"title":"Golang设计模式（一） | 单例模式"},{"categories":["Linux"],"contents":"Linux服务器新安装系统时区有可能不正确，直接导致的结果就是所有产生的数据所使用的时间都不是本地时间，对数据的影响比较大，因为时区不正嘛，所以也就会出来这种情况。Linux服务器的时间设置，可以通过手动配置也可以通过网络进行同步，还可以通过修改系统的时区来达到我们的预期。\n修改时区 通过修改时区的方式有两种方式，一种是即时生效，一种是重启生效。\n即时生效 可以使用系统预置的时区文件中的 Shanghai 文件，对 /etc/localtime 文件进行覆盖操作：\n1 $ sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 修改之后可以通过date命令进行确认是否生效：\n1 2 $ sudo date 2021年 09月 19日 星期日 16:58:43 CST 重启生效 再一种方式是通过修改系统时钟配置文件@@/etc/sysconfig/clock@@来修改系统时间配置。\n","date":"2021-09-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/09/19/linux-server-settings-time/","tags":["time","timezone","date"],"title":"Linux服务器设置时间"},{"categories":["Linux"],"contents":"在MacOS系统下安装rockylinux首先就是需要安装一个虚拟机，MacOS系统虚拟机产品有 VMware、VirtualBox、PD可供选择使用，VirtualBox 是开源免费产品，不过在MacOS下个人使用的过程中感觉不够完美，PD 和 VMware 是收费产品，现阶段 PD 对 M1 处理器支持的比较好，不过好在 VMware 有一个 VMware Fusion Player 版本，可供个人使用，一直在使用感觉还不错，并且可以使用 vmrun 终端工具管理虚拟机非常方便。安装 VMware Fusion Player 之后需要安装 rockylinux，虚拟机安装@@Linux@@操作系统跟物理机没有什么差别，下面操作步骤中会说。最后想简单说明一下 vmware 虚拟机软件提供的 vmrun 终端工具如何使用，接下来进行详情说明~\nStep1、安装VMware VMware Fusion Player 可以到 VMware 官网进行下载。\n下载需要登录用户，如果没有账号请先注册一个，登录之后可以看到如下页面:\n单点下载 Manually Download 下载就可以了，并且还有一个 LICENSE KEYS 拷贝下来保存到本地文件中或其它存储介质均可。\n安装的话也比较简单只需要双击下载下来的 VMware-Fusion-12.1.2-17964953.dmg 文件，一直点击 next 即可，然后到输入 LICENSE KEYS 的页面时，将拷贝下来的 LICENSE KEYS 内容粘贴输入框激活即可。\nStep2、安装rockylinux 安装rockylinux涉及到镜像下载、系统安装、网卡配置等操作。因为要在本地虚拟化一个linux环境，所以不想它的网卡每次通过DHCP动态分配，所以需要将其设置为静态网卡，这样方便在MacOS宿主机直接确定IP，使用SSH工具直接连接到本地虚拟化的linux环境服务器即可。当然你也可以选择云服务器（如阿里去ECS、或腾讯云主机等产品）。\n下载镜像 访问https://rockylinux.org进入到官网进行下载。\n根据自己的需要进行选择合适的系统镜像文件：\n运算符 含义 Minimal 最小化系统 DVD 标准系统(包含通用工具如桌面GNOME) Boot 仅仅包含引导系统 Torrent 下载BT种子文件 Checksum 内容一致性校验码文件 系统安装 打开 VMware Fusion Player 工具，选择 + -\u0026gt; 新建...:\n选择 从光盘或映像中安装 点击 继续：\n点击 使用其他光盘或光盘映像 ：\n在打开的Finder文件管理窗口中选择下载的 rockylinux 镜像文件，点击 打开：\n在 选择操作系统安装光盘或映像 列表就会出现刚刚添加的 rockylinux 系统镜像文件，点击继续：\n在 选择操作系统 页面，选择 Linux -\u0026gt; CenOS 8 64位 即可，（rockylinux 的作者和 CentOS 原作者是同一人，rockylinux 之所以会有 rockylinux 发行版，就是因为红帽高级副总裁兼首席技术官Chris Wright 宣布将不再维护CentOS Linux，所以就有了 rockylinux 项目，谁对谁错也不好评论，有兴趣的可以了解一下），点击 继续：\n在 选择固件类型 页面，按默认值 传统 BIOS 即可，点击 继续：\n出现 完成 页面，点击 完成：\n此时会让你选择虚拟机存储目录，选择一个位置并在存储为文件框内输入文件要存在的目录，如： CentOS.8.64BIT，会生成一个 CentOS.8.64BIT.vmwarevm 的目录。\n此时开始进入系统安装，使用方向键选择 Install Rocky Linux 8 按 Enter 键，进行安装引导程序。\n在 您在安装过程中想使用哪种语言？ 列表中选择 中文 -\u0026gt; 简体中文（中国），点击 继续：\n在 安装信息摘要 页面，点击 用户设置 -\u0026gt; 根密码：\n输入 root 密码，点击 完成：\n之后再次返回到 安装信息摘要 页面，点击 系统 -\u0026gt; 安装目的地：\n点击选择 本地标准磁盘 下的 VMware, VMware Virtual...，点击 完成：\n再次返回到 安装信息摘要 页面，此时 开始安装 按钮变为激活状态，点击 开始安装：\n系统安装这时才真正开始，因为是最小化安装，所以也非常快，大概10分钟的样子：\n系统安装完成之后，点击 重启系统。\n系统引导程序会将系统重新启动。\n最终出现上面的用户登录提示，输入 root 用户名，按 Enter 键之后输入密码：\n使用 root 身份登录成功，至此 rockylinux 系统的安装也就告一段落啦~\n配置网卡 登录到系统后，查看 /etc/sysconfig/network-script/ 目录，你会看到有一个网络配置文件：\n1 2 3 $ ll /etc/sysconfig/network-scripts/ 总用量 4 -rw-r--r--. 1 root root 332 9月 15 22:19 ifcfg-ens33 注意：你安装的 @@rockylinux@@ 系统可能跟我网卡配置文件不太一样，不过没有关系，它都是网卡配置文件。\n使用 vim 编辑器修改 ifcfg-ens33 网卡配置文件。\n首先修改 BOOTPROTO 将 BOOTPROTO 值，由默认的 dhcp 修改为 static。什么意思呢？就是将网卡IP由动态分配，修改为静态(指定一个特定IP)，所谓静态IP就是你配置网卡IP后，它的IP将永远不会改变。\n1 BOOTPROTO=static 其次修改：ONBOOT 将 ONBOOT 值，由默认的 no 修改为 yes。什么意思呢？就是配置在系统重新启动时，开启网卡服务，要不然你的网卡将无法使用，因为它没有开启，你必须手动开启网卡服务才对连接到网络（如果你的服务器在其它城市你要不飞过去自己开启网卡服务，要不找服务器所在城市的朋友帮你开启，是不是非常惨，当然你不会犯这么低级的错误）。\n1 ONBOOT=yes 最后添加静态IP信息 1 2 3 4 IPADDR=192.168.0.223 GATEWAY=192.168.0.1 NETMASK=255.255.255.0 DNS1=114.114.114.114 IPADDR: IP地址。 GATEWAY: 网关地址。 NETMASK: 子网掩码地址。 DNS1: DNS服务器地址。 如何确认上面这几个参数？使用最简单的方式，也就是查看MacOS系统网卡配置属性， -\u0026gt; 系统偏好设置... -\u0026gt; 网络 -\u0026gt; 高级 -\u0026gt; TCP/IP\n可以看到设备在当前局域网IP为 192.168.0.105，随便找一这个不可能用到的IP，配置上即可，如上面是 192.168.0.223，因为我的路由器不会有人用到这个IP（设备比较少嘛），所以用它绑定了我的虚拟机网卡IP，这没有任何问题，也不会造成IP冲突。\n可以看到路由器IP地址为 192.168.0.1 在家庭局域网中这个路由器就是网关，因这个局域网网络拓扑非常简单。子网掩码就是 255.225.255.0，114.114.114.114 是 Google 提供的公众DNS(域名解析服务器)服务地址。\n其它的配置项不用做任何修改，保存退出即可。\n网卡管理 在上面的 配置网卡 部分，已经将网卡配置为静态IP，那么现在就需要重启网卡服务，以使其生效。rockylinux8 默认使用 nmcli（用于控制 NetworkManager 的命令行工具），进行管理网卡服务。\n首先需要使用 NetworkManager's connections 命令下的子命令 reload 重启加载网卡配置信息：\n1 $ nmcli c reload 然后，使用 NetworkManager's connections 命令下的子命令 down 关闭网卡：\n1 $ nmcli c down /etc/sysconfig/network-scripts/ifcfg-ens33 接着，使用 NetworkManager's connections 命令下的子命令 up 重新启动网卡：\n1 $ nmcli c up /etc/sysconfig/network-scripts/ifcfg-ens33 最后通过 ifconfig 命令验证网卡是否生效:\nnmcli 工具非常强大更多使用细节可以参考 GNOME 官网的 nmcli 项目使用说明。当然你也可以通过 nmcli -h 命令查看更多使用细节，还可以通过 man nmcli 命令进行文档说明信息。\nStep3、VMware终端工具vmrun使用 VMware Fusion Player 的安装目录在 /Applications/VMware\\ Fusion.app，其中 Contents/Public/ 子目录下包含一个 vmrun 可执行文件:\n1 2 $ ll /Applications/VMware\\ Fusion.app/Contents/Public lrwxr-xr-x@ 1 root wheel 16B 4 30 16:37 vmrun -\u0026gt; ../Library/vmrun 这个终端工具可以帮助我们实现命令管理虚拟机的相关操作:\nPOWER COMMANDS: 开机相关命令。 SNAPSHOT COMMANDS: 快照相关命令。 NETWORKADAPTER COMMANDS: 网络适配器相关命令。 HOST NETWORK COMMANDS: 主机网络相关命令。 GUEST OS COMMANDS: 来宾操作系统相关命令。 GENERAL COMMANDS: 一般相关命令。 Template VM COMMANDS: 模板虚拟机的相关命令。 这个工具涉及的功能比较全面，如果你想更深入的了解或学习这些命令的使用，可以查看vmware官方文档。\n不过用的最多的还是无界面启动，因为是安装的最小化linux嘛，主要作为本地服务器来使用，下面说一下常用的命令操作。\n无界面启动 执行下如下命令即可无界面启动 rockylinux8，它就连 vmware 虚拟机的应用界面也不会启动（不会存在GUI守护进程）。\n1 vmrun start ~/Virtuals/ROCKYLINUX8.64BIT.vmwarevm/ROCKYLINUX8.64BIT.vmx nogui 无界面停止 如果在无界面状态下已经启动了虚拟机，想要停止它你可以运行如下命令（当然在有界面启动的状态下也可以使用该命令，不过它不会将已经打开的GUI程序关闭）将它停止。\n1 vmrun stop ~/Virtuals/ROCKYLINUX8.64BIT.vmwarevm/ROCKYLINUX8.64BIT.vmx 无界面重启 如果想要重启虚拟机可以使用 reset 子命令进行虚拟机重启（有无界面与上面的无界面停止表现一致，下面的这几个命令也是一样）。\n1 vmrun reset ~/Virtuals/ROCKYLINUX8.64BIT.vmwarevm/ROCKYLINUX8.64BIT.vmx 无界面挂起 所谓的挂起是会保存当前虚拟机的状态的。注意，挂起之后需要使用 vmrun start /vmware/machines/xxxx.vmx 进行还原。\n1 vmrun suspend ~/Virtuals/ROCKYLINUX8.64BIT.vmwarevm/ROCKYLINUX8.64BIT.vmx 无界面暂停 虚拟机暂停仅仅只是暂停，不会保存虚机机状态，注意，暂停之后需要使用 vmrun unpause /vmware/machines/xxxx.vmx 命令进行恢复。\n1 vmrun pause ~/Virtuals/ROCKYLINUX8.64BIT.vmwarevm/ROCKYLINUX8.64BIT.vmx 无界面恢复 1 vmrun unpause ~/Virtuals/ROCKYLINUX8.64BIT.vmwarevm/ROCKYLINUX8.64BIT.vmx ","date":"2021-09-16","image":null,"permalink":"https://shaichunfeng.com/post/2021/09/16/mac-use-vmware-install-rackylinux/","tags":["rockylinux","install","vmware"],"title":"MacOS使用VMware安装rockylinux"},{"categories":["Safe"],"contents":"撞库攻击可能会使个人和企业数据面临严重风险。在这里，我们将进一步了解撞库攻击，如何进行检测和防范，以及为什么它们对企业和个人都构成如此大的威胁。\n什么是撞库？ 撞库攻击是网络犯罪分子试图使用一组帐密同时访问多个帐户。撞库之所以如此有效，是因为近三分之二的互联网用户重复使用他们的密码。网络犯罪分子在几分钟或几个小时的时间内即可将被盗的帐密输入数千个网站，从社交媒体帐户到公司专有软件等，都会受到影响。\n撞库攻击的原理是什么？ 撞库攻击取决于密码的重复使用。由于有很多人将密码重复用于多个帐户，因此仅凭一组帐密足以暴露其大部分或全部帐户。网络犯罪分子利用僵尸网络等工具在多个设备上执行多条战线攻击，只需一组帐密即可扩展攻击能力。\n据估计，大约 80% 的数据入侵 都与泄露密码有关，这就引出了一个问题：为什么这么多人仍然使用一个密码来管理他们的帐户？\n当攻击者成功进行撞库攻击后，他们就有可能可以控制用户的银行信息、社交媒体帐户等。这可能直接导致金钱或其他资产被盗、敲诈勒索或身份盗窃。\n撞库与密码喷洒 撞库和密码喷洒类似，但密码喷洒取决于用户名，而不是整套帐密。密码喷洒涉及使用经过验证的用户名，并将其与一些不同的常见密码组合尝试用于多个帐户。如果用户没有养成良好的密码习惯，则通过猜测常见密码可能会危及其大多数或全部帐户。\n如何检测撞库攻击 及早检测到撞库攻击可以给您足够的时间做出反应并保护您的帐户。方法如下：\n对于个人用户 检测撞库攻击非常简单，只需对每个帐户进行两步验证/多步验证即可。如果您的帐户可能被篡改，您将收到警报，并且要求提供一组额外的凭据才能登录帐户。\n对于企业用户 用于机器人流量的异常检测器。 这些工具有助于检测传入网络流量的异常情况，并在有机器人程序传入时通知您。撞库依赖于能够快速输入帐密的自主机器人，因此检测它们可及早采取措施。 定期扫描泄露数据库检查共用登录。 执行包括扫描数据库在内的常规系统维护可以提供预警，并可能减少数据泄露造成的损失。 使用设备和浏览器指纹。 生物识别凭据可提供高强度的唯一登录。密码与生物识别帐密相结合可以使帐户安全性强 10 倍。 监视 VPN。 如何防范撞库攻击 对于个人用户 尽可能使用多步验证/两步验证 了解密码安全 使用密码管理程序自动生成高强度随机密码，确保登录帐密安全 不要重复使用密码 使用复杂的安全问题和可靠的登录帐密 对于企业用户 为所有公司帐户实施多步验证/两步验证 在登录页面使用 CAPTCHA 在全公司范围提升密码和网络安全教育 制定严格的网络安全政策 限制源于自主系统编号的流量 使用 Web 应用防火墙 (WAF) 使用 IP 块列表限制身份验证请求/登录尝试 从 Web 信息/历史记录中保留已知不良 IP 的运行列表/块 相关参考 Keeper 撞库攻击指南 ","date":"2021-08-20","image":null,"permalink":"https://shaichunfeng.com/post/2021/08/20/credential-stuffing-attacks/","tags":["credential"],"title":"撞库攻击"},{"categories":["Safe"],"contents":"文件上传漏洞 导致该漏洞的原因在于代码作者没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。\n1、前端JavaScript过滤绕过\n如果想要在一个开启了JavaScript验证的网站上传一句话木马，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-\u0026gt;打开intercept(拦截)-\u0026gt;将木马的后缀名改为jpg格式-\u0026gt;点击forward将数据包发回，这样就可以上传成功。最后用菜刀连接。 还有一种方法就是在地址栏输入：about:config，搜索javascript:enabled,双击关闭，也可以成功。\n2、Content-Type绕过\nContent-Type一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件。 如果想要在一个有type验证的网站上传一句话木马，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-\u0026gt;打开intercept(拦截)-\u0026gt;修改包内的Content-Type值：将application/octet-stream修改为image/jpeg。-\u0026gt;点击forward将数据包发回，这样就可以上传成功。\n3、扩展名绕过\n如果想要绕过有扩展名验证的网站上传一句话木马，这个很简单，可以把后缀换成大小写的方式绕过。\n4、00截断绕过\n想通过00%截断来绕过有验证的网站上传一句话木马。将上传的文件名命名为test.php%00.jpg格式，我们可以给浏览器设置代理，127.0.0.1，端口为8080.利用BurpSuite软件代理-\u0026gt;打开intercept(拦截)-\u0026gt;修改包内的Content-Type值：将%00右击选择Covert selection选项中的URL进行编码-\u0026gt;点击forward将数据包发回，这样就可以上传成功。注：系统在对文件名的读取时，如果遇到%00，就会认为读取已结束，不在读取后面的内容。\n解析漏洞 文件包含漏洞 XSS跨站脚本攻击 CSRF 目录遍历漏洞 命令执行漏洞 代码执行漏洞 反序列化漏洞 参考链接 常见漏洞原理简介 ","date":"2021-08-20","image":null,"permalink":"https://shaichunfeng.com/post/2021/08/20/exploits-principle/","tags":["exploits"],"title":"漏洞原理"},{"categories":["Golang"],"contents":"私有库是那些不想公开的库，不开源或不共享的存储库，比如公司内部开发的go包，或自己个人Github服务器上的私有go包，通过go get直接下载私有包是不被允许的，要通过一些设置才可以访问私有存储库。\n配置Git 1 $ git config --global url.git@github.com:.insteadOf https://github.com/ 最终会将上面执行的命令添加到git配置文件中，具体如下所示：\n1 2 3 $ cat ~/.gitconfig [url \u0026#34;git@github.com:\u0026#34;] insteadOf = https://github.com/ 配置Go环境 为了让 Go 模块工作（使用 Go 1.11 或更新版本），您还需要设置 GOPRIVATE 变量，以避免使用公共服务器来获取代码：\n1 $ go env -w GOPRIVATE=github.com/private/repo 如果需要访问多个存储库则需要多次添加，并以逗号分隔\n1 $ go env -w GOPRIVATE=github.com/private/repo-a,github.com/private/repo-b 下载私有库 1 $ go get github.com/private/repo ","date":"2021-08-07","image":null,"permalink":"https://shaichunfeng.com/post/2021/08/07/go-private-library-access-settings/","tags":["private","package"],"title":"Go 私有库访问设置"},{"categories":["Golang"],"contents":"删除Slice的一个元素 1 2 3 func remove(slice []int, index int) []int { return append(slice[:index], slice[index+1:]...) } 清空Slice的所有元素 1 2 3 func remove(slice []int) []int { return slice[:0] } ","date":"2021-07-26","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/26/slice-use/","tags":["slice"],"title":"Slice 具体使用"},{"categories":["Go系列教程"],"contents":"在这一章我们将学习如何使用 Go 语言将数据写到文件里面。并且还要学习如何同步的写到文件里面。\n这章教程包括如下几个部分：\n将字符串写入文件 将字节写入文件 将数据一行一行的写入文件 追加到文件里 并发写文件 请在本地运行所有本教程的程序，因为 playground 对文件的操作支持的并不好。\n将字符串写入文件 最常见的写文件就是将字符串写入文件。这个写起来非常的简单。这个包含以下几个阶段。\n创建文件 将字符串写入文件 我们将得到如下代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { f, err := os.Create(\u0026#34;test.txt\u0026#34;) if err != nil { fmt.Println(err) return } l, err := f.WriteString(\u0026#34;Hello World\u0026#34;) if err != nil { fmt.Println(err) f.Close() return } fmt.Println(l, \u0026#34;bytes written successfully\u0026#34;) err = f.Close() if err != nil { fmt.Println(err) return } } 在第 9 行使用 create 创建一个名字为 test.txt 的文件。如果这个文件已经存在，那么 create 函数将截断这个文件。该函数返回一个文件描述符。\n在第 14 行，我们使用 WriteString 将字符串 Hello World 写入到文件里面。这个方法将返回相应写入的字节数，如果有错误则返回错误。\n最后，在第 21 行我们将文件关闭。\n上面程序将打印：\n1 11 bytes written successfully 运行完成之后你会在程序运行的目录下发现创建了一个 test.txt 的文件。如果你使用文本编辑器打开这个文件，你可以看到文件里面有一个 Hello World 的字符串。\n将字节写入文件 将字节写入文件和写入字符串非常的类似。我们将使用 Write 方法将字节写入到文件。下面的程序将一个字节的切片写入文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { f, err := os.Create(\u0026#34;/home/naveen/bytes\u0026#34;) if err != nil { fmt.Println(err) return } d2 := []byte{104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100} n2, err := f.Write(d2) if err != nil { fmt.Println(err) f.Close() return } fmt.Println(n2, \u0026#34;bytes written successfully\u0026#34;) err = f.Close() if err != nil { fmt.Println(err) return } } 在上面的程序中，第 15 行使用了 Write 方法将字节切片写入到 bytes 这个文件里。这个文本在目录 /home/naveen 里面。你也可以将这个目录换成其他的目录。剩余的程序自带解释。如果执行成功，这个程序将打印 11 bytes written successfully。并且创建一个 bytes 的文件。打开文件，你会发现该文件包含了文本 hello bytes。\n将字符串一行一行的写入文件 另外一个常用的操作就是将字符串一行一行的写入到文件。这一部分我们将写一个程序，该程序创建并写入如下内容到文件里。\n1 2 3 Welcome to the world of Go. Go is a compiled language. It is easy to learn Go. 让我们看下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { f, err := os.Create(\u0026#34;lines\u0026#34;) if err != nil { fmt.Println(err) f.Close() return } d := []string{\u0026#34;Welcome to the world of Go1.\u0026#34;, \u0026#34;Go is a compiled language.\u0026#34;, \u0026#34;It is easy to learn Go.\u0026#34;} for _, v := range d { fmt.Fprintln(f, v) if err != nil { fmt.Println(err) return } } err = f.Close() if err != nil { fmt.Println(err) return } fmt.Println(\u0026#34;file written successfully\u0026#34;) } 在上面程序的第 9 行，我们先创建一个名字叫做 lines 的文件。在第 17 行，我们用迭代并使用 for rang 循环这个数组，并使用 Fprintln Fprintln 函数 将 io.writer 做为参数，并且添加一个新的行，这个正是我们想要的。如果执行成功将打印 file written successfully，并且在当前目录将创建一个 lines 的文件。lines 这个文件的内容如下所示：\n1 2 3 Welcome to the world of Go1. Go is a compiled language. It is easy to learn Go. 追加到文件 这一部分我们将追加一行到上节创建的 lines 文件中。我们将追加 File handling is easy 到 lines 这个文件。\n这个文件将以追加和写的方式打开。这些标志将通过 Open 方法实现。当文件以追加的方式打开，我们添加新的行到文件里。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { f, err := os.OpenFile(\u0026#34;lines\u0026#34;, os.O_APPEND|os.O_WRONLY, 0644) if err != nil { fmt.Println(err) return } newLine := \u0026#34;File handling is easy.\u0026#34; _, err = fmt.Fprintln(f, newLine) if err != nil { fmt.Println(err) f.Close() return } err = f.Close() if err != nil { fmt.Println(err) return } fmt.Println(\u0026#34;file appended successfully\u0026#34;) } 在上面程序的第 9 行，我们以写的方式打开文件并将一行添加到文件里。当成功打开文件之后，在程序第 15 行，我们添加一行到文件里。程序成功将打印 file appended successfully。运行程序，新的行就加到文件里面去了。\n1 2 3 4 Welcome to the world of Go1. Go is a compiled language. It is easy to learn Go. File handling is easy. 并发写文件 当多个 goroutines 同时（并发）写文件时，我们会遇到竞争条件(race condition)。因此，当发生同步写的时候需要一个 channel 作为一致写入的条件。\n我们将写一个程序，该程序创建 100 个 goroutinues。每个 goroutinue 将并发产生一个随机数，届时将有 100 个随机数产生。这些随机数将被写入到文件里面。我们将用下面的方法解决这个问题 .\n创建一个 channel 用来读和写这个随机数。 创建 100 个生产者 goroutine。每个 goroutine 将产生随机数并将随机数写入到 channel 里。 创建一个消费者 goroutine 用来从 channel 读取随机数并将它写入文件。这样的话我们就只有一个 goroutinue 向文件中写数据，从而避免竞争条件。 一旦完成则关闭文件。 我们开始写产生随机数的 produce 函数：\n1 2 3 4 5 func produce(data chan int, wg *sync.WaitGroup) { n := rand.Intn(999) data \u0026lt;- n wg.Done() } 上面的方法产生随机数并且将 data 写入到 channel 中，之后通过调用 waitGroup 的 Done 方法来通知任务已经完成。\n让我们看看将数据写到文件的函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func consume(data chan int, done chan bool) { f, err := os.Create(\u0026#34;concurrent\u0026#34;) if err != nil { fmt.Println(err) return } for d := range data { _, err = fmt.Fprintln(f, d) if err != nil { fmt.Println(err) f.Close() done \u0026lt;- false return } } err = f.Close() if err != nil { fmt.Println(err) done \u0026lt;- false return } done \u0026lt;- true } 这个 consume 的函数创建了一个名为 concurrent 的文件。然后从 channel 中读取随机数并且写到文件中。一旦读取完成并且将随机数写入文件后，通过往 done 这个 cahnnel 中写入 true 来通知任务已完成。\n下面我们写 main 函数，并完成这个程序。下面是我提供的完整程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;sync\u0026#34; ) func produce(data chan int, wg *sync.WaitGroup) { n := rand.Intn(999) data \u0026lt;- n wg.Done() } func consume(data chan int, done chan bool) { f, err := os.Create(\u0026#34;concurrent\u0026#34;) if err != nil { fmt.Println(err) return } for d := range data { _, err = fmt.Fprintln(f, d) if err != nil { fmt.Println(err) f.Close() done \u0026lt;- false return } } err = f.Close() if err != nil { fmt.Println(err) done \u0026lt;- false return } done \u0026lt;- true } func main() { data := make(chan int) done := make(chan bool) wg := sync.WaitGroup{} for i := 0; i \u0026lt; 100; i++ { wg.Add(1) go produce(data, \u0026amp;wg) } go consume(data, done) go func() { wg.Wait() close(data) }() d := \u0026lt;-done if d == true { fmt.Println(\u0026#34;File written successfully\u0026#34;) } else { fmt.Println(\u0026#34;File writing failed\u0026#34;) } } main 函数在第 41 行创建写入和读取数据的 channel，在第 42 行创建 done 这个 channel，此 channel 用于消费者 goroutinue 完成任务之后通知 main 函数。第 43 行创建 Waitgroup 的实例 wg，用于等待所有生产随机数的 goroutine 完成任务。\n在第 44 行使用 for 循环创建 100 个 goroutines。在第 49 行调用 waitgroup 的 wait() 方法等待所有的 goroutines 完成随机数的生成。然后关闭 channel。当 channel 关闭时，消费者 consume goroutine 已经将所有的随机数写入文件，在第 37 行 将 true 写入 done 这个 channel 中，这个时候 main 函数解除阻塞并且打印 File written successfully。\n现在你可以用任何的文本编辑器打开文件 concurrent，可以看到 100 个随机数已经写入 本教程到此结束。希望你能喜欢，祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/36-write-file/","tags":["File"],"title":"Go系列教程（三十六） | 写入文件(Write File)"},{"categories":["Go系列教程"],"contents":"文件读取是所有编程语言中最常见的操作之一。本教程我们会学习如何使用 Go 读取文件。\n本教程分为如下小节。\n将整个文件读取到内存 使用绝对文件路径 使用命令行标记来传递文件路径 将文件绑定在二进制文件中 分块读取文件 逐行读取文件 将整个文件读取到内存 将整个文件读取到内存是最基本的文件操作之一。这需要使用 ioutil 包中的 ReadFile 函数。\n让我们在 Go 程序所在的目录中，读取一个文件。我已经在 GOPATH（译注：原文是 GOROOT，应该是笔误）中创建了文件夹，在该文件夹内部，有一个文本文件 test.txt，我们会使用 Go 程序 filehandling.go 来读取它。test.txt 包含文本 “Hello World. Welcome to file handling in Go”。我的文件夹结构如下：\n1 2 3 4 src filehandling filehandling.go test.txt 接下来我们来看看代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; ) func main() { data, err := ioutil.ReadFile(\u0026#34;test.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;File reading error\u0026#34;, err) return } fmt.Println(\u0026#34;Contents of file:\u0026#34;, string(data)) } 由于无法在 playground 上读取文件，因此请在你的本地环境运行这个程序。\n在上述程序的第 9 行，程序会读取文件，并返回一个字节切片，而这个切片保存在 data 中。在第 14 行，我们将 data 转换为 string，显示出文件的内容。\n请在 test.txt 所在的位置运行该程序。\n例如，对于 linux/mac，如果 test.txt 位于 /home/naveen/go/src/filehandling，可以使用下列步骤来运行程序。\n1 2 3 $ cd /home/naveen/go/src/filehandling/ $ go install filehandling $ workspacepath/bin/filehandling 对于 windows，如果 test.txt 位于 C:\\Users\\naveen.r\\go\\src\\filehandling，则使用下列步骤。\n1 2 3 \u0026gt; cd C:\\Users\\naveen.r\\go\\src\\filehandling \u0026gt; go install filehandling \u0026gt; workspacepath\\bin\\filehandling.exe 该程序会输出：\n1 Contents of file: Hello World. Welcome to file handling in Go. 如果在其他位置运行这个程序（比如 /home/userdirectory），会打印下面的错误。\n1 File reading error open test.txt: The system cannot find the file specified. 这是因为 Go 是编译型语言。go install 会根据源代码创建一个二进制文件。二进制文件独立于源代码，可以在任何位置上运行。由于在运行二进制文件的位置上没有找到 test.txt，因此程序会报错，提示无法找到指定的文件。\n有三种方法可以解决这个问题。\n使用绝对文件路径 使用命令行标记来传递文件路径 将文件绑定在二进制文件中 让我们来依次介绍。\n1. 使用绝对文件路径 要解决问题，最简单的方法就是传入绝对文件路径。我已经修改了程序，把路径改成了绝对路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; ) func main() { data, err := ioutil.ReadFile(\u0026#34;/home/naveen/go/src/filehandling/test.txt\u0026#34;) if err != nil { fmt.Println(\u0026#34;File reading error\u0026#34;, err) return } fmt.Println(\u0026#34;Contents of file:\u0026#34;, string(data)) } 现在可以在任何位置上运行程序，打印出 test.txt 的内容。\n例如，可以在我的家目录运行。\n1 2 3 $ cd $HOME $ go install filehandling $ workspacepath/bin/filehandling 该程序打印出了 test.txt 的内容。\n看似这是一个简单的方法，但它的缺点是：文件必须放在程序指定的路径中，否则就会出错。\n2. 使用命令行标记来传递文件路径 另一种解决方案是使用命令行标记来传递文件路径。使用 flag 包，我们可以从输入的命令行获取到文件路径，接着读取文件内容。\n首先我们来看看 flag 包是如何工作的。flag 包有一个名为 String 的函数。该函数接收三个参数。第一个参数是标记名，第二个是默认值，第三个是标记的简短描述。\n让我们来编写程序，从命令行读取文件名。将 filehandling.go 的内容替换如下：\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { fptr := flag.String(\u0026#34;fpath\u0026#34;, \u0026#34;test.txt\u0026#34;, \u0026#34;file path to read from\u0026#34;) flag.Parse() fmt.Println(\u0026#34;value of fpath is\u0026#34;, *fptr) } 在上述程序中第 8 行，通过 String 函数，创建了一个字符串标记，名称是 fpath，默认值是 test.txt，描述为 file path to read from。这个函数返回存储 flag 值的字符串变量的地址。\n在程序访问 flag 之前，必须先调用 flag.Parse()。\n在第 10 行，程序会打印出 flag 值。\n使用下面命令运行程序。\n1 wrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt 我们传入 /path-of-file/test.txt，赋值给了 fpath 标记。\n该程序输出：\n1 value of fpath is /path-of-file/test.txt 这是因为 fpath 的默认值是 test.txt。\n现在我们知道如何从命令行读取文件路径了，让我们继续完成我们的文件读取程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; ) func main() { fptr := flag.String(\u0026#34;fpath\u0026#34;, \u0026#34;test.txt\u0026#34;, \u0026#34;file path to read from\u0026#34;) flag.Parse() data, err := ioutil.ReadFile(*fptr) if err != nil { fmt.Println(\u0026#34;File reading error\u0026#34;, err) return } fmt.Println(\u0026#34;Contents of file:\u0026#34;, string(data)) } 在上述程序里，命令行传入文件路径，程序读取了该文件的内容。使用下面命令运行该程序。\n1 wrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt 请将 /path-of-file/ 替换为 test.txt 的真实路径。该程序将打印：\n1 Contents of file: Hello World. Welcome to file handling in Go. 3. 将文件绑定在二进制文件中 虽然从命令行获取文件路径的方法很好，但还有一种更好的解决方法。如果我们能够将文本文件捆绑在二进制文件，岂不是很棒？这就是我们下面要做的事情。\n有很多包可以帮助我们实现。我们会使用 packr，因为它很简单，并且我在项目中使用它时，没有出现任何问题。\n第一步就是安装 packr 包。\n在命令提示符中输入下面命令，安装 packr 包。\n1 go get -u github.com/gobuffalo/packr/... packr 会把静态文件（例如 .txt 文件）转换为 .go 文件，接下来，.go 文件会直接嵌入到二进制文件中。packer 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。\n我们通过程序来更好地理解它。用以下内容来替换 handling.go 文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gobuffalo/packr\u0026#34; ) func main() { box := packr.NewBox(\u0026#34;../filehandling\u0026#34;) data := box.String(\u0026#34;test.txt\u0026#34;) fmt.Println(\u0026#34;Contents of file:\u0026#34;, data) } 在上面程序的第 10 行，我们创建了一个新盒子（New Box）。盒子表示一个文件夹，其内容会嵌入到二进制中。在这里，我指定了 filehandling 文件夹，其内容包含 test.txt。在下一行，我们读取了文件内容，并打印出来。\n在开发阶段时，我们可以使用 go install 命令来运行程序。程序可以正常运行。packr 非常智能，在开发阶段可以从磁盘加载文件。\n使用下面命令来运行程序。\n1 2 go install filehandling workspacepath/bin/filehandling 该命令可以在其他位置运行。packr 很聪明，可以获取传递给 NewBox 命令的目录的绝对路径。\n该程序会输出：\n1 Contents of file: Hello World. Welcome to file handling in Go. 你可以试着改变 test.txt 的内容，然后再运行 filehandling。可以看到，无需再次编译，程序打印出了 test.txt 的更新内容。完美！\n现在我们来看看如何将 test.txt 打包到我们的二进制文件中。我们使用 packr 命令来实现。\n运行下面的命令：\n1 packr install -v filehandling 它会打印：\n1 2 3 4 5 6 7 building box ../filehandling packing file filehandling.go packed file filehandling.go packing file test.txt packed file test.txt built box ../filehandling with [\u0026#34;filehandling.go\u0026#34; \u0026#34;test.txt\u0026#34;] filehandling 该命令将静态文件绑定到了二进制文件中。\n在运行上述命令之后，使用命令 workspacepath/bin/filehandling 来运行程序。程序会打印出 test.txt 的内容。于是从二进制文件中，我们读取了 test.txt 的内容。\n如果你不知道文件到底是由二进制还是磁盘来提供，我建议你删除 test.txt，并在此运行 filehandling 命令。你将看到，程序打印出了 test.txt 的内容。太棒了:D。我们已经成功将静态文件嵌入到了二进制文件中。\n分块读取文件 在前面的章节，我们学习了如何把整个文件读取到内存。当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 bufio 包来完成。\n让我们来编写一个程序，以 3 个字节的块为单位读取 test.txt 文件。如下所示，替换 filehandling.go 的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { fptr := flag.String(\u0026#34;fpath\u0026#34;, \u0026#34;test.txt\u0026#34;, \u0026#34;file path to read from\u0026#34;) flag.Parse() f, err := os.Open(*fptr) if err != nil { log.Fatal(err) } defer func() { if err = f.Close(); err != nil { log.Fatal(err) } }() r := bufio.NewReader(f) b := make([]byte, 3) for { _, err := r.Read(b) if err != nil { fmt.Println(\u0026#34;Error reading file:\u0026#34;, err) break } fmt.Println(string(b)) } } 在上述程序的第 15 行，我们使用命令行标记传递的路径，打开文件。\n在第 19 行，我们延迟了文件的关闭操作。\n在上面程序的第 24 行，我们新建了一个缓冲读取器（buffered reader）。在下一行，我们创建了长度和容量为 3 的字节切片，程序会把文件的字节读取到切片中。\n第 27 行的 Read 方法会读取 len(b) 个字节（达到 3 字节），并返回所读取的字节数。当到达文件最后时，它会返回一个 EOF 错误。程序的其他地方比较简单，不做解释。\n如果我们使用下面命令来运行程序：\n1 2 $ go install filehandling $ wrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt 会得到以下输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Hel lo Wor ld. We lco me to fil e h and lin g i n G o. Error reading file: EOF 逐行读取文件 本节我们讨论如何使用 Go 逐行读取文件。这可以使用 bufio 来实现。\n请将 test.txt 替换为以下内容。\n1 2 3 Hello World. Welcome to file handling in Go. This is the second line of the file. We have reached the end of the file. 逐行读取文件涉及到以下步骤。\n打开文件； 在文件上新建一个 scanner； 扫描文件并且逐行读取。 将 filehandling.go 替换为以下内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { fptr := flag.String(\u0026#34;fpath\u0026#34;, \u0026#34;test.txt\u0026#34;, \u0026#34;file path to read from\u0026#34;) flag.Parse() f, err := os.Open(*fptr) if err != nil { log.Fatal(err) } defer func() { if err = f.Close(); err != nil { log.Fatal(err) } }() s := bufio.NewScanner(f) for s.Scan() { fmt.Println(s.Text()) } err = s.Err() if err != nil { log.Fatal(err) } } 在上述程序的第 15 行，我们用命令行标记传入的路径，打开文件。在第 24 行，我们用文件创建了一个新的 scanner。第 25 行的 Scan() 方法读取文件的下一行，如果可以读取，就可以使用 Text() 方法。\n当 Scan 返回 false 时，除非已经到达文件末尾（此时 Err() 返回 nil），否则 Err() 就会返回扫描过程中出现的错误。\n如果我使用下面命令来运行程序：\n1 2 $ go install filehandling $ workspacepath/bin/filehandling -fpath=/path-of-file/test.txt 程序会输出：\n1 2 3 Hello World. Welcome to file handling in Go. This is the second line of the file. We have reached the end of the file. 本教程到此结束。希望你能喜欢，祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/35-read-file/","tags":["file"],"title":"Go系列教程（三十五） | 读取文件(Read file)"},{"categories":["Go系列教程"],"contents":"反射是 Go 语言的高级主题之一。我会尽可能让它变得简单易懂。\n本教程分为如下小节。\n什么是反射？ 为何需要检查变量，确定变量的类型？ reflect 包 reflect.Type 和 reflect.Value reflect.Kind NumField() 和 Field() 方法 Int() 和 String() 方法 完整的程序 我们应该使用反射吗？ 让我们来逐个讨论这些章节。\n什么是反射？ 反射就是程序能够在运行时检查变量和值，求出它们的类型。你可能还不太懂，这没关系。在本教程结束后，你就会清楚地理解反射，所以跟着我们的教程学习吧。\n为何需要检查变量，确定变量的类型？ 在学习反射时，所有人首先面临的疑惑就是：如果程序中每个变量都是我们自己定义的，那么在编译时就可以知道变量类型了，为什么我们还需要在运行时检查变量，求出它的类型呢？没错，在大多数时候都是这样，但并非总是如此。\n我来解释一下吧。下面我们编写一个简单的程序。\n1 2 3 4 5 6 7 8 9 10 package main import ( \u0026#34;fmt\u0026#34; ) func main() { i := 10 fmt.Printf(\u0026#34;%d %T\u0026#34;, i, i) } 在 playground 上运行\n在上面的程序中，i 的类型在编译时就知道了，然后我们在下一行打印出 i。这里没什么特别之处。\n现在了解一下，需要在运行时求得变量类型的情况。假如我们要编写一个简单的函数，它接收结构体作为参数，并用它来创建一个 SQL 插入查询。\n考虑下面的程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; ) type order struct { ordId int customerId int } func main() { o := order{ ordId: 1234, customerId: 567, } fmt.Println(o) } 在 playground 上运行\n在上面的程序中，我们需要编写一个函数，接收结构体变量 o 作为参数，返回下面的 SQL 插入查询。\n1 insert into order values(1234, 567) 这个函数写起来很简单。我们现在编写这个函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; ) type order struct { ordId int customerId int } func createQuery(o order) string { i := fmt.Sprintf(\u0026#34;insert into order values(%d, %d)\u0026#34;, o.ordId, o.customerId) return i } func main() { o := order{ ordId: 1234, customerId: 567, } fmt.Println(createQuery(o)) } 在 playground 上运行\n在第 12 行，createQuery 函数用 o 的两个字段（ordId 和 customerId），创建了插入查询。该程序会输出：\n1 insert into order values(1234, 567) 现在我们来升级这个查询生成器。如果我们想让它变得通用，可以适用于任何结构体类型，该怎么办呢？我们用程序来理解一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main type order struct { ordId int customerId int } type employee struct { name string id int address string salary int country string } func createQuery(q interface{}) string { } func main() { } 我们的目标就是完成 createQuery 函数（上述程序中的第 16 行），它可以接收任何结构体作为参数，根据结构体的字段创建插入查询。\n例如，如果我们传入下面的结构体：\n1 2 3 4 o := order { ordId: 1234, customerId: 567 } createQuery 函数应该返回：\n1 insert into order values (1234, 567) 类似地，如果我们传入：\n1 2 3 4 5 6 7 e := employee { name: \u0026#34;Naveen\u0026#34;, id: 565, address: \u0026#34;Science Park Road, Singapore\u0026#34;, salary: 90000, country: \u0026#34;Singapore\u0026#34;, } 该函数会返回：\n1 insert into employee values(\u0026#34;Naveen\u0026#34;, 565, \u0026#34;Science Park Road, Singapore\u0026#34;, 90000, \u0026#34;Singapore\u0026#34;) 由于 createQuery 函数应该适用于任何结构体，因此它接收 interface{} 作为参数。为了简单起见，我们只处理包含 string 和 int 类型字段的结构体，但可以扩展为包含任何类型的字段。\ncreateQuery 函数应该适用于所有的结构体。因此，要编写这个函数，就必须在运行时检查传递过来的结构体参数的类型，找到结构体字段，接着创建查询。这时就需要用到反射了。在本教程的下一步，我们将会学习如何使用 reflect 包来实现它。\nreflect 包 在 Go 语言中，reflect 实现了运行时反射。reflect 包会帮助识别 interface{} 变量的底层具体类型和具体值。这正是我们所需要的。createQuery 函数接收 interface{} 参数，根据它的具体类型和具体值，创建 SQL 查询。这正是 reflect 包能够帮助我们的地方。\n在编写我们通用的查询生成器之前，我们首先需要了解 reflect 包中的几种类型和方法。让我们来逐个了解。\nreflect.Type 和 reflect.Value reflect.Type 表示 interface{} 的具体类型，而 reflect.Value 表示它的具体值。reflect.TypeOf() 和 reflect.ValueOf() 两个函数可以分别返回 reflect.Type 和 reflect.Value。这两种类型是我们创建查询生成器的基础。我们现在用一个简单的例子来理解这两种类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type order struct { ordId int customerId int } func createQuery(q interface{}) { t := reflect.TypeOf(q) v := reflect.ValueOf(q) fmt.Println(\u0026#34;Type \u0026#34;, t) fmt.Println(\u0026#34;Value \u0026#34;, v) } func main() { o := order{ ordId: 456, customerId: 56, } createQuery(o) } 在 playground 上运行\n在上面的程序中，第 13 行的 createQuery 函数接收 interface{} 作为参数。在第 14 行，reflect.TypeOf 接收了参数 interface{}，返回了reflect.Type，它包含了传入的 interface{} 参数的具体类型。同样地，在第 15 行，reflect.ValueOf 函数接收参数 interface{}，并返回了 reflect.Value，它包含了传来的 interface{} 的具体值。\n上述程序会打印：\n1 2 Type main.order Value {456 56} 从输出我们可以看到，程序打印了接口的具体类型和具体值。\nreflect.Kind reflect 包中还有一个重要的类型：Kind。\n在反射包中，Kind 和 Type 的类型可能看起来很相似，但在下面程序中，可以很清楚地看出它们的不同之处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type order struct { ordId int customerId int } func createQuery(q interface{}) { t := reflect.TypeOf(q) k := t.Kind() fmt.Println(\u0026#34;Type \u0026#34;, t) fmt.Println(\u0026#34;Kind \u0026#34;, k) } func main() { o := order{ ordId: 456, customerId: 56, } createQuery(o) } 在 playground 上运行\n上述程序会输出：\n1 2 Type main.order Kind struct 我想你应该很清楚两者的区别了。Type 表示 interface{} 的实际类型（在这里是 main.Order)，而 Kind 表示该类型的特定类别（在这里是 struct）。\nNumField() 和 Field() 方法 NumField() 方法返回结构体中字段的数量，而 Field(i int) 方法返回字段 i 的 reflect.Value。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type order struct { ordId int customerId int } func createQuery(q interface{}) { if reflect.ValueOf(q).Kind() == reflect.Struct { v := reflect.ValueOf(q) fmt.Println(\u0026#34;Number of fields\u0026#34;, v.NumField()) for i := 0; i \u0026lt; v.NumField(); i++ { fmt.Printf(\u0026#34;Field:%d type:%T value:%v\\n\u0026#34;, i, v.Field(i), v.Field(i)) } } } func main() { o := order{ ordId: 456, customerId: 56, } createQuery(o) } 在 playground 上运行\n在上面的程序中，因为 NumField 方法只能在结构体上使用，我们在第 14 行首先检查了 q 的类别是 struct。程序的其他代码很容易看懂，不作解释。该程序会输出：\n1 2 3 Number of fields 2 Field:0 type:reflect.Value value:456 Field:1 type:reflect.Value value:56 Int() 和 String() 方法 Int 和 String 可以帮助我们分别取出 reflect.Value 作为 int64 和 string。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 56 x := reflect.ValueOf(a).Int() fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, x, x) b := \u0026#34;Naveen\u0026#34; y := reflect.ValueOf(b).String() fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, y, y) } 在 playground 上运行\n在上面程序中的第 10 行，我们取出 reflect.Value，并转换为 int64，而在第 13 行，我们取出 reflect.Value 并将其转换为 string。该程序会输出：\n1 2 type:int64 value:56 type:string value:Naveen 完整的程序 现在我们已经具备足够多的知识，来完成我们的查询生成器了，我们来实现它把。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type order struct { ordId int customerId int } type employee struct { name string id int address string salary int country string } func createQuery(q interface{}) { if reflect.ValueOf(q).Kind() == reflect.Struct { t := reflect.TypeOf(q).Name() query := fmt.Sprintf(\u0026#34;insert into %s values(\u0026#34;, t) v := reflect.ValueOf(q) for i := 0; i \u0026lt; v.NumField(); i++ { switch v.Field(i).Kind() { case reflect.Int: if i == 0 { query = fmt.Sprintf(\u0026#34;%s%d\u0026#34;, query, v.Field(i).Int()) } else { query = fmt.Sprintf(\u0026#34;%s, %d\u0026#34;, query, v.Field(i).Int()) } case reflect.String: if i == 0 { query = fmt.Sprintf(\u0026#34;%s\\\u0026#34;%s\\\u0026#34;\u0026#34;, query, v.Field(i).String()) } else { query = fmt.Sprintf(\u0026#34;%s, \\\u0026#34;%s\\\u0026#34;\u0026#34;, query, v.Field(i).String()) } default: fmt.Println(\u0026#34;Unsupported type\u0026#34;) return } } query = fmt.Sprintf(\u0026#34;%s)\u0026#34;, query) fmt.Println(query) return } fmt.Println(\u0026#34;unsupported type\u0026#34;) } func main() { o := order{ ordId: 456, customerId: 56, } createQuery(o) e := employee{ name: \u0026#34;Naveen\u0026#34;, id: 565, address: \u0026#34;Coimbatore\u0026#34;, salary: 90000, country: \u0026#34;India\u0026#34;, } createQuery(e) i := 90 createQuery(i) } 在 playground 上运行\n在第 22 行，我们首先检查了传来的参数是否是一个结构体。在第 23 行，我们使用了 Name() 方法，从该结构体的 reflect.Type 获取了结构体的名字。接下来一行，我们用 t 来创建查询。\n在第 28 行，case 语句 检查了当前字段是否为 reflect.Int，如果是的话，我们会取到该字段的值，并使用 Int() 方法转换为 int64。if else 语句用于处理边界情况。请添加日志来理解为什么需要它。在第 34 行，我们用来相同的逻辑来取到 string。\n我们还作了额外的检查，以防止 createQuery 函数传入不支持的类型时，程序发生崩溃。程序的其他代码是自解释性的。我建议你在合适的地方添加日志，检查输出，来更好地理解这个程序。\n该程序会输出：\n1 2 3 insert into order values(456, 56) insert into employee values(\u0026#34;Naveen\u0026#34;, 565, \u0026#34;Coimbatore\u0026#34;, 90000, \u0026#34;India\u0026#34;) unsupported type 至于向输出的查询中添加字段名，我们把它留给读者作为练习。请尝试着修改程序，打印出以下格式的查询。\n1 insert into order(ordId, customerId) values(456, 56) 我们应该使用反射吗？ 我们已经展示了反射的实际应用，现在考虑一个很现实的问题。我们应该使用反射吗？我想引用 Rob Pike 关于使用反射的格言，来回答这个问题。\n清晰优于聪明。而反射并不是一目了然的。\n反射是 Go 语言中非常强大和高级的概念，我们应该小心谨慎地使用它。使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它，只在必须用到它时，才使用反射。\n本教程到此结束。希望你们喜欢。祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/34-reflection/","tags":["Reflection"],"title":"Go系列教程（三十四） | 反射(Reflection)"},{"categories":["Go系列教程"],"contents":"什么是头等（第一类）函数？ 支持头等函数（First Class Function）的编程语言，可以把函数赋值给变量，也可以把函数作为其它函数的参数或者返回值。Go 语言支持头等函数的机制。\n本教程我们会讨论头等函数的语法和用例。\n匿名函数 我们来编写一个简单的示例，把函数赋值给一个变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;fmt\u0026#34; ) func main() { a := func() { fmt.Println(\u0026#34;hello world first class function\u0026#34;) } a() fmt.Printf(\u0026#34;%T\u0026#34;, a) } 在 playground 上运行\n在上面的程序中，我们将一个函数赋值给了变量 a（第 8 行）。这是把函数赋值给变量的语法。你如果观察得仔细的话，会发现赋值给 a 的函数没有名称。由于没有名称，这类函数称为匿名函数（Anonymous Function）。\n调用该函数的唯一方法就是使用变量 a。我们在下一行调用了它。a() 调用了这个函数，打印出 hello world first class function。在第 12 行，我们打印出 a 的类型。这会输出 func()。\n运行该程序，会输出：\n1 2 hello world first class function func() 要调用一个匿名函数，可以不用赋值给变量。通过下面的例子，我们看看这是怎么做到的。\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; ) func main() { func() { fmt.Println(\u0026#34;hello world first class function\u0026#34;) }() } 在 playground 上运行\n在上面的程序中，第 8 行定义了一个匿名函数，并在定义之后，我们使用 () 立即调用了该函数（第 10 行）。该程序会输出：\n1 hello world first class function 就像其它函数一样，还可以向匿名函数传递参数。\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; ) func main() { func(n string) { fmt.Println(\u0026#34;Welcome\u0026#34;, n) }(\u0026#34;Gophers\u0026#34;) } 在 playground 上运行\n在上面的程序中，我们向匿名函数传递了一个字符串参数（第 10 行）。运行该程序后会输出：\n1 Welcome Gophers 用户自定义的函数类型 正如我们定义自己的结构体类型一样，我们可以定义自己的函数类型。\n1 type add func(a int, b int) int 以上代码片段创建了一个新的函数类型 add，它接收两个整型参数，并返回一个整型。现在我们来定义 add 类型的变量。\n我们来编写一个程序，定义一个 add 类型的变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; ) type add func(a int, b int) int func main() { var a add = func(a int, b int) int { return a + b } s := a(5, 6) fmt.Println(\u0026#34;Sum\u0026#34;, s) } 在 playground 上运行\n在上面程序的第 10 行，我们定义了一个 add 类型的变量 a，并向它赋值了一个符合 add 类型签名的函数。我们在第 13 行调用了该函数，并将结果赋值给 s。该程序会输出：\n1 Sum 11 高阶函数 wiki 把高阶函数（Hiher-order Function）定义为：满足下列条件之一的函数：\n接收一个或多个函数作为参数 返回值是一个函数 针对上述两种情况，我们看看一些简单实例。\n把函数作为参数，传递给其它函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; ) func simple(a func(a, b int) int) { fmt.Println(a(60, 7)) } func main() { f := func(a, b int) int { return a + b } simple(f) } 在 playground 上运行\n在上面的实例中，第 7 行我们定义了一个函数 simple，simple 接收一个函数参数（该函数接收两个 int 参数，返回一个 a 整型）。在 main 函数的第 12 行，我们创建了一个匿名函数 f，其签名符合 simple 函数的参数。我们在下一行调用了 simple，并传递了参数 f。该程序打印输出 67。\n在其它函数中返回函数 现在我们重写上面的代码，在 simple 函数中返回一个函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; ) func simple() func(a, b int) int { f := func(a, b int) int { return a + b } return f } func main() { s := simple() fmt.Println(s(60, 7)) } 在 playground 上运行\n在上面程序中，第 7 行的 simple 函数返回了一个函数，并接受两个 int 参数，返回一个 int。\n在第 15 行，我们调用了 simple 函数。我们把 simple 的返回值赋值给了 s。现在 s 包含了 simple 函数返回的函数。我们调用了 s，并向它传递了两个 int 参数（第 16 行）。该程序输出 67。\n闭包 闭包（Closure）是匿名函数的一个特例。当一个匿名函数所访问的变量定义在函数体的外部时，就称这样的匿名函数为闭包。\n看看一个示例就明白了。\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; ) func main() { a := 5 func() { fmt.Println(\u0026#34;a =\u0026#34;, a) }() } 在 playground 上运行\n在上面的程序中，匿名函数在第 10 行访问了变量 a，而 a 存在于函数体的外部。因此这个匿名函数就是闭包。\n每一个闭包都会绑定一个它自己的外围变量（Surrounding Variable）。我们通过一个简单示例来体会这句话的含义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func appendStr() func(string) string { t := \u0026#34;Hello\u0026#34; c := func(b string) string { t = t + \u0026#34; \u0026#34; + b return t } return c } func main() { a := appendStr() b := appendStr() fmt.Println(a(\u0026#34;World\u0026#34;)) fmt.Println(b(\u0026#34;Everyone\u0026#34;)) fmt.Println(a(\u0026#34;Gopher\u0026#34;)) fmt.Println(b(\u0026#34;!\u0026#34;)) } 在 playground 上运行\n在上面程序中，函数 appendStr 返回了一个闭包。这个闭包绑定了变量 t。我们来理解这是什么意思。\n在第 17 行和第 18 行声明的变量 a 和 b 都是闭包，它们绑定了各自的 t 值。\n我们首先用参数 World 调用了 a。现在 a 中 t 值变为了 Hello World。\n在第 20 行，我们又用参数 Everyone 调用了 b。由于 b 绑定了自己的变量 t，因此 b 中的 t 还是等于初始值 Hello。于是该函数调用之后，b 中的 t 变为了 Hello Everyone。程序的其他部分很简单，不再解释。\n该程序会输出：\n1 2 3 4 Hello World Hello Everyone Hello World Gopher Hello Everyone ! 头等函数的实际用途 迄今为止，我们已经定义了什么是头等函数，也看了一些专门设计的示例，来学习它们如何工作。现在我们来编写一些实际的程序，来展现头等函数的实际用处。\n我们会创建一个程序，基于一些条件，来过滤一个 students 切片。现在我们来逐步实现它。\n首先定义一个 student 类型。\n1 2 3 4 5 6 type student struct { firstName string lastName string grade string country string } 下一步是编写一个 filter 函数。该函数接收一个 students 切片和一个函数作为参数，这个函数会计算一个学生是否满足筛选条件。写出这个函数后，你很快就会明白，我们继续吧。\n1 2 3 4 5 6 7 8 9 func filter(s []student, f func(student) bool) []student { var r []student for _, v := range s { if f(v) == true { r = append(r, v) } } return r } 在上面的函数中，filter 的第二个参数是一个函数。这个函数接收 student 参数，返回一个 bool 值。这个函数计算了某一学生是否满足筛选条件。我们在第 3 行遍历了 student 切片，将每个学生作为参数传递给了函数 f。如果该函数返回 true，就表示该学生通过了筛选条件，接着将该学生添加到了结果切片 r 中。你可能会很困惑这个函数的实际用途，等我们完成程序你就知道了。我添加了 main 函数，整个程序如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package main import ( \u0026#34;fmt\u0026#34; ) type student struct { firstName string lastName string grade string country string } func filter(s []student, f func(student) bool) []student { var r []student for _, v := range s { if f(v) == true { r = append(r, v) } } return r } func main() { s1 := student{ firstName: \u0026#34;Naveen\u0026#34;, lastName: \u0026#34;Ramanathan\u0026#34;, grade: \u0026#34;A\u0026#34;, country: \u0026#34;India\u0026#34;, } s2 := student{ firstName: \u0026#34;Samuel\u0026#34;, lastName: \u0026#34;Johnson\u0026#34;, grade: \u0026#34;B\u0026#34;, country: \u0026#34;USA\u0026#34;, } s := []student{s1, s2} f := filter(s, func(s student) bool { if s.grade == \u0026#34;B\u0026#34; { return true } return false }) fmt.Println(f) } 在 playground 上运行\n在 main 函数中，我们首先创建了两个学生 s1 和 s2，并将他们添加到了切片 s。现在假设我们想要查询所有成绩为 B 的学生。为了实现这样的功能，我们传递了一个检查学生成绩是否为 B 的函数，如果是，该函数会返回 true。我们把这个函数作为参数传递给了 filter 函数（第 38 行）。上述程序会输出：\n1 [{Samuel Johnson B USA}] 假设我们想要查找所有来自印度的学生。通过修改传递给 filter 的函数参数，就很容易地实现了。\n实现它的代码如下所示：\n1 2 3 4 5 6 7 c := filter(s, func(s student) bool { if s.country == \u0026#34;India\u0026#34; { return true } return false }) fmt.Println(c) 请将该函数添加到 main 函数，并检查它的输出。\n我们最后再编写一个程序，来结束这一节的讨论。这个程序会对切片的每个元素执行相同的操作，并返回结果。例如，如果我们希望将切片中的所有整数乘以 5，并返回出结果，那么通过头等函数可以很轻松地实现。我们把这种对集合中的每个元素进行操作的函数称为 map 函数。相关代码如下所示，它们很容易看懂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; ) func iMap(s []int, f func(int) int) []int { var r []int for _, v := range s { r = append(r, f(v)) } return r } func main() { a := []int{5, 6, 7, 8, 9} r := iMap(a, func(n int) int { return n * 5 }) fmt.Println(r) } 在 playground 上运行\n该程序会输出：\n1 [25 30 35 40 45] 现在简单概括一下本教程讨论的内容：\n什么是头等函数？ 匿名函数 用户自定义的函数类型 高阶函数 把函数作为参数，传递给其它函数 在其它函数中返回函数 闭包 头等函数的实际用途 本教程到此结束。祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/33-functions-are-first-class-citizens/","tags":["functions"],"title":"Go系列教程（三十三） | 函数是一等公民(Functions Are First Class Citizens)"},{"categories":["Go系列教程"],"contents":"什么是 panic？ 在 Go 语言中，程序中一般是使用错误来处理异常情况。对于程序中出现的大部分异常情况，错误就已经够用了。\n但在有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 panic 来终止程序。当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪（Stack Trace），最后程序终止。在编写一个示例程序后，我们就能很好地理解这个概念了。\n在本教程里，我们还会接着讨论，当程序发生 panic 时，使用 recover 可以重新获得对该程序的控制。\n可以认为 panic 和 recover 与其他语言中的 try-catch-finally 语句类似，只不过一般我们很少使用 panic 和 recover。而当我们使用了 panic 和 recover 时，也会比 try-catch-finally 更加优雅，代码更加整洁。\n什么时候应该使用 panic？ 需要注意的是，你应该尽可能地使用错误，而不是使用 panic 和 recover。只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制。\npanic 有两个合理的用例。\n发生了一个不能恢复的错误，此时程序不能继续运行。 一个例子就是 web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 panic，因为如果不能绑定端口，啥也做不了。 发生了一个编程上的错误。 假如我们有一个接收指针参数的方法，而其他人使用 nil 作为参数调用了它。在这种情况下，我们可以使用 panic，因为这是一个编程错误：用 nil 参数调用了一个只能接收合法指针的方法。 panic 示例 内建函数 panic 的签名如下所示：\n1 func panic(interface{}) 当程序终止时，会打印传入 panic 的参数。我们写一个示例，你就会清楚它的用途了。我们现在就开始吧。\n我们会写一个例子，来展示 panic 如何工作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; ) func fullName(firstName *string, lastName *string) { if firstName == nil { panic(\u0026#34;runtime error: first name cannot be nil\u0026#34;) } if lastName == nil { panic(\u0026#34;runtime error: last name cannot be nil\u0026#34;) } fmt.Printf(\u0026#34;%s %s\\n\u0026#34;, *firstName, *lastName) fmt.Println(\u0026#34;returned normally from fullName\u0026#34;) } func main() { firstName := \u0026#34;Elon\u0026#34; fullName(\u0026amp;firstName, nil) fmt.Println(\u0026#34;returned normally from main\u0026#34;) } 在 playground 上运行\n上面的程序很简单，会打印一个人的全名。第 7 行的 fullName 函数会打印出一个人的全名。该函数在第 8 行和第 11 行分别检查了 firstName 和 lastName 的指针是否为 nil。如果是 nil，fullName 函数会调用含有不同的错误信息的 panic。当程序终止时，会打印出该错误信息。\n运行该程序，会有如下输出：\n1 2 3 4 5 6 7 panic: runtime error: last name cannot be nil goroutine 1 [running]: main.fullName(0x1040c128, 0x0) /tmp/sandbox135038844/main.go:12 +0x120 main.main() /tmp/sandbox135038844/main.go:20 +0x80 我们来分析这个输出，理解一下 panic 是如何工作的，并且思考当程序发生 panic 时，会怎样打印堆栈跟踪。\n在第 19 行，我们将 Elon 赋值给了 firstName。在第 20 行，我们调用了 fullName 函数，其中 lastName 等于 nil。因此，满足了第 11 行的条件，程序发生 panic。当出现了 panic 时，程序就会终止运行，打印出传入 panic 的参数，接着打印出堆栈跟踪。因此，第 14 行和第 15 行的代码并不会在发生 panic 之后执行。程序首先会打印出传入 panic 函数的信息：\n1 panic: runtime error: last name cannot be empty 接着打印出堆栈跟踪。\n程序在 fullName 函数的第 12 行发生 panic，因此，首先会打印出如下所示的输出。\n1 2 main.fullName(0x1040c128, 0x0) /tmp/sandbox135038844/main.go:12 +0x120 接着会打印出堆栈的下一项。在本例中，堆栈跟踪中的下一项是第 20 行（因为发生 panic 的 fullName 调用就在这一行），因此接下来会打印出：\n1 2 main.main() /tmp/sandbox135038844/main.go:20 +0x80 现在我们已经到达了导致 panic 的顶层函数，这里没有更多的层级，因此结束打印。\n发生 panic 时的 defer 我们重新总结一下 panic 做了什么。当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪，最后程序终止。\n在上面的例子中，我们没有延迟调用任何函数。如果有延迟函数，会先调用它，然后程序控制返回到函数调用方。\n我们来修改上面的示例，使用一个延迟语句。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func fullName(firstName *string, lastName *string) { defer fmt.Println(\u0026#34;deferred call in fullName\u0026#34;) if firstName == nil { panic(\u0026#34;runtime error: first name cannot be nil\u0026#34;) } if lastName == nil { panic(\u0026#34;runtime error: last name cannot be nil\u0026#34;) } fmt.Printf(\u0026#34;%s %s\\n\u0026#34;, *firstName, *lastName) fmt.Println(\u0026#34;returned normally from fullName\u0026#34;) } func main() { defer fmt.Println(\u0026#34;deferred call in main\u0026#34;) firstName := \u0026#34;Elon\u0026#34; fullName(\u0026amp;firstName, nil) fmt.Println(\u0026#34;returned normally from main\u0026#34;) } 在 playground 上运行\n上述代码中，我们只修改了两处，分别在第 8 行和第 20 行添加了延迟函数的调用。\n该函数会打印：\n1 2 3 4 5 6 7 8 9 10 11 This program prints, deferred call in fullName deferred call in main panic: runtime error: last name cannot be nil goroutine 1 [running]: main.fullName(0x1042bf90, 0x0) /tmp/sandbox060731990/main.go:13 +0x280 main.main() /tmp/sandbox060731990/main.go:22 +0xc0 当程序在第 13 行发生 panic 时，首先执行了延迟函数，接着控制返回到函数调用方，调用方的延迟函数继续运行，直到到达顶层调用函数。\n在我们的例子中，首先执行 fullName 函数中的 defer 语句（第 8 行）。程序打印出：\n1 deferred call in fullName 接着程序返回到 main 函数，执行了 main 函数的延迟调用，因此会输出：\n1 deferred call in main 现在程序控制到达了顶层函数，因此该函数会打印出 panic 信息，然后是堆栈跟踪，最后终止程序。\nrecover recover 是一个内建函数，用于重新获得 panic 协程的控制。\nrecover 函数的标签如下所示：\n1 func recover() interface{} 只有在延迟函数的内部，调用 recover 才有用。在延迟函数内调用 recover，可以取到 panic 的错误信息，并且停止 panic 续发事件（Panicking Sequence），程序运行恢复正常。如果在延迟函数的外部调用 recover，就不能停止 panic 续发事件。\n我们来修改一下程序，在发生 panic 之后，使用 recover 来恢复正常的运行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;fmt\u0026#34; ) func recoverName() { if r := recover(); r!= nil { fmt.Println(\u0026#34;recovered from \u0026#34;, r) } } func fullName(firstName *string, lastName *string) { defer recoverName() if firstName == nil { panic(\u0026#34;runtime error: first name cannot be nil\u0026#34;) } if lastName == nil { panic(\u0026#34;runtime error: last name cannot be nil\u0026#34;) } fmt.Printf(\u0026#34;%s %s\\n\u0026#34;, *firstName, *lastName) fmt.Println(\u0026#34;returned normally from fullName\u0026#34;) } func main() { defer fmt.Println(\u0026#34;deferred call in main\u0026#34;) firstName := \u0026#34;Elon\u0026#34; fullName(\u0026amp;firstName, nil) fmt.Println(\u0026#34;returned normally from main\u0026#34;) } 在 playground 上运行\n在第 7 行，recoverName() 函数调用了 recover()，返回了调用 panic 的传参。在这里，我们只是打印出 recover 的返回值（第 8 行）。在 fullName 函数内，我们在第 14 行延迟调用了 recoverNames()。\n当 fullName 发生 panic 时，会调用延迟函数 recoverName()，它使用了 recover() 来停止 panic 续发事件。\n该程序会输出：\n1 2 3 recovered from runtime error: last name cannot be nil returned normally from main deferred call in main 当程序在第 19 行发生 panic 时，会调用延迟函数 recoverName，它反过来会调用 recover() 来重新获得 panic 协程的控制。第 8 行调用了 recover，返回了 panic 的传参，因此会打印：\n1 recovered from runtime error: last name cannot be nil 在执行完 recover() 之后，panic 会停止，程序控制返回到调用方（在这里就是 main 函数），程序在发生 panic 之后，从第 29 行开始会继续正常地运行。程序会打印 returned normally from main，之后是 deferred call in main。\npanic，recover 和 Go 协程 只有在相同的 Go 协程中调用 recover 才管用。recover 不能恢复一个不同协程的 panic。我们用一个例子来理解这一点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func recovery() { if r := recover(); r != nil { fmt.Println(\u0026#34;recovered:\u0026#34;, r) } } func a() { defer recovery() fmt.Println(\u0026#34;Inside A\u0026#34;) go b() time.Sleep(1 * time.Second) } func b() { fmt.Println(\u0026#34;Inside B\u0026#34;) panic(\u0026#34;oh! B panicked\u0026#34;) } func main() { a() fmt.Println(\u0026#34;normally returned from main\u0026#34;) } 在 playground 上运行\n在上面的程序中，函数 b() 在第 23 行发生 panic。函数 a() 调用了一个延迟函数 recovery()，用于恢复 panic。在第 17 行，函数 b() 作为一个不同的协程来调用。下一行的 Sleep 只是保证 a() 在 b() 运行结束之后才退出。\n你认为程序会输出什么？panic 能够恢复吗？答案是否定的，panic 并不会恢复。因为调用 recovery 的协程和 b() 中发生 panic 的协程并不相同，因此不可能恢复 panic。\n运行该程序会输出：\n1 2 3 4 5 6 7 8 9 Inside A Inside B panic: oh! B panicked goroutine 5 [running]: main.b() /tmp/sandbox388039916/main.go:23 +0x80 created by main.a /tmp/sandbox388039916/main.go:17 +0xc0 从输出可以看出，panic 没有恢复。\n如果函数 b() 在相同的协程里调用，panic 就可以恢复。\n如果程序的第 17 行由 go b() 修改为 b()，就可以恢复 panic 了，因为 panic 发生在与 recover 相同的协程里。如果运行这个修改后的程序，会输出：\n1 2 3 4 Inside A Inside B recovered: oh! B panicked normally returned from main 运行时 panic 运行时错误（如数组越界）也会导致 panic。这等价于调用了内置函数 panic，其参数由接口类型 runtime.Error 给出。runtime.Error 接口的定义如下：\n1 2 3 4 5 6 7 8 type Error interface { error // RuntimeError is a no-op function but // serves to distinguish types that are run time // errors from ordinary errors: a type is a // run time error if it has a RuntimeError method. RuntimeError() } 而 runtime.Error 接口满足内建接口类型 error。\n我们来编写一个示例，创建一个运行时 panic。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; ) func a() { n := []int{5, 7, 4} fmt.Println(n[3]) fmt.Println(\u0026#34;normally returned from a\u0026#34;) } func main() { a() fmt.Println(\u0026#34;normally returned from main\u0026#34;) } 在 playground 上运行\n在上面的程序中，第 9 行我们试图访问 n[3]，这是一个对切片的错误引用。该程序会发生 panic，输出如下：\n1 2 3 4 5 6 7 panic: runtime error: index out of range goroutine 1 [running]: main.a() /tmp/sandbox780439659/main.go:9 +0x40 main.main() /tmp/sandbox780439659/main.go:13 +0x20 你也许想知道，是否可以恢复一个运行时 panic？当然可以！我们来修改一下上面的代码，恢复这个 panic。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; ) func r() { if r := recover(); r != nil { fmt.Println(\u0026#34;Recovered\u0026#34;, r) } } func a() { defer r() n := []int{5, 7, 4} fmt.Println(n[3]) fmt.Println(\u0026#34;normally returned from a\u0026#34;) } func main() { a() fmt.Println(\u0026#34;normally returned from main\u0026#34;) } 在 playground 上运行\n运行上面程序会输出：\n1 2 Recovered runtime error: index out of range normally returned from main 从输出可以知道，我们已经恢复了这个 panic。\n恢复后获得堆栈跟踪 当我们恢复 panic 时，我们就释放了它的堆栈跟踪。实际上，在上述程序里，恢复 panic 之后，我们就失去了堆栈跟踪。\n有办法可以打印出堆栈跟踪，就是使用 Debug 包中的 PrintStack 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime/debug\u0026#34; ) func r() { if r := recover(); r != nil { fmt.Println(\u0026#34;Recovered\u0026#34;, r) debug.PrintStack() } } func a() { defer r() n := []int{5, 7, 4} fmt.Println(n[3]) fmt.Println(\u0026#34;normally returned from a\u0026#34;) } func main() { a() fmt.Println(\u0026#34;normally returned from main\u0026#34;) } 在 playground 上运行\n在上面的程序中，我们在第 11 行使用了 debug.PrintStack() 打印堆栈跟踪。\n该程序会输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Recovered runtime error: index out of range goroutine 1 [running]: runtime/debug.Stack(0x1042beb8, 0x2, 0x2, 0x1c) /usr/local/go/src/runtime/debug/stack.go:24 +0xc0 runtime/debug.PrintStack() /usr/local/go/src/runtime/debug/stack.go:16 +0x20 main.r() /tmp/sandbox949178097/main.go:11 +0xe0 panic(0xf0a80, 0x17cd50) /usr/local/go/src/runtime/panic.go:491 +0x2c0 main.a() /tmp/sandbox949178097/main.go:18 +0x80 main.main() /tmp/sandbox949178097/main.go:23 +0x20 normally returned from main 从输出我们可以看出，首先已经恢复了 panic，打印出 Recovered runtime error: index out of range。此外，我们也打印出了堆栈跟踪。在恢复了 panic 之后，还打印出 normally returned from main。\n本教程到此结束。\n简单概括一下本教程讨论的内容：\n什么是 panic？ 什么时候应该使用 panic？ panic 示例 发生 panic 时的 defer recover panic，recover 和 Go 协程 运行时 panic 恢复后获得堆栈跟踪 祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/32-panic-and-recover.md/","tags":["panic","recover"],"title":"Go系列教程（三十二） | panic 和 recover(Panic and Recover)"},{"categories":["Go系列教程"],"contents":"在上一教程里，我们学习了 Go 中的错误是如何表示的，并学习了如何处理标准库里的错误。我们还学习了从标准库的错误中提取更多的信息。\n在本教程中，我们会学习如何创建我们自己的自定义错误，并在我们创建的函数和包中使用它。我们会使用与标准库中相同的技术，来提供自定义错误的更多细节信息。\n使用 New 函数创建自定义错误 创建自定义错误最简单的方法是使用 errors 包中的 New 函数。\n在使用 New 函数 创建自定义错误之前，我们先来看看 New 是如何实现的。如下所示，是 errors 包 中的 New 函数的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Package errors implements functions to manipulate errors. package errors // New returns an error that formats as the given text. func New(text string) error { return \u0026amp;errorString{text} } // errorString is a trivial implementation of error. type errorString struct { s string } func (e *errorString) Error() string { return e.s } New 函数的实现很简单。errorString 是一个结构体类型，只有一个字符串字段 s。第 14 行使用了 errorString 指针接受者（Pointer Receiver），来实现 error 接口的 Error() string 方法。\n第 5 行的 New 函数有一个字符串参数，通过这个参数创建了 errorString 类型的变量，并返回了它的地址。于是它就创建并返回了一个新的错误。\n现在我们已经知道了 New 函数是如何工作的，我们开始在程序里使用 New 来创建自定义错误吧。\n我们将创建一个计算圆半径的简单程序，如果半径为负，它会返回一个错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func circleArea(radius float64) (float64, error) { if radius \u0026lt; 0 { return 0, errors.New(\u0026#34;Area calculation failed, radius is less than zero\u0026#34;) } return math.Pi * radius * radius, nil } func main() { radius := -20.0 area, err := circleArea(radius) if err != nil { fmt.Println(err) return } fmt.Printf(\u0026#34;Area of circle %0.2f\u0026#34;, area) } 在 glayground 上运行\n在上面的程序中，我们检查半径是否小于零（第 10 行）。如果半径小于零，我们会返回等于 0 的面积，以及相应的错误信息。如果半径大于零，则会计算出面积，并返回值为 nil 的错误（第 13 行）。\n在 main 函数里，我们在第 19 行检查错误是否等于 nil。如果不是 nil，我们会打印出错误并返回，否则我们会打印出圆的面积。\n在我们的程序中，半径小于零，因此打印出：\n1 Area calculation failed, radius is less than zero 使用 Errorf 给错误添加更多信息 上面的程序效果不错，但是如果我们能够打印出当前圆的半径，那就更好了。这就要用到 fmt 包中的 Errorf 函数了。Errorf 函数会根据格式说明符，规定错误的格式，并返回一个符合该错误的字符串。\n接下来我们使用 Errorf 函数来改进我们的程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func circleArea(radius float64) (float64, error) { if radius \u0026lt; 0 { return 0, fmt.Errorf(\u0026#34;Area calculation failed, radius %0.2f is less than zero\u0026#34;, radius) } return math.Pi * radius * radius, nil } func main() { radius := -20.0 area, err := circleArea(radius) if err != nil { fmt.Println(err) return } fmt.Printf(\u0026#34;Area of circle %0.2f\u0026#34;, area) } 在 playground 上运行\n在上面的程序中，我们使用 Errorf（第 10 行）打印了发生错误的半径。程序运行后会输出：\n1 Area calculation failed, radius -20.00 is less than zero 使用结构体类型和字段提供错误的更多信息 错误还可以用实现了 error 接口的结构体来表示。这种方式可以更加灵活地处理错误。在上面例子中，如果我们希望访问引发错误的半径，现在唯一的方法就是解析错误的描述信息 Area calculation failed, radius -20.00 is less than zero。这样做不太好，因为一旦描述信息发生变化，程序就会出错。\n我们会使用标准库里采用的方法，在上一教程中“断言底层结构体类型，使用结构体字段获取更多信息”这一节，我们讲解了这一方法，可以使用结构体字段来访问引发错误的半径。我们会创建一个实现 error 接口的结构体类型，并使用它的字段来提供关于错误的更多信息。\n第一步就是创建一个表示错误的结构体类型。错误类型的命名约定是名称以 Error 结尾。因此我们不妨把结构体类型命名为 areaError。\n1 2 3 4 type areaError struct { err string radius float64 } 上面的结构体类型有一个 radius 字段，它存储了与错误有关的半径，而 err 字段存储了实际的错误信息。\n下一步是实现 error 接口。\n1 2 3 func (e *areaError) Error() string { return fmt.Sprintf(\u0026#34;radius %0.2f: %s\u0026#34;, e.radius, e.err) } 在上面的代码中，我们使用指针接收者 *areaError，实现了 error 接口的 Error() string 方法。该方法打印出半径和关于错误的描述。\n现在我们来编写 main 函数和 circleArea 函数来完成整个程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type areaError struct { err string radius float64 } func (e *areaError) Error() string { return fmt.Sprintf(\u0026#34;radius %0.2f: %s\u0026#34;, e.radius, e.err) } func circleArea(radius float64) (float64, error) { if radius \u0026lt; 0 { return 0, \u0026amp;areaError{\u0026#34;radius is negative\u0026#34;, radius} } return math.Pi * radius * radius, nil } func main() { radius := -20.0 area, err := circleArea(radius) if err != nil { if err, ok := err.(*areaError); ok { fmt.Printf(\u0026#34;Radius %0.2f is less than zero\u0026#34;, err.radius) return } fmt.Println(err) return } fmt.Printf(\u0026#34;Area of rectangle1 %0.2f\u0026#34;, area) } 在 playground 上运行\n在上面的程序中，circleArea（第 17 行）用于计算圆的面积。该函数首先检查半径是否小于零，如果小于零，它会通过错误半径和对应错误信息，创建一个 areaError 类型的值，然后返回 areaError 值的地址，与此同时 area 等于 0（第 19 行）。于是我们提供了更多的错误信息（即导致错误的半径），我们使用了自定义错误的结构体字段来定义它。\n如果半径是非负数，该函数会在第 21 行计算并返回面积，同时错误值为 nil。\n在 main 函数的 26 行，我们试图计算半径为 -20 的圆的面积。由于半径小于零，因此会导致一个错误。\n我们在第 27 行检查了错误是否为 nil，并在下一行断言了 *areaError 类型。如果错误是 *areaError 类型，我们就可以用 err.radius 来获取错误的半径（第 29 行），打印出自定义错误的消息，最后程序返回退出。\n如果断言错误，我们就在第 32 行打印该错误，并返回。如果没有发生错误，在第 35 行会打印出面积。\n该程序会输出：\n1 Radius -20.00 is less than zero 下面我们来使用上一教程提到的第二种方法，使用自定义错误类型的方法来提供错误的更多信息。\n使用结构体类型的方法来提供错误的更多信息 在本节里，我们会编写一个计算矩形面积的程序。如果长或宽小于零，程序就会打印出错误。\n第一步就是创建一个表示错误的结构体。\n1 2 3 4 5 type areaError struct { err string //error description length float64 //length which caused the error width float64 //width which caused the error } 上面的结构体类型除了有一个错误描述字段，还有可能引发错误的宽和高。\n现在我们有了错误类型，我们来实现 error 接口，并给该错误类型添加两个方法，使它提供了更多的错误信息。\n1 2 3 4 5 6 7 8 9 10 11 func (e *areaError) Error() string { return e.err } func (e *areaError) lengthNegative() bool { return e.length \u0026lt; 0 } func (e *areaError) widthNegative() bool { return e.width \u0026lt; 0 } 在上面的代码片段中，我们从 Error() string 方法中返回了关于错误的描述。当 length 小于零时，lengthNegative() bool 方法返回 true，而当 width 小于零时，widthNegative() bool 方法返回 true。这两个方法都提供了关于错误的更多信息，在这里，它提示我们计算面积失败的原因（长度为负数或者宽度为负数）。于是我们就有了两个错误类型结构体的方法，来提供更多的错误信息。\n下一步就是编写计算面积的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func rectArea(length, width float64) (float64, error) { err := \u0026#34;\u0026#34; if length \u0026lt; 0 { err += \u0026#34;length is less than zero\u0026#34; } if width \u0026lt; 0 { if err == \u0026#34;\u0026#34; { err = \u0026#34;width is less than zero\u0026#34; } else { err += \u0026#34;, width is less than zero\u0026#34; } } if err != \u0026#34;\u0026#34; { return 0, \u0026amp;areaError{err, length, width} } return length * width, nil } 上面的 rectArea 函数检查了长或宽是否小于零，如果小于零，rectArea 会返回一个错误信息，否则 rectArea 会返回矩形的面积和一个值为 nil 的错误。\n让我们创建 main 函数来完成整个程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { length, width := -5.0, -9.0 area, err := rectArea(length, width) if err != nil { if err, ok := err.(*areaError); ok { if err.lengthNegative() { fmt.Printf(\u0026#34;error: length %0.2f is less than zero\\n\u0026#34;, err.length) } if err.widthNegative() { fmt.Printf(\u0026#34;error: width %0.2f is less than zero\\n\u0026#34;, err.width) } return } fmt.Println(err) return } fmt.Println(\u0026#34;area of rect\u0026#34;, area) } 在 main 程序中，我们检查了错误是否为 nil（第 4 行）。如果错误值不是 nil，我们会在下一行断言 *areaError 类型。然后，我们使用 lengthNegative() 和 widthNegative() 方法，检查错误的原因是长度小于零还是宽度小于零。这样我们就使用了错误结构体类型的方法，来提供更多的错误信息。\n如果没有错误发生，就会打印矩形的面积。\n下面是整个程序的代码供你参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package main import \u0026#34;fmt\u0026#34; type areaError struct { err string //error description length float64 //length which caused the error width float64 //width which caused the error } func (e *areaError) Error() string { return e.err } func (e *areaError) lengthNegative() bool { return e.length \u0026lt; 0 } func (e *areaError) widthNegative() bool { return e.width \u0026lt; 0 } func rectArea(length, width float64) (float64, error) { err := \u0026#34;\u0026#34; if length \u0026lt; 0 { err += \u0026#34;length is less than zero\u0026#34; } if width \u0026lt; 0 { if err == \u0026#34;\u0026#34; { err = \u0026#34;width is less than zero\u0026#34; } else { err += \u0026#34;, width is less than zero\u0026#34; } } if err != \u0026#34;\u0026#34; { return 0, \u0026amp;areaError{err, length, width} } return length * width, nil } func main() { length, width := -5.0, -9.0 area, err := rectArea(length, width) if err != nil { if err, ok := err.(*areaError); ok { if err.lengthNegative() { fmt.Printf(\u0026#34;error: length %0.2f is less than zero\\n\u0026#34;, err.length) } if err.widthNegative() { fmt.Printf(\u0026#34;error: width %0.2f is less than zero\\n\u0026#34;, err.width) } return } fmt.Println(err) return } fmt.Println(\u0026#34;area of rect\u0026#34;, area) } 在 playground 上运行\n该程序会打印输出：\n1 2 error: length -5.00 is less than zero error: width -9.00 is less than zero 在上一教程错误处理中，我们介绍了三种提供更多错误信息的方法，现在我们已经看了其中两个示例。\n第三种方法使用的是直接比较，比较简单。我留给读者作为练习，你们可以试着使用这种方法来给出自定义错误的更多信息。\n本教程到此结束。\n简单概括一下本教程讨论的内容：\n使用 New 函数创建自定义错误 使用 Error 添加更多错误信息 使用结构体类型和字段，提供更多错误信息 使用结构体类型和方法，提供更多错误信息 祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/31-custom-error/","tags":["error"],"title":"Go系列教程（三十一） | 自定义错误(Custom Error)"},{"categories":["Go系列教程"],"contents":"什么是错误？ 错误表示程序中出现了异常情况。比如当我们试图打开一个文件时，文件系统里却并没有这个文件。这就是异常情况，它用一个错误来表示。\n在 Go 中，错误一直是很常见的。错误用内建的 error 类型来表示。\n就像其他的内建类型（如 int、float64 等），错误值可以存储在变量里、作为函数的返回值等等。\n示例 现在我们开始编写一个示例，该程序试图打开一个并不存在的文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { f, err := os.Open(\u0026#34;/test.txt\u0026#34;) if err != nil { fmt.Println(err) return } fmt.Println(f.Name(), \u0026#34;opened successfully\u0026#34;) } 在 playground 中运行\n在程序的第 9 行，我们试图打开路径为 /test.txt 的文件（playground 显然并不存在这个文件）。os 包里的 Open 函数有如下签名：\n1 func Open(name string) (file *File, err error) 如果成功打开文件，Open 函数会返回一个文件句柄（File Handler）和一个值为 nil 的错误。而如果打开文件时发生了错误，会返回一个不等于 nil 的错误。\n如果一个函数 或方法 返回了错误，按照惯例，错误会作为最后一个值返回。于是 Open 函数也是将 err 作为最后一个返回值。\n按照 Go 的惯例，在处理错误时，通常都是将返回的错误与 nil 比较。nil 值表示了没有错误发生，而非 nil 值表示出现了错误。在这里，我们第 10 行检查了错误值是否为 nil。如果不是 nil，我们会简单地打印出错误，并在 main 函数中返回。\n运行该程序会输出：\n1 open /test.txt: No such file or directory 很棒！我们得到了一个错误，它指出该文件并不存在。\n错误类型的表示 让我们进一步深入，理解 error 类型是如何定义的。error 是一个接口类型，定义如下：\n1 2 3 type error interface { Error() string } error 有了一个签名为 Error() string 的方法。所有实现该接口的类型都可以当作一个错误类型。Error() 方法给出了错误的描述。\nfmt.Println 在打印错误时，会在内部调用 Error() string 方法来得到该错误的描述。上一节示例中的第 11 行，就是这样打印出错误的描述的。\n从错误获取更多信息的不同方法 现在，我们知道了 error 是一个接口类型，让我们看看如何从一个错误获取更多信息。\n在前面的示例里，我们只是打印出错误的描述。如果我们想知道这个错误的文件路径，该怎么做呢？一种选择是直接解析错误的字符串。这是前面示例的输出：\n1 open /test.txt: No such file or directory 我们解析了这条错误信息，虽然获取了发生错误的文件路径，但是这种方法很不优雅。随着语言版本的更新，这条错误的描述随时都有可能变化，使我们程序出错。\n有没有更加可靠的方法来获取文件名呢？答案是肯定的，这是可以做到的，Go 标准库给出了各种提取错误相关信息的方法。我们一个个来看看吧。\n1. 断言底层结构体类型，使用结构体字段获取更多信息 如果你仔细阅读了 Open 函数的文档，你可以看见它返回的错误类型是 *PathError。PathError 是结构体类型，它在标准库中的实现如下：\n1 2 3 4 5 6 7 type PathError struct { Op string Path string Err error } func (e *PathError) Error() string { return e.Op + \u0026#34; \u0026#34; + e.Path + \u0026#34;: \u0026#34; + e.Err.Error() } 如果你有兴趣了解上述源代码出现的位置，可以在这里找到：https://golang.org/src/os/error.go?s=653:716#L11。\n通过上面的代码，你就知道了 *PathError 通过声明 Error() string 方法，实现了 error 接口。Error() string 将文件操作、路径和实际错误拼接，并返回该字符串。于是我们得到该错误信息：\n1 open /test.txt: No such file or directory 结构体 PathError 的 Path 字段，就有导致错误的文件路径。我们修改前面写的程序，打印出该路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { f, err := os.Open(\u0026#34;/test.txt\u0026#34;) if err, ok := err.(*os.PathError); ok { fmt.Println(\u0026#34;File at path\u0026#34;, err.Path, \u0026#34;failed to open\u0026#34;) return } fmt.Println(f.Name(), \u0026#34;opened successfully\u0026#34;) } 在 playground 上运行\n在上面的程序里，我们在第 10 行使用了类型断言（Type Assertion）来获取 error 接口的底层值（Underlying Value）。接下来在第 11 行，我们使用 err.Path 来打印该路径。该程序会输出：\n1 File at path /test.txt failed to open 很棒！我们已经使用类型断言成功获取到了该错误的文件路径。\n2. 断言底层结构体类型，调用方法获取更多信息 第二种获取更多错误信息的方法，也是对底层类型进行断言，然后通过调用该结构体类型的方法，来获取更多的信息。\n我们通过一个实例来理解这一点。\n标准库中的 DNSError 结构体类型定义如下：\n1 type DNSError struct { ...}func (e *DNSError) Error() string { ...}func (e *DNSError) Timeout() bool { ... }func (e *DNSError) Temporary() bool { ... } 从上述代码可以看到，DNSError 结构体还有 Timeout() bool 和 Temporary() bool 两个方法，它们返回一个布尔值，指出该错误是由超时引起的，还是临时性错误。\n接下来我们编写一个程序，断言 *DNSError 类型，并调用这些方法来确定该错误是临时性错误，还是由超时导致的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { addr, err := net.LookupHost(\u0026#34;golangbot123.com\u0026#34;) if err, ok := err.(*net.DNSError); ok { if err.Timeout() { fmt.Println(\u0026#34;operation timed out\u0026#34;) } else if err.Temporary() { fmt.Println(\u0026#34;temporary error\u0026#34;) } else { fmt.Println(\u0026#34;generic error: \u0026#34;, err) } return } fmt.Println(addr) } 注：在 playground 无法进行 DNS 解析。请在你的本地运行该程序。\n在上述程序中，我们在第 9 行，试图获取 golangbot123.com（无效的域名） 的 ip。在第 10 行，我们通过 *net.DNSError 的类型断言，获取到了错误的底层值。接下来的第 11 行和第 13 行，我们分别检查了该错误是由超时引起的，还是一个临时性错误。\n在本例中，我们的错误既不是临时性错误，也不是由超时引起的，因此该程序输出：\n1 generic error: lookup golangbot123.com: no such host 如果该错误是临时性错误，或是由超时引发的，那么对应的 if 语句会执行，于是我们就可以适当地处理它们。\n3. 直接比较 第三种获取错误的更多信息的方式，是与 error 类型的变量直接比较。我们通过一个示例来理解。\nfilepath 包中的 Glob 用于返回满足 glob 模式的所有文件名。如果模式写的不对，该函数会返回一个错误 ErrBadPattern。\nfilepath 包中的 ErrBadPattern 定义如下：\n1 var ErrBadPattern = errors.New(\u0026#34;syntax error in pattern\u0026#34;) errors.New() 用于创建一个新的错误。我们会在下一教程中详细讨论它。\n当模式不正确时，Glob 函数会返回 ErrBadPattern。\n我们来写一个小程序来看看这个错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { files, error := filepath.Glob(\u0026#34;[\u0026#34;) if error != nil \u0026amp;\u0026amp; error == filepath.ErrBadPattern { fmt.Println(error) return } fmt.Println(\u0026#34;matched files\u0026#34;, files) } 在 playground 上运行\n在上述程序里，我们查询了模式为 [ 的文件，然而这个模式写的不正确。我们检查了该错误是否为 nil。为了获取该错误的更多信息，我们在第 10 行将 error 直接与 filepath.ErrBadPattern 相比较。如果该条件满足，那么该错误就是由模式错误导致的。该程序会输出：\n1 syntax error in pattern 标准库在提供错误的详细信息时，使用到了上述提到的三种方法。在下一教程里，我们会通过这些方法来创建我们自己的自定义错误。\n不可忽略错误 绝不要忽略错误。忽视错误会带来问题。接下来我重写上面的示例，在列出所有满足模式的文件名时，我省略了错误处理的代码。\n1 2 3 4 5 6 7 8 9 10 11 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { files, _ := filepath.Glob(\u0026#34;[\u0026#34;) fmt.Println(\u0026#34;matched files\u0026#34;, files) } 在 playground 上运行\n我们已经从前面的示例知道了这个模式是错误的。在第 9 行，通过使用 _ 空白标识符，我忽略了 Glob 函数返回的错误。我在第 10 行简单打印了所有匹配的文件。该程序会输出：\n1 matched files [] 由于我忽略了错误，输出看起来就像是没有任何匹配了 glob 模式的文件，但实际上这是因为模式的写法不对。所以绝不要忽略错误。\n本教程到此结束。\n这一教程我们讨论了该如何处理程序中出现的错误，也讨论了如何查询关于错误的更多信息。简单概括一下本教程讨论的内容：\n什么是错误？ 错误的表示 获取错误详细信息的各种方法 不能忽视错误 在下一教程，我们会创建我们自己的自定义错误，并给标准错误增加更多的语境（Context）。\n祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/30-error-handle.md/","tags":["error"],"title":"Go系列教程（三十） | 错误处理(Error Handle)"},{"categories":["Go系列教程"],"contents":"什么是 defer？ defer 语句的用途是：含有 defer 语句的函数，会在该函数将要返回之前，调用另一个函数。这个定义可能看起来很复杂，我们通过一个示例就很容易明白了。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; ) func finished() { fmt.Println(\u0026#34;Finished finding largest\u0026#34;) } func largest(nums []int) { defer finished() fmt.Println(\u0026#34;Started finding largest\u0026#34;) max := nums[0] for _, v := range nums { if v \u0026gt; max { max = v } } fmt.Println(\u0026#34;Largest number in\u0026#34;, nums, \u0026#34;is\u0026#34;, max) } func main() { nums := []int{78, 109, 2, 563, 300} largest(nums) } 在 playground 上运行\n上面的程序很简单，就是找出一个给定切片的最大值。largest 函数接收一个 int 类型的切片作为参数，然后打印出该切片中的最大值。largest 函数的第一行的语句为 defer finished()。这表示在 finished() 函数将要返回之前，会调用 finished() 函数。运行该程序，你会看到有如下输出：\n1 2 3 Started finding largest Largest number in [78 109 2 563 300] is 563 Finished finding largest largest 函数开始执行后，会打印上面的两行输出。而就在 largest 将要返回的时候，又调用了我们的延迟函数（Deferred Function），打印出 Finished finding largest 的文本。\n延迟方法 defer 不仅限于函数的调用，调用方法也是合法的。我们写一个小程序来测试吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) type person struct { firstName string lastName string } func (p person) fullName() { fmt.Printf(\u0026#34;%s %s\u0026#34;,p.firstName,p.lastName) } func main() { p := person { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Smith\u0026#34;, } defer p.fullName() fmt.Printf(\u0026#34;Welcome \u0026#34;) } 在 playground 上运行\n在上面的例子中，我们在第 22 行延迟了一个方法调用。而其他的代码很直观，这里不再解释。该程序输出：\n1 Welcome John Smith 实参取值（Arguments Evaluation） 在 Go 语言中，并非在调用延迟函数的时候才确定实参，而是当执行 defer 语句的时候，就会对延迟函数的实参进行求值。\n通过一个例子就能够理解了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; ) func printA(a int) { fmt.Println(\u0026#34;value of a in deferred function\u0026#34;, a) } func main() { a := 5 defer printA(a) a = 10 fmt.Println(\u0026#34;value of a before deferred function call\u0026#34;, a) } 在 playground 上运行\n在上面的程序里的第 11 行，a 的初始值为 5。在第 12 行执行 defer 语句的时候，由于 a 等于 5，因此延迟函数 printA 的实参也等于 5。接着我们在第 13 行将 a 的值修改为 10。下一行会打印出 a 的值。该程序输出：\n1 2 value of a before deferred function call 10 value of a in deferred function 5 从上面的输出，我们可以看出，在调用了 defer 语句后，虽然我们将 a 修改为 10，但调用延迟函数 printA(a)后，仍然打印的是 5。\ndefer 栈 当一个函数内多次调用 defer 时，Go 会把 defer 调用放入到一个栈中，随后按照后进先出（Last In First Out, LIFO）的顺序执行。\n我们下面编写一个小程序，使用 defer 栈，将一个字符串逆序打印。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; ) func main() { name := \u0026#34;Naveen\u0026#34; fmt.Printf(\u0026#34;Orignal String: %s\\n\u0026#34;, string(name)) fmt.Printf(\u0026#34;Reversed String: \u0026#34;) for _, v := range []rune(name) { defer fmt.Printf(\u0026#34;%c\u0026#34;, v) } } 在 playground 上运行\n在上述程序中的第 11 行，for range 循环会遍历一个字符串，并在第 12 行调用了 defer fmt.Printf(\u0026quot;%c\u0026quot;, v)。这些延迟调用会添加到一个栈中，按照后进先出的顺序执行，因此，该字符串会逆序打印出来。该程序会输出：\n1 2 Orignal String: Naveen Reversed String: neevaN defer 的实际应用 目前为止，我们看到的代码示例，都没有体现出 defer 的实际用途。本节我们会看看 defer 的实际应用。\n当一个函数应该在与当前代码流（Code Flow）无关的环境下调用时，可以使用 defer。我们通过一个用到了 WaitGroup 代码示例来理解这句话的含义。我们首先会写一个没有使用 defer 的程序，然后我们会用 defer 来修改，看到 defer 带来的好处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type rect struct { length int width int } func (r rect) area(wg *sync.WaitGroup) { if r.length \u0026lt; 0 { fmt.Printf(\u0026#34;rect %v\u0026#39;s length should be greater than zero\\n\u0026#34;, r) wg.Done() return } if r.width \u0026lt; 0 { fmt.Printf(\u0026#34;rect %v\u0026#39;s width should be greater than zero\\n\u0026#34;, r) wg.Done() return } area := r.length * r.width fmt.Printf(\u0026#34;rect %v\u0026#39;s area %d\\n\u0026#34;, r, area) wg.Done() } func main() { var wg sync.WaitGroup r1 := rect{-67, 89} r2 := rect{5, -67} r3 := rect{8, 9} rects := []rect{r1, r2, r3} for _, v := range rects { wg.Add(1) go v.area(\u0026amp;wg) } wg.Wait() fmt.Println(\u0026#34;All go routines finished executing\u0026#34;) } 在 playground 上运行\n在上面的程序里，我们在第 8 行创建了 rect 结构体，并在第 13 行创建了 rect 的方法 area，计算出矩形的面积。area 检查了矩形的长宽是否小于零。如果矩形的长宽小于零，它会打印出对应的提示信息，而如果大于零，它会打印出矩形的面积。\nmain 函数创建了 3 个 rect 类型的变量：r1、r2 和 r3。在第 34 行，我们把这 3 个变量添加到了 rects 切片里。该切片接着使用 for range 循环遍历，把 area 方法作为一个并发的 Go 协程进行调用（第 37 行）。我们用 WaitGroup wg 来确保 main 函数在其他协程执行完毕之后，才会结束执行。WaitGroup 作为参数传递给 area 方法后，在第 16 行、第 21 行和第 26 行通知 main 函数，表示现在协程已经完成所有任务。如果你仔细观察，会发现 wg.Done() 只在 area 函数返回的时候才会调用。wg.Done() 应该在 area 将要返回之前调用，并且与代码流的路径（Path）无关，因此我们可以只调用一次 defer，来有效地替换掉 wg.Done() 的多次调用。\n我们来用 defer 来重写上面的代码。\n在下面的代码中，我们移除了原先程序中的 3 个 wg.Done 的调用，而是用一个单独的 defer wg.Done() 来取代它（第 14 行）。这使得我们的代码更加简洁易懂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) type rect struct { length int width int } func (r rect) area(wg *sync.WaitGroup) { defer wg.Done() if r.length \u0026lt; 0 { fmt.Printf(\u0026#34;rect %v\u0026#39;s length should be greater than zero\\n\u0026#34;, r) return } if r.width \u0026lt; 0 { fmt.Printf(\u0026#34;rect %v\u0026#39;s width should be greater than zero\\n\u0026#34;, r) return } area := r.length * r.width fmt.Printf(\u0026#34;rect %v\u0026#39;s area %d\\n\u0026#34;, r, area) } func main() { var wg sync.WaitGroup r1 := rect{-67, 89} r2 := rect{5, -67} r3 := rect{8, 9} rects := []rect{r1, r2, r3} for _, v := range rects { wg.Add(1) go v.area(\u0026amp;wg) } wg.Wait() fmt.Println(\u0026#34;All go routines finished executing\u0026#34;) } 在 playground 上运行\n该程序会输出：\n1 2 3 4 rect {8 9}\u0026#39;s area 72 rect {-67 89}\u0026#39;s length should be greater than zero rect {5 -67}\u0026#39;s width should be greater than zero All go routines finished executing 在上面的程序中，使用 defer 还有一个好处。假设我们使用 if 条件语句，又给 area 方法添加了一条返回路径（Return Path）。如果没有使用 defer 来调用 wg.Done()，我们就得很小心了，确保在这条新添的返回路径里调用了 wg.Done()。由于现在我们延迟调用了 wg.Done()，因此无需再为这条新的返回路径添加 wg.Done() 了。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/29-defer/","tags":["defer"],"title":"Go系列教程（二十九） | 延迟调用(Defer) "},{"categories":["Go系列教程"],"contents":"Go 通过接口来实现多态。我们已经讨论过，在 Go 语言中，我们是隐式地实现接口。一个类型如果定义了接口所声明的全部方法，那它就实现了该接口。现在我们来看看，利用接口，Go 是如何实现多态的。\n使用接口实现多态 一个类型如果定义了接口的所有方法，那它就隐式地实现了该接口。\n所有实现了接口的类型，都可以把它的值保存在一个接口类型的变量中。在 Go 中，我们使用接口的这种特性来实现多态。\n通过一个程序我们来理解 Go 语言的多态，它会计算一个组织机构的净收益。为了简单起见，我们假设这个虚构的组织所获得的收入来源于两个项目：fixed billing 和 time and material。该组织的净收益等于这两个项目的收入总和。同样为了简单起见，我们假设货币单位是美元，而无需处理美分。因此货币只需简单地用 int 来表示。（我建议阅读 https://forum.golangbridge.org/t/what-is-the-proper-golang-equivalent-to-decimal-when-dealing-with-money/413 上的文章，学习如何表示美分。感谢 Andreas Matuschek 在评论区指出这一点。）\n我们首先定义一个接口 Income。\n1 2 3 4 type Income interface { calculate() int source() string } 上面定义了接口 Interface，它包含了两个方法：calculate() 计算并返回项目的收入，而 source() 返回项目名称。\n下面我们定义一个表示 FixedBilling 项目的结构体类型。\n1 2 3 4 type FixedBilling struct { projectName string biddedAmount int } 项目 FixedBillin 有两个字段：projectName 表示项目名称，而 biddedAmount 表示组织向该项目投标的金额。\nTimeAndMaterial 结构体用于表示项目 Time and Material。\n1 2 3 4 5 type TimeAndMaterial struct { projectName string noOfHours int hourlyRate int } 结构体 TimeAndMaterial 拥有三个字段名：projectName、noOfHours 和 hourlyRate。\n下一步我们给这些结构体类型定义方法，计算并返回实际收入和项目名称。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func (fb FixedBilling) calculate() int { return fb.biddedAmount } func (fb FixedBilling) source() string { return fb.projectName } func (tm TimeAndMaterial) calculate() int { return tm.noOfHours * tm.hourlyRate } func (tm TimeAndMaterial) source() string { return tm.projectName } 在项目 FixedBilling 里面，收入就是项目的投标金额。因此我们返回 FixedBilling 类型的 calculate() 方法。\n而在项目 TimeAndMaterial 里面，收入等于 noOfHours 和 hourlyRate 的乘积，作为 TimeAndMaterial 类型的 calculate() 方法的返回值。\n我们还通过 source() 方法返回了表示收入来源的项目名称。\n由于 FixedBilling 和 TimeAndMaterial 两个结构体都定义了 Income 接口的两个方法：calculate() 和 source()，因此这两个结构体都实现了 Income 接口。\n我们来声明一个 calculateNetIncome 函数，用来计算并打印总收入。\n1 2 3 4 5 6 7 8 func calculateNetIncome(ic []Income) { var netincome int = 0 for _, income := range ic { fmt.Printf(\u0026#34;Income From %s = $%d\\n\u0026#34;, income.source(), income.calculate()) netincome += income.calculate() } fmt.Printf(\u0026#34;Net income of organisation = $%d\u0026#34;, netincome) } 上面的函数接收一个 Income 接口类型的切片作为参数。该函数会遍历这个接口切片，并依个调用 calculate() 方法，计算出总收入。该函数同样也会通过调用 source() 显示收入来源。根据 Income 接口的具体类型，程序会调用不同的 calculate() 和 source() 方法。于是，我们在 calculateNetIncome 函数中就实现了多态。\n如果在该组织以后增加了新的收入来源，calculateNetIncome 无需修改一行代码，就可以正确地计算总收入了。\n最后就剩下这个程序的 main 函数了。\n1 2 3 4 5 6 7 func main() { project1 := FixedBilling{projectName: \u0026#34;Project 1\u0026#34;, biddedAmount: 5000} project2 := FixedBilling{projectName: \u0026#34;Project 2\u0026#34;, biddedAmount: 10000} project3 := TimeAndMaterial{projectName: \u0026#34;Project 3\u0026#34;, noOfHours: 160, hourlyRate: 25} incomeStreams := []Income{project1, project2, project3} calculateNetIncome(incomeStreams) } 在上面的 main 函数中，我们创建了三个项目，有两个是 FixedBilling 类型，一个是 TimeAndMaterial 类型。接着我们创建了一个 Income 类型的切片，存放了这三个项目。由于这三个项目都实现了 Interface 接口，因此可以把这三个项目放入 Income 切片。最后我们将该切片作为参数，调用了 calculateNetIncome 函数，显示了项目不同的收益和收入来源。\n以下完整的代码供你参考。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package main import ( \u0026#34;fmt\u0026#34; ) type Income interface { calculate() int source() string } type FixedBilling struct { projectName string biddedAmount int } type TimeAndMaterial struct { projectName string noOfHours int hourlyRate int } func (fb FixedBilling) calculate() int { return fb.biddedAmount } func (fb FixedBilling) source() string { return fb.projectName } func (tm TimeAndMaterial) calculate() int { return tm.noOfHours * tm.hourlyRate } func (tm TimeAndMaterial) source() string { return tm.projectName } func calculateNetIncome(ic []Income) { var netincome int = 0 for _, income := range ic { fmt.Printf(\u0026#34;Income From %s = $%d\\n\u0026#34;, income.source(), income.calculate()) netincome += income.calculate() } fmt.Printf(\u0026#34;Net income of organisation = $%d\u0026#34;, netincome) } func main() { project1 := FixedBilling{projectName: \u0026#34;Project 1\u0026#34;, biddedAmount: 5000} project2 := FixedBilling{projectName: \u0026#34;Project 2\u0026#34;, biddedAmount: 10000} project3 := TimeAndMaterial{projectName: \u0026#34;Project 3\u0026#34;, noOfHours: 160, hourlyRate: 25} incomeStreams := []Income{project1, project2, project3} calculateNetIncome(incomeStreams) } 该程序会输出：\n1 2 3 4 Income From Project 1 = $5000 Income From Project 2 = $10000 Income From Project 3 = $4000 Net income of organisation = $19000 新增收益流 假设前面的组织通过广告业务，建立了一个新的收益流（Income Stream）。我们可以看到添加它非常简单，并且计算总收益也很容易，我们无需对 calculateNetIncome 函数进行任何修改。这就是多态的好处。\n我们首先定义 Advertisement 类型，并在 Advertisement 类型中定义 calculate() 和 source() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Advertisement struct { adName string CPC int noOfClicks int } func (a Advertisement) calculate() int { return a.CPC * a.noOfClicks } func (a Advertisement) source() string { return a.adName } Advertisement 类型有三个字段，分别是 adName、CPC（每次点击成本）和 noOfClicks（点击次数）。广告的总收益等于 CPC 和 noOfClicks 的乘积。\n现在我们稍微修改一下 main 函数，把新的收益流添加进来。\n1 2 3 4 5 6 7 8 9 func main() { project1 := FixedBilling{projectName: \u0026#34;Project 1\u0026#34;, biddedAmount: 5000} project2 := FixedBilling{projectName: \u0026#34;Project 2\u0026#34;, biddedAmount: 10000} project3 := TimeAndMaterial{projectName: \u0026#34;Project 3\u0026#34;, noOfHours: 160, hourlyRate: 25} bannerAd := Advertisement{adName: \u0026#34;Banner Ad\u0026#34;, CPC: 2, noOfClicks: 500} popupAd := Advertisement{adName: \u0026#34;Popup Ad\u0026#34;, CPC: 5, noOfClicks: 750} incomeStreams := []Income{project1, project2, project3, bannerAd, popupAd} calculateNetIncome(incomeStreams) } 我们创建了两个广告项目，即 bannerAd 和 popupAd。incomeStream 切片包含了这两个创建的广告项目。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package main import ( \u0026#34;fmt\u0026#34; ) type Income interface { calculate() int source() string } type FixedBilling struct { projectName string biddedAmount int } type TimeAndMaterial struct { projectName string noOfHours int hourlyRate int } type Advertisement struct { adName string CPC int noOfClicks int } func (fb FixedBilling) calculate() int { return fb.biddedAmount } func (fb FixedBilling) source() string { return fb.projectName } func (tm TimeAndMaterial) calculate() int { return tm.noOfHours * tm.hourlyRate } func (tm TimeAndMaterial) source() string { return tm.projectName } func (a Advertisement) calculate() int { return a.CPC * a.noOfClicks } func (a Advertisement) source() string { return a.adName } func calculateNetIncome(ic []Income) { var netincome int = 0 for _, income := range ic { fmt.Printf(\u0026#34;Income From %s = $%d\\n\u0026#34;, income.source(), income.calculate()) netincome += income.calculate() } fmt.Printf(\u0026#34;Net income of organisation = $%d\u0026#34;, netincome) } func main() { project1 := FixedBilling{projectName: \u0026#34;Project 1\u0026#34;, biddedAmount: 5000} project2 := FixedBilling{projectName: \u0026#34;Project 2\u0026#34;, biddedAmount: 10000} project3 := TimeAndMaterial{projectName: \u0026#34;Project 3\u0026#34;, noOfHours: 160, hourlyRate: 25} bannerAd := Advertisement{adName: \u0026#34;Banner Ad\u0026#34;, CPC: 2, noOfClicks: 500} popupAd := Advertisement{adName: \u0026#34;Popup Ad\u0026#34;, CPC: 5, noOfClicks: 750} incomeStreams := []Income{project1, project2, project3, bannerAd, popupAd} calculateNetIncome(incomeStreams) } 上面程序会输出：\n1 2 3 4 5 6 Income From Project 1 = $5000 Income From Project 2 = $10000 Income From Project 3 = $4000 Income From Banner Ad = $1000 Income From Popup Ad = $3750 Net income of organisation = $23750 你会发现，尽管我们新增了收益流，但却完全没有修改 calculateNetIncome 函数。这就是多态带来的好处。由于新的 Advertisement 同样实现了 Income 接口，所以我们能够向 incomeStreams 切片添加 Advertisement。calculateNetIncome 无需修改，因为它能够调用 Advertisement 类型的 calculate() 和 source() 方法。\n本教程到此结束。祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/28-polymorphism/","tags":["struct"],"title":"Go系列教程（二十八） | 多态(Polymorphism)"},{"categories":["Go系列教程"],"contents":"Go 不支持继承，但它支持组合（Composition）。组合一般定义为“合并在一起”。汽车就是一个关于组合的例子：一辆汽车由车轮、引擎和其他各种部件组合在一起。\n通过嵌套结构体进行组合 在 Go 中，通过在结构体内嵌套结构体，可以实现组合。\n组合的典型例子就是博客帖子。每一个博客的帖子都有标题、内容和作者信息。使用组合可以很好地表示它们。通过学习本教程后面的内容，我们会知道如何实现组合。\n我们首先创建一个 author 结构体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; ) type author struct { firstName string lastName string bio string } func (a author) fullName() string { return fmt.Sprintf(\u0026#34;%s %s\u0026#34;, a.firstName, a.lastName) } 在上面的代码片段中，我们创建了一个 author 结构体，author 的字段有 firstname、lastname 和 bio。我们还添加了一个 fullName() 方法，其中 author 作为接收者类型，该方法返回了作者的全名。\n下一步我们创建 post 结构体。\n1 2 3 4 5 6 7 8 9 10 11 12 type post struct { title string content string author } func (p post) details() { fmt.Println(\u0026#34;Title: \u0026#34;, p.title) fmt.Println(\u0026#34;Content: \u0026#34;, p.content) fmt.Println(\u0026#34;Author: \u0026#34;, p.author.fullName()) fmt.Println(\u0026#34;Bio: \u0026#34;, p.author.bio) } post 结构体的字段有 title 和 content。它还有一个嵌套的匿名字段 author。该字段指定 author 组成了 post 结构体。现在 post 可以访问 author 结构体的所有字段和方法。我们同样给 post 结构体添加了 details() 方法，用于打印标题、内容和作者的全名与简介。\n一旦结构体内嵌套了一个结构体字段，Go 可以使我们访问其嵌套的字段，好像这些字段属于外部结构体一样。所以上面第 11 行的 p.author.fullName() 可以替换为 p.fullName()。于是，details() 方法可以重写，如下所示：\n1 2 3 4 5 6 func (p post) details() { fmt.Println(\u0026#34;Title: \u0026#34;, p.title) fmt.Println(\u0026#34;Content: \u0026#34;, p.content) fmt.Println(\u0026#34;Author: \u0026#34;, p.fullName()) fmt.Println(\u0026#34;Bio: \u0026#34;, p.bio) } 现在，我们的 author 和 post 结构体都已准备就绪，我们来创建一个博客帖子来完成这个程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import ( \u0026#34;fmt\u0026#34; ) type author struct { firstName string lastName string bio string } func (a author) fullName() string { return fmt.Sprintf(\u0026#34;%s %s\u0026#34;, a.firstName, a.lastName) } type post struct { title string content string author } func (p post) details() { fmt.Println(\u0026#34;Title: \u0026#34;, p.title) fmt.Println(\u0026#34;Content: \u0026#34;, p.content) fmt.Println(\u0026#34;Author: \u0026#34;, p.fullName()) fmt.Println(\u0026#34;Bio: \u0026#34;, p.bio) } func main() { author1 := author{ \u0026#34;Naveen\u0026#34;, \u0026#34;Ramanathan\u0026#34;, \u0026#34;Golang Enthusiast\u0026#34;, } post1 := post{ \u0026#34;Inheritance in Go\u0026#34;, \u0026#34;Go supports composition instead of inheritance\u0026#34;, author1, } post1.details() } 在上面程序中，main 函数在第 31 行新建了一个 author 结构体变量。而在第 36 行，我们通过嵌套 author1 来创建一个 post。该程序输出：\n1 2 3 4 Title: Inheritance in Go Content: Go supports composition instead of inheritance Author: Naveen Ramanathan Bio: Golang Enthusiast 结构体切片的嵌套 我们可以进一步处理这个示例，使用博客帖子的切片来创建一个网站。😄\n我们首先定义 website 结构体。请在上述代码里的 main 函数中，添加下面的代码，并运行它。\n1 2 3 4 5 6 7 8 9 10 type website struct { []post } func (w website) contents() { fmt.Println(\u0026#34;Contents of Website\\n\u0026#34;) for _, v := range w.posts { v.details() fmt.Println() } } 在你添加上述代码后，当你运行程序时，编译器将会报错，如下所示：\n1 main.go:31:9: syntax error: unexpected [, expecting field name or embedded type 这项错误指出了嵌套的结构体切片 []post。错误的原因是结构体不能嵌套一个匿名切片。我们需要一个字段名。所以我们来修复这个错误，让编译器顺利通过。\n1 2 3 type website struct { posts []post } 可以看到，我给帖子的切片 []post 添加了字段名 posts。\n现在我们来修改主函数，为我们的新网站创建一些帖子吧。\n修改后的完整代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package main import ( \u0026#34;fmt\u0026#34; ) type author struct { firstName string lastName string bio string } func (a author) fullName() string { return fmt.Sprintf(\u0026#34;%s %s\u0026#34;, a.firstName, a.lastName) } type post struct { title string content string author } func (p post) details() { fmt.Println(\u0026#34;Title: \u0026#34;, p.title) fmt.Println(\u0026#34;Content: \u0026#34;, p.content) fmt.Println(\u0026#34;Author: \u0026#34;, p.fullName()) fmt.Println(\u0026#34;Bio: \u0026#34;, p.bio) } type website struct { posts []post } func (w website) contents() { fmt.Println(\u0026#34;Contents of Website\\n\u0026#34;) for _, v := range w.posts { v.details() fmt.Println() } } func main() { author1 := author{ \u0026#34;Naveen\u0026#34;, \u0026#34;Ramanathan\u0026#34;, \u0026#34;Golang Enthusiast\u0026#34;, } post1 := post{ \u0026#34;Inheritance in Go\u0026#34;, \u0026#34;Go supports composition instead of inheritance\u0026#34;, author1, } post2 := post{ \u0026#34;Struct instead of Classes in Go\u0026#34;, \u0026#34;Go does not support classes but methods can be added to structs\u0026#34;, author1, } post3 := post{ \u0026#34;Concurrency\u0026#34;, \u0026#34;Go is a concurrent language and not a parallel one\u0026#34;, author1, } w := website{ posts: []post{post1, post2, post3}, } w.contents() } 在上面的主函数中，我们创建了一个作者 author1，以及三个帖子 post1、post2 和 post3。我们最后通过嵌套三个帖子，在第 62 行创建了网站 w，并在下一行显示内容。\n程序会输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Contents of Website Title: Inheritance in Go Content: Go supports composition instead of inheritance Author: Naveen Ramanathan Bio: Golang Enthusiast Title: Struct instead of Classes in Go Content: Go does not support classes but methods can be added to structs Author: Naveen Ramanathan Bio: Golang Enthusiast Title: Concurrency Content: Go is a concurrent language and not a parallel one Author: Naveen Ramanathan Bio: Golang Enthusiast 本教程到此结束。祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/27-combination-replaces-inheritance/","tags":["status"],"title":"Go系列教程（二十七） | 组合替代继承(Combination Replaces Inheritance)"},{"categories":["Go系列教程"],"contents":"Go 支持面向对象吗？ Go 并不是完全面向对象的编程语言。Go 官网的 FAQ 回答了 Go 是否是面向对象语言，摘录如下。\n可以说是，也可以说不是。虽然 Go 有类型和方法，支持面向对象的编程风格，但却没有类型的层次结构。Go 中的“接口”概念提供了一种不同的方法，我们认为它易于使用，也更为普遍。Go 也可以将结构体嵌套使用，这与子类化（Subclassing）类似，但并不完全相同。此外，Go 提供的特性比 C++ 或 Java 更为通用：子类可以由任何类型的数据来定义，甚至是内建类型（如简单的“未装箱的”整型）。这在结构体（类）中没有受到限制。\n在接下来的教程里，我们会讨论如何使用 Go 来实现面向对象编程概念。与其它面向对象语言（如 Java）相比，Go 有很多完全不同的特性。\n使用结构体，而非类 Go 不支持类，而是提供了结构体。结构体中可以添加方法。这样可以将数据和操作数据的方法绑定在一起，实现与类相似的效果。\n为了加深理解，我们来编写一个示例吧。\n在示例中，我们创建一个自定义包，它帮助我们更好地理解，结构体是如何有效地取代类的。\n在你的 Go 工作区创建一个名为 oop 的文件夹。在 opp 中再创建子文件夹 employee。在 employee 内，创建一个名为 employee.go 的文件。\n文件夹结构会是这样：\n1 workspacepath -\u0026gt; oop -\u0026gt; employee -\u0026gt; employee.go 请将 employee.go 里的内容替换为如下所示的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package employee import ( \u0026#34;fmt\u0026#34; ) type Employee struct { FirstName string LastName string TotalLeaves int LeavesTaken int } func (e Employee) LeavesRemaining() { fmt.Printf(\u0026#34;%s %s has %d leaves remaining\u0026#34;, e.FirstName, e.LastName, (e.TotalLeaves - e.LeavesTaken)) } 在上述程序里，第 1 行指定了该文件属于 employee 包。而第 7 行声明了一个 Employee 结构体。在第 14 行，结构体 Employee 添加了一个名为 LeavesRemaining 的方法。该方法会计算和显示员工的剩余休假数。于是现在我们有了一个结构体，并绑定了结构体的方法，这与类很相似。\n接着在 oop 文件夹里创建一个文件，命名为 main.go。\n现在目录结构如下所示：\n1 2 workspacepath -\u0026gt; oop -\u0026gt; employee -\u0026gt; employee.go workspacepath -\u0026gt; oop -\u0026gt; main.go main.go 的内容如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;oop/employee\u0026#34; func main() { e := employee.Employee { FirstName: \u0026#34;Sam\u0026#34;, LastName: \u0026#34;Adolf\u0026#34;, TotalLeaves: 30, LeavesTaken: 20, } e.LeavesRemaining() } 我们在第 3 行引用了 employee 包。在 main()（第 12 行），我们调用了 Employee 的 LeavesRemaining() 方法。\n由于有自定义包，这个程序不能在 go playground 上运行。你可以在你的本地运行，在 workspacepath/bin/oop 下输入命令 go install opp，程序会打印输出：\n1 Sam Adolf has 10 leaves remaining 使用 New() 函数，而非构造器 我们上面写的程序看起来没什么问题，但还是有一些细节问题需要注意。我们看看当定义一个零值的 employee 结构体变量时，会发生什么。将 main.go 的内容修改为如下代码：\n1 2 3 4 5 6 7 8 package main import \u0026#34;oop/employee\u0026#34; func main() { var e employee.Employee e.LeavesRemaining() } 我们的修改只是创建一个零值的 Employee 结构体变量（第 6 行）。该程序会输出：\n1 has 0 leaves remaining 你可以看到，使用 Employee 创建的零值变量没有什么用。它没有合法的姓名，也没有合理的休假细节。\n在像 Java 这样的 OOP 语言中，是使用构造器来解决这种问题的。一个合法的对象必须使用参数化的构造器来创建。\nGo 并不支持构造器。如果某类型的零值不可用，需要程序员来隐藏该类型，避免从其他包直接访问。程序员应该提供一种名为 NewT(parameters) 的 函数，按照要求来初始化 T 类型的变量。按照 Go 的惯例，应该把创建 T 类型变量的函数命名为 NewT(parameters)。这就类似于构造器了。如果一个包只含有一种类型，按照 Go 的惯例，应该把函数命名为 New(parameters)， 而不是 NewT(parameters)。\n让我修改一下原先的代码，使得每当创建 employee 的时候，它都是可用的。\n首先应该让 Employee 结构体不可引用，然后创建一个 New 函数，用于创建 Employee 结构体变量。在 employee.go 中输入下面代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package employee import ( \u0026#34;fmt\u0026#34; ) type employee struct { firstName string lastName string totalLeaves int leavesTaken int } func New(firstName string, lastName string, totalLeave int, leavesTaken int) employee { e := employee {firstName, lastName, totalLeave, leavesTaken} return e } func (e employee) LeavesRemaining() { fmt.Printf(\u0026#34;%s %s has %d leaves remaining\u0026#34;, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken)) } 我们进行了一些重要的修改。我们把 Employee 结构体的首字母改为小写 e，也就是将 type Employee struct 改为了 type employee struct。通过这种方法，我们把 employee 结构体变为了不可引用的，防止其他包对它的访问。除非有特殊需求，否则也要隐藏所有不可引用的结构体的所有字段，这是 Go 的最佳实践。由于我们不会在外部包需要 employee 的字段，因此我们也让这些字段无法引用。\n同样，我们还修改了 LeavesRemaining() 的方法。\n现在由于 employee 不可引用，因此不能在其他包内直接创建 Employee 类型的变量。于是我们在第 14 行提供了一个可引用的 New 函数，该函数接收必要的参数，返回一个新创建的 employee 结构体变量。\n这个程序还需要一些必要的修改，但现在先运行这个程序，理解一下当前的修改。如果运行当前程序，编译器会报错，如下所示：\n1 go/src/constructor/main.go:6: undefined: employee.Employee 这是因为我们将 Employee 设置为不可引用，因此编译器会报错，提示该类型没有在 main.go 中定义。很完美，正如我们期望的一样，其他包现在不能轻易创建零值的 employee 变量了。我们成功地避免了创建不可用的 employee 结构体变量。现在创建 employee 变量的唯一方法就是使用 New 函数。\n如下所示，修改 main.go 里的内容。\n1 2 3 4 5 6 7 8 package main import \u0026#34;oop/employee\u0026#34; func main() { e := employee.New(\u0026#34;Sam\u0026#34;, \u0026#34;Adolf\u0026#34;, 30, 20) e.LeavesRemaining() } 该文件唯一的修改就是第 6 行。通过向 New 函数传入所需变量，我们创建了一个新的 employee 结构体变量。\n下面是修改后的两个文件的内容。\nemployee.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package employee import ( \u0026#34;fmt\u0026#34; ) type employee struct { firstName string lastName string totalLeaves int leavesTaken int } func New(firstName string, lastName string, totalLeave int, leavesTaken int) employee { e := employee {firstName, lastName, totalLeave, leavesTaken} return e } func (e employee) LeavesRemaining() { fmt.Printf(\u0026#34;%s %s has %d leaves remaining\u0026#34;, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken)) } main.go\n1 2 3 4 5 6 7 8 package main import \u0026#34;oop/employee\u0026#34; func main() { e := employee.New(\u0026#34;Sam\u0026#34;, \u0026#34;Adolf\u0026#34;, 30, 20) e.LeavesRemaining() } 运行该程序，会输出：\n1 Sam Adolf has 10 leaves remaining 现在你能明白了，虽然 Go 不支持类，但结构体能够很好地取代类，而以 New(parameters) 签名的方法可以替代构造器。\n关于 Go 中的类和构造器到此结束。祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/26-struct/","tags":["struct"],"title":"Go系列教程（二十六） | 结构体(Struct)"},{"categories":["Go系列教程"],"contents":"本教程我们学习 Mutex。我们还会学习怎样通过 Mutex 和信道来处理竞态条件（Race Condition）。\n临界区 在学习 Mutex 之前，我们需要理解并发编程中临界区（Critical Section）的概念。当程序并发地运行时，多个 Go 协程不应该同时访问那些修改共享资源的代码。这些修改共享资源的代码称为临界区。例如，假设我们有一段代码，将一个变量 x 自增 1。\n1 x = x + 1 如果只有一个 Go 协程访问上面的代码段，那都没有任何问题。\n但当有多个协程并发运行时，代码却会出错，让我们看看究竟是为什么吧。简单起见，假设在一行代码的前面，我们已经运行了两个 Go 协程。\n在上一行代码的内部，系统执行程序时分为如下几个步骤（这里其实还有很多包括寄存器的技术细节，以及加法的工作原理等，但对于我们的系列教程，只需认为只有三个步骤就好了）：\n获得 x 的当前值 计算 x + 1 将步骤 2 计算得到的值赋值给 x 如果只有一个协程执行上面的三个步骤，不会有问题。\n我们讨论一下当有两个并发的协程执行该代码时，会发生什么。下图描述了当两个协程并发地访问代码行 x = x + 1 时，可能出现的一种情况。\n我们假设 x 的初始值为 0。而协程 1 获取 x 的初始值，并计算 x + 1。而在协程 1 将计算值赋值给 x 之前，系统上下文切换到了协程 2。于是，协程 2 获取了 x 的初始值（依然为 0），\u0008并计算 x + 1。接着系统上下文又切换回了协程 1。现在，协程 1 将计算值 1 赋值给 x，因此 x 等于 1。然后，协程 2 继续开始执行，把计算值（依然是 1）复制给了 x，因此在所有协程执行完毕之后，x 都等于 1。\n现在我们考虑另外一种可能发生的情况。\n在上面的情形里，协程 1 开始执行，完成了三个步骤后结束，因此 x 的值等于 1。接着，开始执行协程 2。目前 x 的值等于 1。而当协程 2 执行完毕时，x 的值等于 2。\n所以，从这两个例子你可以发现，根据上下文切换的不同情形，x 的最终值是 1 或者 2。这种不太理想的情况称为竞态条件（Race Condition），其程序的输出是由协程的执行顺序决定的。\n在上例中，如果在任意时刻只允许一个 Go 协程访问临界区，那么就可以避免竞态条件。而使用 Mutex 可以达到这个目的。\nMutex Mutex 用于提供一种加锁机制（Locking Mechanism），可确保在某时刻只有一个协程在临界区运行，以防止出现竞态条件。\nMutex 可以在 sync 包内找到。Mutex 定义了两个方法：Lock 和 Unlock。所有在 Lock 和 Unlock 之间的代码，都只能由一个 Go 协程执行，于是就可以避免竞态条件。\n1 2 3 mutex.Lock() x = x + 1 mutex.Unlock() 在上面的代码中，x = x + 1 只能由一个 Go 协程执行，因此避免了竞态条件。\n如果有一个 Go 协程已经持有了锁（Lock），当其他协程试图获得该锁时，这些协程会被阻塞，直到 Mutex 解除锁定为止。\n含有竞态条件的程序 在本节里，我们会编写一个含有竞态条件的程序，而在接下来一节，我们再修复竞态条件的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var x = 0 func increment(wg *sync.WaitGroup) { x = x + 1 wg.Done() } func main() { var w sync.WaitGroup for i := 0; i \u0026lt; 1000; i++ { w.Add(1) go increment(\u0026amp;w) } w.Wait() fmt.Println(\u0026#34;final value of x\u0026#34;, x) } 在上述程序里，第 7 行的 increment 函数把 x 的值加 1，并调用 WaitGroup 的 Done()，通知该函数已结束。\n在上述程序的第 15 行，我们生成了 1000 个 increment 协程。每个 Go 协程并发地运行，由于第 8 行试图增加 x 的值，因此多个并发的协程试图访问 x 的值，这时就会发生竞态条件。\n由于 playground 具有确定性，竞态条件不会在 playground 发生，请在你的本地运行该程序。请在你的本地机器上多运行几次，可以发现由于竞态条件，每一次输出都不同。我其中遇到的几次输出有 final value of x 941、final value of x 928、final value of x 922 等。\n使用 Mutex 在前面的程序里，我们创建了 1000 个 Go 协程。如果每个协程对 x 加 1，最终 x 期望的值应该是 1000。在本节，我们会在程序里使用 Mutex，修复竞态条件的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var x = 0 func increment(wg *sync.WaitGroup, m *sync.Mutex) { m.Lock() x = x + 1 m.Unlock() wg.Done() } func main() { var w sync.WaitGroup var m sync.Mutex for i := 0; i \u0026lt; 1000; i++ { w.Add(1) go increment(\u0026amp;w, \u0026amp;m) } w.Wait() fmt.Println(\u0026#34;final value of x\u0026#34;, x) } Mutex 是一个结构体类型，我们在第 15 行创建了 Mutex 类型的变量 m，其值为零值。在上述程序里，我们修改了 increment 函数，将增加 x 的代码（x = x + 1）放置在 m.Lock() 和 m.Unlock()之间。现在这段代码不存在竞态条件了，因为任何时刻都只允许一个协程执行这段代码。\n于是如果运行该程序，会输出：\n1 final value of x 1000 在第 18 行，传递 Mutex 的地址很重要。如果传递的是 Mutex 的值，而非地址，那么每个协程都会得到 Mutex 的一份拷贝，竞态条件还是会发生。\n使用信道处理竞态条件 我们还能用信道来处理竞态条件。看看是怎么做的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var x = 0 func increment(wg *sync.WaitGroup, ch chan bool) { ch \u0026lt;- true x = x + 1 \u0026lt;- ch wg.Done() } func main() { var w sync.WaitGroup ch := make(chan bool, 1) for i := 0; i \u0026lt; 1000; i++ { w.Add(1) go increment(\u0026amp;w, ch) } w.Wait() fmt.Println(\u0026#34;final value of x\u0026#34;, x) } 在上述程序中，我们创建了容量为 1 的缓冲信道，并在第 18 行将它传入 increment 协程。该缓冲信道用于保证只有一个协程访问增加 x 的临界区。具体的实现方法是在 x 增加之前（第 8 行），传入 true 给缓冲信道。由于缓冲信道的容量为 1，所以任何其他协程试图写入该信道时，都会发生阻塞，直到 x 增加后，信道的值才会被读取（第 10 行）。实际上这就保证了只允许一个协程访问临界区。\n该程序也输出：\n1 final value of x 1000 Mutex vs 信道 通过使用 Mutex 和信道，我们已经解决了竞态条件的问题。那么我们该选择使用哪一个？答案取决于你想要解决的问题。如果你想要解决的问题更适用于 Mutex，那么就用 Mutex。如果需要使用 Mutex，无须犹豫。而如果该问题更适用于信道，那就使用信道。:)\n由于信道是 Go 语言很酷的特性，大多数 Go 新手处理每个并发问题时，使用的都是信道。这是不对的。Go 给了你选择 Mutex 和信道的余地，选择其中之一都可以是正确的。\n总体说来，当 Go 协程需要与其他协程通信时，可以使用信道。而当只允许一个协程访问临界区时，可以使用 Mutex。\n就我们上面解决的问题而言，我更倾向于使用 Mutex，因为该问题并不需要协程间的通信。所以 Mutex 是很自然的选择。\n我的建议是去选择针对问题的工具，而别让问题去将就工具。🤣\n本教程到此结束。祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/25-go-mutex/","tags":["golang"],"title":"Go系列教程（二十五） | Go互斥锁(Mutex)"},{"categories":["Go系列教程"],"contents":"什么是 select？ select 语句用于在多个发送/接收信道操作中进行选择。select 语句会一直阻塞，直到发送/接收操作准备就绪。如果有多个信道操作准备完毕，select 会随机地选取其中之一执行。该语法与 switch 类似，所不同的是，这里的每个 case 语句都是信道操作。我们好好看一些代码来加深理解吧。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func server1(ch chan string) { time.Sleep(6 * time.Second) ch \u0026lt;- \u0026#34;from server1\u0026#34; } func server2(ch chan string) { time.Sleep(3 * time.Second) ch \u0026lt;- \u0026#34;from server2\u0026#34; } func main() { output1 := make(chan string) output2 := make(chan string) go server1(output1) go server2(output2) select { case s1 := \u0026lt;-output1: fmt.Println(s1) case s2 := \u0026lt;-output2: fmt.Println(s2) } } 在上面程序里，server1 函数（第 8 行）休眠了 6 秒，接着将文本 from server1 写入信道 ch。而 server2 函数（第 12 行）休眠了 3 秒，然后把 from server2 写入了信道 ch。\n而 main 函数在第 20 行和第 21 行，分别调用了 server1 和 server2 两个 Go 协程。\n在第 22 行，程序运行到了 select 语句。select 会一直发生阻塞，除非其中有 case 准备就绪。在上述程序里，server1 协程会在 6 秒之后写入 output1 信道，而server2 协程在 3 秒之后就写入了 output2 信道。因此 select 语句会阻塞 3 秒钟，等着 server2 向 output2 信道写入数据。3 秒钟过后，程序会输出：\n1 from server2 然后程序终止。\nselect 的应用 在上面程序中，函数之所以取名为 server1 和 server2，是为了展示 select 的实际应用。\n假设我们有一个关键性应用，需要尽快地把输出返回给用户。这个应用的数据库复制并且存储在世界各地的服务器上。假设函数 server1 和 server2 与这样不同区域的两台服务器进行通信。每台服务器的负载和网络时延决定了它的响应时间。我们向两台服务器发送请求，并使用 select 语句等待相应的信道发出响应。select 会选择首先响应的服务器，而忽略其它的响应。使用这种方法，我们可以向多个服务器发送请求，并给用户返回最快的响应了。🤣\n默认情况 在没有 case 准备就绪时，可以执行 select 语句中的默认情况（Default Case）。这通常用于防止 select 语句一直阻塞。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func process(ch chan string) { time.Sleep(10500 * time.Millisecond) ch \u0026lt;- \u0026#34;process successful\u0026#34; } func main() { ch := make(chan string) go process(ch) for { time.Sleep(1000 * time.Millisecond) select { case v := \u0026lt;-ch: fmt.Println(\u0026#34;received value: \u0026#34;, v) return default: fmt.Println(\u0026#34;no value received\u0026#34;) } } } 上述程序中，第 8 行的 process 函数休眠了 10500 毫秒（10.5 秒），接着把 process successful 写入 ch 信道。在程序中的第 15 行，并发地调用了这个函数。\n在并发地调用了 process 协程之后，主协程启动了一个无限循环。这个无限循环在每一次迭代开始时，都会先休眠 1000 毫秒（1 秒），然后执行一个 select 操作。在最开始的 10500 毫秒中，由于 process 协程在 10500 毫秒后才会向 ch 信道写入数据，因此 select 语句的第一个 case（即 case v := \u0026lt;-ch:）并未就绪。所以在这期间，程序会执行默认情况，该程序会打印 10 次 no value received。\n在 10.5 秒之后，process 协程会在第 10 行向 ch 写入 process successful。现在，就可以执行 select 语句的第一个 case 了，程序会打印 received value: process successful，然后程序终止。该程序会输出：\n1 2 3 4 5 6 7 8 9 10 11 no value received no value received no value received no value received no value received no value received no value received no value received no value received no value received received value: process successful 死锁与默认情况 1 2 3 4 5 6 7 8 package main func main() { ch := make(chan string) select { case \u0026lt;-ch: } } 上面的程序中，我们在第 4 行创建了一个信道 ch。我们在 select 内部（第 6 行），试图读取信道 ch。由于没有 Go 协程向该信道写入数据，因此 select 语句会一直阻塞，导致死锁。该程序会触发运行时 panic，报错信息如下：\n1 2 3 4 5 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.main() /tmp/sandbox416567824/main.go:6 +0x80 如果存在默认情况，就不会发生死锁，因为在没有其他 case 准备就绪时，会执行默认情况。我们用默认情况重写后，程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 package main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan string) select { case \u0026lt;-ch: default: fmt.Println(\u0026#34;default case executed\u0026#34;) } } 以上程序会输出：\n1 default case executed 如果 select 只含有值为 nil 的信道，也同样会执行默认情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { var ch chan string select { case v := \u0026lt;-ch: fmt.Println(\u0026#34;received value\u0026#34;, v) default: fmt.Println(\u0026#34;default case executed\u0026#34;) } } 在上面程序中，ch 等于 nil，而我们试图在 select 中读取 ch（第 8 行）。如果没有默认情况，select 会一直阻塞，导致死锁。由于我们在 select 内部加入了默认情况，程序会执行它，并输出：\n1 default case executed 随机选取 当 select 由多个 case 准备就绪时，将会随机地选取其中之一去执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func server1(ch chan string) { ch \u0026lt;- \u0026#34;from server1\u0026#34; } func server2(ch chan string) { ch \u0026lt;- \u0026#34;from server2\u0026#34; } func main() { output1 := make(chan string) output2 := make(chan string) go server1(output1) go server2(output2) time.Sleep(1 * time.Second) select { case s1 := \u0026lt;-output1: fmt.Println(s1) case s2 := \u0026lt;-output2: fmt.Println(s2) } } 在上面程序里，我们在第 18 行和第 19 行分别调用了 server1 和 server2 两个 Go 协程。接下来，主程序休眠了 1 秒钟（第 20 行）。当程序控制到达第 21 行的 select 语句时，server1 已经把 from server1 写到了 output1 信道上，而 server2 也同样把 from server2 写到了 output2 信道上。因此这个 select 语句中的两种情况都准备好执行了。如果你运行这个程序很多次的话，输出会是 from server1 或者 from server2，这会根据随机选取的结果而变化。\n请在你的本地系统上运行这个程序，获得程序的随机结果。因为如果你在 playground 上在线运行的话，它的输出总是一样的，这是由于 playground 不具有随机性所造成的。\n这下我懂了：空 select 1 2 3 4 5 package main func main() { select {} } 你认为上面代码会输出什么？\n我们已经知道，除非有 case 执行，select 语句就会一直阻塞着。在这里，select 语句没有任何 case，因此它会一直阻塞，导致死锁。该程序会触发 panic，输出如下：\n1 2 3 4 5 fatal error: all goroutines are asleep - deadlock! goroutine 1 [select (no cases)]: main.main() /tmp/sandbox299546399/main.go:4 +0x20 本教程到此结束。祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/24-go-select/","tags":["golang"],"title":"Go系列教程（二十四） | Go Select"},{"categories":["Go系列教程"],"contents":"什么是缓冲信道？ 在上一教程里，我们讨论的主要是无缓冲信道。我们在信道的教程里详细讨论了，无缓冲信道的发送和接收过程是阻塞的。\n我们还可以创建一个有缓冲（Buffer）的信道。只在缓冲已满的情况，才会阻塞向缓冲信道（Buffered Channel）发送数据。同样，只有在缓冲为空的时候，才会阻塞从缓冲信道接收数据。\n通过向 make 函数再传递一个表示容量的参数（指定缓冲的大小），可以创建缓冲信道。\n1 ch := make(chan type, capacity) 要让一个信道有缓冲，上面语法中的 capacity 应该大于 0。无缓冲信道的容量默认为 0，因此我们在上一教程创建信道时，省略了容量参数。\n我们开始编写代码，创建一个缓冲信道。\n示例一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; ) func main() { ch := make(chan string, 2) ch \u0026lt;- \u0026#34;naveen\u0026#34; ch \u0026lt;- \u0026#34;paul\u0026#34; fmt.Println(\u0026lt;- ch) fmt.Println(\u0026lt;- ch) } 在上面程序里的第 9 行，我们创建了一个缓冲信道，其容量为 2。由于该信道的容量为 2，因此可向它写入两个字符串，而且不会发生阻塞。在第 10 行和第 11 行，我们向信道写入两个字符串，该信道并没有发生阻塞。我们又在第 12 行和第 13 行分别读取了这两个字符串。该程序输出：\n1 2 naveen paul 示例二 我们再看一个缓冲信道的示例，其中有一个并发的 Go 协程来向信道写入数据，而 Go 主协程负责读取数据。该示例帮助我们进一步理解，在向缓冲信道写入数据时，什么时候会发生阻塞。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func write(ch chan int) { for i := 0; i \u0026lt; 5; i++ { ch \u0026lt;- i fmt.Printf(\u0026#34;successfully wrote %d to ch\\n\u0026#34;, i) } close(ch) } func main() { ch := make(chan int, 2) go write(ch) time.Sleep(2 * time.Second) for v := range ch { fmt.Printf(\u0026#34;read value %d from ch\\n\u0026#34;, v) time.Sleep(2 * time.Second) } } 在上面的程序中，第 16 行在 Go 主协程中创建了容量为 2 的缓冲信道 ch，而第 17 行把 ch 传递给了 write 协程。接下来 Go 主协程休眠了两秒。在这期间，write 协程在并发地运行。write 协程有一个 for 循环，依次向信道 ch 写入 0～4。而缓冲信道的容量为 2，因此 write 协程里立即会向 ch 写入 0 和 1，接下来发生阻塞，直到 ch 内的值被读取。因此，该程序立即打印出下面两行：\n1 2 successfully wrote 0 to ch successfully wrote 1 to ch 打印上面两行之后，write 协程中向 ch 的写入发生了阻塞，直到 ch 有值被读取到。而 Go 主协程休眠了两秒后，才开始读取该信道，因此在休眠期间程序不会打印任何结果。主协程结束休眠后，在第 19 行使用 for range 循环，开始读取信道 ch，打印出了读取到的值后又休眠两秒，这个循环一直到 ch 关闭才结束。所以该程序在两秒后会打印下面两行：\n1 2 read value 0 from ch successfully wrote 2 to ch 该过程会一直进行，直到信道被读取完所有的值，并在 write 协程中关闭信道。最终输出如下：\n1 2 3 4 5 6 7 8 9 10 successfully wrote 0 to ch successfully wrote 1 to ch read value 0 from ch successfully wrote 2 to ch read value 1 from ch successfully wrote 3 to ch read value 2 from ch successfully wrote 4 to ch read value 3 from ch read value 4 from ch 死锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; ) func main() { ch := make(chan string, 2) ch \u0026lt;- \u0026#34;naveen\u0026#34; ch \u0026lt;- \u0026#34;paul\u0026#34; ch \u0026lt;- \u0026#34;steve\u0026#34; fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) } 在上面程序里，我们向容量为 2 的缓冲信道写入 3 个字符串。当在程序控制到达第 3 次写入时（第 11 行），由于它超出了信道的容量，因此这次写入发生了阻塞。现在想要这次写操作能够进行下去，必须要有其它协程来读取这个信道的数据。但在本例中，并没有并发协程来读取这个信道，因此这里会发生死锁（deadlock）。程序会在运行时触发 panic，信息如下：\n1 2 3 4 5 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() /tmp/sandbox274756028/main.go:11 +0x100 长度 vs 容量 缓冲信道的容量是指信道可以存储的值的数量。我们在使用 make 函数创建缓冲信道的时候会指定容量大小。\n缓冲信道的长度是指信道中当前排队的元素个数。\n代码可以把一切解释得很清楚。🤣\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; ) func main() { ch := make(chan string, 3) ch \u0026lt;- \u0026#34;naveen\u0026#34; ch \u0026lt;- \u0026#34;paul\u0026#34; fmt.Println(\u0026#34;capacity is\u0026#34;, cap(ch)) fmt.Println(\u0026#34;length is\u0026#34;, len(ch)) fmt.Println(\u0026#34;read value\u0026#34;, \u0026lt;-ch) fmt.Println(\u0026#34;new length is\u0026#34;, len(ch)) } 在上面的程序里，我们创建了一个容量为 3 的信道，于是它可以保存 3 个字符串。接下来，我们分别在第 9 行和第 10 行向信道写入了两个字符串。于是信道有两个字符串排队，因此其长度为 2。在第 13 行，我们又从信道读取了一个字符串。现在该信道内只有一个字符串，因此其长度变为 1。该程序会输出：\n1 2 3 4 capacity is 3 length is 2 read value naveen new length is 1 WaitGroup 在本教程的下一节里，我们会讲到工作池（Worker Pools）。而 WaitGroup 用于实现工作池，因此要理解工作池，我们首先需要学习 WaitGroup。\nWaitGroup 用于等待一批 Go 协程执行结束。程序控制会一直阻塞，直到这些协程全部执行完毕。假设我们有 3 个并发执行的 Go 协程（由 Go 主协程生成）。Go 主协程需要等待这 3 个协程执行结束后，才会终止。这就可以用 WaitGroup 来实现。\n理论说完了，我们编写点儿代码吧。🤣\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) func process(i int, wg *sync.WaitGroup) { fmt.Printf(\u0026#34;Started goroutine %d\\n\u0026#34;, i) time.Sleep(2 * time.Second) fmt.Printf(\u0026#34;Goroutine %d ended\\n\u0026#34;, i) wg.Done() } func main() { no := 3 var wg sync.WaitGroup for i := 0; i \u0026lt; no; i++ { wg.Add(1) go process(i, \u0026amp;wg) } wg.Wait() fmt.Println(\u0026#34;All goroutines are executed\u0026#34;) } WaitGroup 是一个结构体类型，我们在第 18 行创建了 WaitGroup 类型的变量，其初始值为零值。WaitGroup 使用计数器来工作。当我们调用 WaitGroup 的 Add 并传递一个 int 时，WaitGroup 的计数器会加上 Add 的传参。要减少计数器，可以调用 WaitGroup 的 Done() 方法。Wait() 方法会阻塞调用它的 Go 协程，直到计数器变为 0 后才会停止阻塞。\n上述程序里，for 循环迭代了 3 次，我们在循环内调用了 wg.Add(1)（第 20 行）。因此计数器变为 3。for 循环同样创建了 3 个 process 协程，然后在第 23 行调用了 wg.Wait()，确保 Go 主协程等待计数器变为 0。在第 13 行，process 协程内调用了 wg.Done，可以让计数器递减。一旦 3 个子协程都执行完毕（即 wg.Done() 调用了 3 次），那么计数器就变为 0，于是主协程会解除阻塞。\n在第 21 行里，传递 wg 的地址是很重要的。如果没有传递 wg 的地址，那么每个 Go 协程将会得到一个 WaitGroup 值的拷贝，因而当它们执行结束时，main 函数并不会知道。\n该程序输出：\n1 2 3 4 5 6 7 Started goroutine 2 Started goroutine 0 Started goroutine 1 Goroutine 1 ended Goroutine 0 ended Goroutine 2 ended All goroutines are executed 由于 Go 协程的执行顺序不一定，因此你的输出可能和我不一样。🤣\n工作池的实现 缓冲信道的重要应用之一就是实现工作池。\n一般而言，工作池就是一组等待任务分配的线程。一旦完成了所分配的任务，这些线程可继续等待任务的分配。\n我们会使用缓冲信道来实现工作池。我们工作池的任务是计算所输入数字的每一位的和。例如，如果输入 234，结果会是 9（即 2 + 3 + 4）。向工作池输入的是一列伪随机数。\n我们工作池的核心功能如下：\n创建一个 Go 协程池，监听一个等待作业分配的输入型缓冲信道。 将作业添加到该输入型缓冲信道中。 作业完成后，再将结果写入一个输出型缓冲信道。 从输出型缓冲信道读取并打印结果。 我们会逐步编写这个程序，让代码易于理解。\n第一步：就是创建两个结构体，表示作业和结果。 1 2 3 4 5 6 7 8 9 type Job struct { id int randomno int } type Result struct { job Job sumofdigits int } 所有 Job 结构体变量都会有 id 和 randomno 两个字段，randomno 用于计算其每位数之和。\n而 Result 结构体有一个 job 字段，表示所对应的作业，还有一个 sumofdigits 字段，表示计算的结果（每位数字之和）。\n第二步：是分别创建用于接收作业和写入结果的缓冲信道。 1 2 var jobs = make(chan Job, 10) var results = make(chan Result, 10) 工作协程（Worker Goroutine）会监听 jobs 缓冲信道里更新的作业。一旦工作协程完成了作业，其结果就会写入 results 缓冲信道。\n第三步：创建任务处理函数。 如下所示，digits 函数的任务实际上就是计算整数的每一位之和，最后返回该结果。为了模拟出 digits 在计算过程中花费了一段时间，我们在函数内添加了两秒的休眠时间。\n1 2 3 4 5 6 7 8 9 10 11 func digits(number int) int { sum := 0 no := number for no != 0 { digit := no % 10 sum += digit no /= 10 } time.Sleep(2 * time.Second) return sum } 第四步：然后，我们写一个创建工作协程的函数。 1 2 3 4 5 6 7 func worker(wg *sync.WaitGroup) { for job := range jobs { output := Result{job, digits(job.randomno)} results \u0026lt;- output } wg.Done() } 上面的函数创建了一个工作者（Worker），读取 jobs 信道的数据，根据当前的 job 和 digits 函数的返回值，创建了一个 Result 结构体变量，然后将结果写入 results 缓冲信道。worker 函数接收了一个 WaitGroup 类型的 wg 作为参数，当所有的 jobs 完成的时候，调用了 Done() 方法。\n第四步：紧接着我们写一个创建 Go 协程工作池的函数。 1 2 3 4 5 6 7 8 9 func createWorkerPool(noOfWorkers int) { var wg sync.WaitGroup for i := 0; i \u0026lt; noOfWorkers; i++ { wg.Add(1) go worker(\u0026amp;wg) } wg.Wait() close(results) } 上面 createWorkerPool 函数的参数是需要创建的工作协程的数量。在函数内部通过一个循环创建所有的工作协程。在创建工作协程之前，它调用了 wg.Add(1) 方法，于是 WaitGroup 计数器递增。接下来，我们创建工作协程，并向 worker 函数传递 wg 的地址。创建了需要的所有工作协程后，函数调用 wg.Wait()，等待所有的工作协程执行完毕。当所有的工作协程执行完毕之后，函数会关闭 results 信道。因为所有协程都已经执行完毕，于是不再需要向 results 信道写入数据了。\n第五步：添加作业分配函数。 现在我们已经有了工作池，我们继续编写一个函数，把作业分配给工作者。\n1 2 3 4 5 6 7 8 func allocate(noOfJobs int) { for i := 0; i \u0026lt; noOfJobs; i++ { randomno := rand.Intn(999) job := Job{i, randomno} jobs \u0026lt;- job } close(jobs) } 上面的 allocate 函数，接收所需要创建的作业数量作为输入参数，生成了最大值为 998 的伪随机数，并使用该随机数创建了 Job 结构体变量。这个函数把 for 循环的计数器 i 作为 id，最后把创建的结构体变量写入 jobs 信道。当写入所有的 job 时，它关闭了 jobs 信道。\n第六步：添加结果信道读取函数。 接下来创建一个读取 results 信道数据并打印输出的函数。\n1 2 3 4 5 6 func result(done chan bool) { for result := range results { fmt.Printf(\u0026#34;Job id %d, input random no %d , sum of digits %d\\n\u0026#34;, result.job.id, result.job.randomno, result.sumofdigits) } done \u0026lt;- true } result 函数读取 results 信道，并打印出 job 的 id、输入的随机数、该随机数的每位数之和。result 函数也接受 done 信道作为参数，当打印所有结果时，done 会被写入 true。\n第七步：main函数组织调用。 现在一切准备充分了。我们继续完成最后一步，在 main() 函数中调用上面所有的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func main() { startTime := time.Now() noOfJobs := 100 go allocate(noOfJobs) done := make(chan bool) go result(done) noOfWorkers := 10 createWorkerPool(noOfWorkers) \u0026lt;-done endTime := time.Now() diff := endTime.Sub(startTime) fmt.Println(\u0026#34;total time taken \u0026#34;, diff.Seconds(), \u0026#34;seconds\u0026#34;) } 我们首先在 main 函数的第 2 行，保存了程序的起始时间，并在最后一行（第 12 行）计算了 endTime 和 startTime 的差值，显示出程序运行的总时间。由于我们想要通过改变协程数量，来做一点基准指标（Benchmark），所以需要这么做。\n我们把 noOfJobs 设置为 100，接下来调用了 allocate，向 jobs 信道添加作业。\n我们创建了 done 信道，并将其传递给 result 协程。于是该协程会开始打印结果，并在完成打印时发出通知。\n通过调用 createWorkerPool 函数，我们最终创建了一个有 10 个协程的工作池。main 函数会监听 done 信道的通知，等待所有结果打印结束。\n为了便于参考，下面是整个程序。我还引用了必要的包。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Job struct { id int randomno int } type Result struct { job Job sumofdigits int } var jobs = make(chan Job, 10) var results = make(chan Result, 10) func digits(number int) int { sum := 0 no := number for no != 0 { digit := no % 10 sum += digit no /= 10 } time.Sleep(2 * time.Second) return sum } func worker(wg *sync.WaitGroup) { for job := range jobs { output := Result{job, digits(job.randomno)} results \u0026lt;- output } wg.Done() } func createWorkerPool(noOfWorkers int) { var wg sync.WaitGroup for i := 0; i \u0026lt; noOfWorkers; i++ { wg.Add(1) go worker(\u0026amp;wg) } wg.Wait() close(results) } func allocate(noOfJobs int) { for i := 0; i \u0026lt; noOfJobs; i++ { randomno := rand.Intn(999) job := Job{i, randomno} jobs \u0026lt;- job } close(jobs) } func result(done chan bool) { for result := range results { fmt.Printf(\u0026#34;Job id %d, input random no %d , sum of digits %d\\n\u0026#34;, result.job.id, result.job.randomno, result.sumofdigits) } done \u0026lt;- true } func main() { startTime := time.Now() noOfJobs := 100 go allocate(noOfJobs) done := make(chan bool) go result(done) noOfWorkers := 10 createWorkerPool(noOfWorkers) \u0026lt;-done endTime := time.Now() diff := endTime.Sub(startTime) fmt.Println(\u0026#34;total time taken \u0026#34;, diff.Seconds(), \u0026#34;seconds\u0026#34;) } 为了更精确地计算总时间，请在你的本地机器上运行该程序。\n该程序输出：\n1 2 3 4 5 Job id 1, input random no 636, sum of digits 15 Job id 0, input random no 878, sum of digits 23 Job id 9, input random no 150, sum of digits 6 ... total time taken 20.01081009 seconds 程序总共会打印 100 行，对应着 100 项作业，然后最后会打印一行程序消耗的总时间。你的输出会和我的不同，因为 Go 协程的运行顺序不一定，同样总时间也会因为硬件而不同。在我的例子中，运行程序大约花费了 20 秒。\n现在我们把 main 函数里的 noOfWorkers 增加到 20。我们把工作者的数量加倍了。由于工作协程增加了（准确说来是两倍），因此程序花费的总时间会减少（准确说来是一半）。在我的例子里，程序会打印出 10.004364685 秒。\n1 2 ... total time taken 10.004364685 seconds 现在我们可以理解了，随着工作协程数量增加，完成作业的总时间会减少。你们可以练习一下：在 main 函数里修改 noOfJobs 和 noOfWorkers 的值，并试着去分析一下结果。\n本教程到此结束。祝你愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/23-buffered-channels-and-worker-pools/","tags":["Golang"],"title":"Go系列教程（二十三） | Go缓冲信道和工作池(Buffered Channels and Worker Pools)"},{"categories":["Go系列教程"],"contents":"在上一教程里，我们探讨了如何使用 Go 协程（Goroutine）来实现并发。我们接着在本教程里学习信道（Channel），学习如何通过信道来实现 Go 协程间的通信。\n什么是信道？ 信道（通道）可以想像成 Go 协程之间通信的管道。如同管道中的水会从一端流到另一端，通过使用信道，数据也可以从一端发送，在另一端接收。\n信道的声明 所有信道都关联了一个类型。信道只能运输这种类型的数据，而运输其他类型的数据都是非法的。\nchan T 表示 T 类型的信道。\n信道的零值为 nil。信道的零值没有什么用，应该使用 make 内置函数，来像对 Map 和 Slice 初始化那样，来定义信道。\n定义：指对标志符声明并初始化，声明可以通俗的理解为指定标志符所表示的具体类型，初始化可以理解为开辟内存空间。只声明并没有对其初始化的标志符在Go语言中其默认值为类型零值。\n下面编写代码，定义一个信道。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { // 变量声明 var a chan int if a == nil { fmt.Println(\u0026#34;channel a is nil, going to initialize it\u0026#34;) // 变量初始化 a = make(chan int) fmt.Printf(\u0026#34;Type of a is %T\u0026#34;, a) } } 在第 7 行，因为只是对变量 a 的一个声明，并没有初始化，由于信道是引用类型，所以变量 a 的值为类型零值，也就是为 nil。于是，程序执行了 if 语句块内的语句，在第 11 行，初始化了信道 a。程序中 a 是一个 int 类型的信道。该程序会输出：\n1 2 channel a is nil, going to initialize it Type of a is chan int 简短声明通常也是一种定义信道的简洁有效的方法。\n1 a := make(chan int) 这一行代码同样定义了一个 int 类型的信道 a。\n通过信道进行发送和接收 如下所示，该语法通过信道发送和接收数据。\n1 2 3 4 5 // 读取信道 a data := \u0026lt;- a // 写入信道 a a \u0026lt;- data 信道旁的箭头方向指定了是发送数据还是接收数据。\n在第一行，箭头对于 a 来说是向外指的，因此我们读取了信道 a 的值，并把该值存储到变量 data。\n在第二行，箭头指向了 a，因此我们在把数据写入信道 a。\n发送与接收默认是阻塞的 发送与接收默认是阻塞的。这是什么意思？当把数据发送到信道时，程序控制会在发送数据的语句处发生阻塞，直到有其它 Go 协程从信道中读取到数据，才会解除阻塞。与此类似，当读取信道中的数据时，如果没有其它的 Go 协程把数据写入到这个信道中，那么读取信道的过程就会一直阻塞着。\n信道的这种特性能够帮助 Go 协程之间进行高效的通信，不需要用到其他编程语言中常见的显式锁或条件变量。\n信道的代码示例 理论已经够了🤣。接下来写点代码，看看协程之间通过信道是怎么通信的吧。\n我们其实可以重写上章学习 Go 协程 时写的程序，现在我们在这里用上信道。\n首先引用前面教程里的程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func hello() { fmt.Println(\u0026#34;Hello world goroutine\u0026#34;) } func main() { go hello() time.Sleep(1 * time.Second) fmt.Println(\u0026#34;main function\u0026#34;) } 这是上一篇的代码。我们使用到了休眠，使 Go 主协程等待 hello 协程结束。如果你看不懂，建议你阅读上一教程 Go 协程。\n我们接下来使用信道来重写上面代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; ) func hello(done chan bool) { fmt.Println(\u0026#34;Hello world goroutine\u0026#34;) done \u0026lt;- true } func main() { done := make(chan bool) go hello(done) \u0026lt;-done fmt.Println(\u0026#34;main function\u0026#34;) } 在上述程序里，我们在第 13 行创建了一个 bool 类型的信道 done，并把 done 作为参数传递给了 hello 协程。在第 15 行，我们通过信道 done 读取（接收）数据。这一行代码发生了阻塞，除非有协程向 done 写入（发送）数据，否则程序不会跳到下一行代码。于是，这就不需要用以前的 time.Sleep 方式来阻止 Go 主协程退出了。\n第 15 行代码 \u0026lt;-done 通过信道 done 读取（接收）数据，但并没有使用数据或者把数据存储到变量中。这完全是合法的。\n现在我们的 Go 主协程发生了阻塞，等待信道 done 写入（发送）的数据。该信道作为参数传递给了协程 hello，hello 打印出 Hello world goroutine，接下来向 done 写入（发送）数据。当完成写入（发送）时，Go 主协程会通过信道 done 读取（接收）数据，于是它解除阻塞状态，打印出文本 main function。\n该程序输出如下：\n1 2 Hello world goroutine main function 我们稍微修改一下程序，在 hello 协程里加入休眠函数，以便更好地理解阻塞的概念。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func hello(done chan bool) { fmt.Println(\u0026#34;hello go routine is going to sleep\u0026#34;) time.Sleep(4 * time.Second) fmt.Println(\u0026#34;hello go routine awake and going to write to done\u0026#34;) done \u0026lt;- true } func main() { done := make(chan bool) fmt.Println(\u0026#34;Main going to call hello go goroutine\u0026#34;) go hello(done) \u0026lt;-done fmt.Println(\u0026#34;Main received data\u0026#34;) } 在上面程序里，我们向 hello 函数里添加了 4 秒的休眠（第 10 行）。\n程序首先会打印 Main going to call hello go goroutine。接着会开启 hello 协程，打印 hello go routine is going to sleep。打印完之后，hello 协程会休眠 4 秒钟，而在这期间，Go 主协程会在 \u0026lt;-done 这一行发生阻塞，等待来自信道 done 的数据。4 秒钟之后，打印 hello go routine awake and going to write to done，接着再打印 Main received data。\n信道的另一个示例 我们再编写一个程序来更好地理解信道。该程序会计算一个数中的每一位数字的平方和与立方和，然后把平方和与立方和相加并打印出来。\n例如，如果输入是 123，该程序会如下计算输出：\n1 2 3 4 5 6 7 8 // 平方和 14 squares = (1 * 1) + (2 * 2) + (3 * 3) // 立方和 36 cubes = (1 * 1 * 1) + (2 * 2 * 2) + (3 * 3 * 3) // 平方和与立方和之和 50 output = squares + cubes 我们会这样去构建程序：在一个单独的 Go 协程计算平方和，而在另一个单独的 Go 协程计算立方和，最后在 Go 主协程把平方和与立方和相加。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; ) func calcSquares(number int, squareop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit number /= 10 } squareop \u0026lt;- sum } func calcCubes(number int, cubeop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit * digit number /= 10 } cubeop \u0026lt;- sum } func main() { number := 799 sqrch := make(chan int) cubech := make(chan int) go calcSquares(number, sqrch) go calcCubes(number, cubech) squares, cubes := \u0026lt;-sqrch, \u0026lt;-cubech fmt.Println(\u0026#34;Final output\u0026#34;, squares + cubes) } 在第 7 行，函数 calcSquares 计算一个数每位的平方和，并把计算结果发送给信道 squareop。与此类似，在第 17 行，函数 calcCubes 计算一个数每位的立方和，并把计算结果发送给信道 cubop。\n这两个函数分别在单独的 Go 协程里运行（第 31 行和第 32 行），每个函数都有传递信道的参数，以便写入数据。Go 主协程会在第 33 行等待两个信道传来的数据。一旦从两个信道接收完数据，数据就会存储在变量 squares 和 cubes 里，然后计算这两个变量的和并打印出最终的结果。该程序会输出：\n1 Final output 2012 死锁 使用信道需要考虑的一个重点是死锁。当 Go 协程给一个信道发送数据时，照理说会有其他 Go 协程来接收数据。如果没有的话，程序就会在运行时触发 panic，形成死锁。\n同理，当有 Go 协程等着从一个信道接收数据时，我们期望其他的 Go 协程会向该信道发送数据，要不然程序就会触发 panic。\n1 2 3 4 5 6 package main func main() { ch := make(chan int) ch \u0026lt;- 5 } 在上述程序中，我们创建了一个信道 ch，接着在下一行 ch \u0026lt;- 5，我们把 5 发送到这个信道。对于本程序而言，没有其他的 Go 协程从信道 ch 接收数据。于是程序触发 panic，出现如下运行时错误。\n1 2 3 4 5 fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() /tmp/sandbox249677995/main.go:6 +0x80 单向信道 我们目前讨论的信道都是双向信道，即通过信道既能发送数据，又能接收数据。其实也可以创建单向信道，这种信道只能发送或者接收数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func sendData(sendch chan\u0026lt;- int) { sendch \u0026lt;- 10 } func main() { sendch := make(chan\u0026lt;- int) go sendData(sendch) fmt.Println(\u0026lt;-sendch) } 上面程序的第 10 行，我们创建了唯送（Send Only）信道 sendch。chan\u0026lt;- int 定义了唯送信道，因为箭头指向了 chan。在第 12 行，我们试图通过唯送信道接收数据，于是编译器报错：\n1 main.go:11: invalid operation: \u0026lt;-sendch (receive from send-only type chan\u0026lt;- int) 一切都很顺利，只不过一个不能读取数据的唯送信道究竟有什么意义呢？\n这就需要用到信道转换（Channel Conversion）了。把一个双向信道转换成唯送信道或者唯收（Receive Only）信道都是行得通的，但是反过来就不行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func sendData(sendch chan\u0026lt;- int) { sendch \u0026lt;- 10 } func main() { cha1 := make(chan int) go sendData(cha1) fmt.Println(\u0026lt;-cha1) } 在上述程序的第 10 行，我们创建了一个双向信道 cha1。在第 11 行把 cha1 作为参数传递给了 sendData 协程。在第 5 行，函数 sendData 里的参数 sendch chan\u0026lt;- int 把 cha1 转换为一个唯送信道。于是该信道在 sendData 协程里是一个唯送信道，而在 Go 主协程里是一个双向信道。该程序最终打印输出 10。\n关闭信道和使用 for range 遍历信道 数据发送方可以关闭信道，通知接收方这个信道不再有数据发送过来。\n当从信道接收数据时，接收方可以多用一个变量来检查信道是否已经关闭。\n1 v, ok := \u0026lt;- ch 上面的语句里，如果成功接收信道所发送的数据，那么 ok 等于 true。而如果 ok 等于 false，说明我们试图读取一个关闭的信道。从关闭的信道读取到的值会是该信道类型的零值。例如，当信道是一个 int 类型的信道时，那么从关闭的信道读取的值将会是 0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; ) func producer(values chan int) { for i := 0; i \u0026lt; 10; i++ { values \u0026lt;- i } close(values) } func main() { ch := make(chan int) go producer(ch) for { v, ok := \u0026lt;-ch if ok == false { break } fmt.Println(\u0026#34;Received \u0026#34;, v, ok) } } 在上述的程序中，producer 协程会将数字从 0 到 9 写入到信道 values，然后关闭该信道。主函数有一个无限的 for 循环（第 17 行），使用变量 ok（第 19 行）检查信道是否已经关闭。如果 ok 等于 false，说明信道已经关闭，于是退出 for 循环。如果 ok 等于 true，会打印出接收到的值和 ok 的值。\n1 2 3 4 5 6 7 8 9 10 Received 0 true Received 1 true Received 2 true Received 3 true Received 4 true Received 5 true Received 6 true Received 7 true Received 8 true Received 9 true for range 循环用于在一个信道关闭之前，从信道接收数据。\n接下来我们使用 for range 循环重写上面的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;fmt\u0026#34; ) func producer(values chan int) { for i := 0; i \u0026lt; 10; i++ { values \u0026lt;- i } close(values) } func main() { ch := make(chan int) go producer(ch) for v := range ch { fmt.Println(\u0026#34;Received \u0026#34;,v) } } 在第 17 行，for range 循环从信道 ch 接收数据，直到该信道关闭。一旦关闭了 ch，循环会自动结束。该程序会输出：\n1 2 3 4 5 6 7 8 9 10 Received 0 Received 1 Received 2 Received 3 Received 4 Received 5 Received 6 Received 7 Received 8 Received 9 我们可以使用 for range 循环，重写信道的另一个示例这一节里面的代码，提高代码的可重用性。\n如果你仔细观察这段代码，会发现获得一个数里的每位数的代码在 calcSquares 和 calcCubes 两个函数内重复了。我们将把这段代码抽离出来，放在一个单独的函数里，然后并发地调用它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import ( \u0026#34;fmt\u0026#34; ) func digits(number int, dchnl chan int) { for number != 0 { digit := number % 10 dchnl \u0026lt;- digit number /= 10 } close(dchnl) } func calcSquares(number int, squareop chan int) { sum := 0 dch := make(chan int) go digits(number, dch) for digit := range dch { sum += digit * digit } squareop \u0026lt;- sum } func calcCubes(number int, cubeop chan int) { sum := 0 dch := make(chan int) go digits(number, dch) for digit := range dch { sum += digit * digit * digit } cubeop \u0026lt;- sum } func main() { number := 799 sqrch := make(chan int) cubech := make(chan int) go calcSquares(number, sqrch) go calcCubes(number, cubech) squares, cubes := \u0026lt;-sqrch, \u0026lt;-cubech fmt.Println(\u0026#34;Final output\u0026#34;, squares+cubes) } 上述程序里的 digits 函数，包含了获取一个数的每位数的逻辑，并且 calcSquares 和 calcCubes 两个函数并发地调用了 digits。当计算完一个数的每一位数时，第 13 行就会关闭信道。calcSquares 和 calcCubes 两个协程使用 for range 循环分别监听了它们的信道，直到该信道关闭。程序的其他地方不变，该程序同样会输出：\n1 Final output 2012 本教程的内容到此结束。关于信道还有一些其他的概念，比如缓冲信道（Buffered Channel）、工作池（Worker Pool）和 select。我们会在接下来的教程里专门介绍它们。感谢你的阅读。祝你过得愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/22-golang-channel/","tags":["Golang"],"title":"Go系列教程（二十二） | Go信道(channels)"},{"categories":["Go系列教程"],"contents":"在前面的教程里，我们探讨了并发，以及并发与并行的区别。本教程则会介绍在 Go 语言里，如何使用 Go 协程（Goroutine）来实现并发。\nGo 协程是什么？ Go 协程是与其他函数或方法一起并发运行的函数或方法。Go 协程可以看作是轻量级线程。与线程相比，创建一个 Go 协程的成本很小。因此在 Go 应用中，常常会看到有数以千计的 Go 协程并发地运行。\nGo 协程相比于线程的优势 相比线程而言，Go 协程的成本极低。堆栈大小只有若干 kb，并且可以根据应用的需求进行增减。而线程必须指定堆栈的大小，其堆栈是固定不变的。 Go 协程会复用（Multiplex）数量更少的 OS 线程。即使程序有数以千计的 Go 协程，也可能只有一个线程。如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），那么系统会再创建一个 OS 线程，并把其余 Go 协程都移动到这个新的 OS 线程。所有这一切都在运行时进行，作为程序员，我们没有直接面临这些复杂的细节，而是有一个简洁的 API 来处理并发。 Go 协程使用信道（Channel）来进行通信。信道用于防止多个协程访问共享内存时发生竞态条件（Race Condition）。信道可以看作是 Go 协程之间通信的管道。我们会在下一教程详细讨论信道。 如何启动一个 Go 协程？ 调用函数或者方法时，在前面加上 go 关键字，就可以让一个新的 Go 协程并发地运行。\n让我们创建一个 Go 协程吧。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; ) func hello() { fmt.Println(\u0026#34;Hello world goroutine\u0026#34;) } func main() { go hello() fmt.Println(\u0026#34;main function\u0026#34;) } 在第 12 行，go hello() 启动了一个新的 Go 协程。现在 hello() 函数与 main() 函数会并发地执行。main() 函数会运行在一个特有的 Go 协程上，它称为 Go 主协程（Main Goroutine）。\n运行一下程序，你会很惊讶！\n该程序只会输出文本 main function。我们启动的 Go 协程究竟出现了什么问题？要理解这一切，我们需要理解两个 Go 协程的主要性质。\n启动一个新的协程时，协程的调用会立即返回。与函数不同，程序控制不会去等待 Go 协程执行完毕。在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。 如果希望运行其他 Go 协程，Go 主协程必须继续运行着。如果 Go 主协程终止，则程序终止，于是其他 Go 协程也不会继续运行。 现在你应该能够理解，为何我们的 Go 协程没有运行了吧。在第 12 行调用了 go hello() 之后，程序控制没有等待 hello 协程结束，立即返回到了代码下一行，打印 main function。接着由于没有其他可执行的代码，Go 主协程终止，于是 hello 协程就没有机会运行了。\n我们现在修复这个问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func hello() { fmt.Println(\u0026#34;Hello world goroutine\u0026#34;) } func main() { go hello() time.Sleep(1 * time.Second) fmt.Println(\u0026#34;main function\u0026#34;) } 在上面程序的第 14 行，我们调用了 time 包里的 Sleep 函数，该函数会休眠执行它的 Go 协程。在这里，我们使 Go 主协程休眠了 1 秒。因此在主协程终止之前，调用 go hello() 协程就有足够的时间来执行了。该程序首先打印 Hello world goroutine，等待 1 秒钟之后，接着打印 main function。\n在 Go 主协程中使用休眠，以便等待其他协程执行完毕，这种方法只是用于理解 Go 协程如何工作的技巧。信道可用于在其他协程结束执行之前，阻塞 Go 主协程。我们会在下一教程中讨论信道。\n启动多个 Go 协程 为了更好地理解 Go 协程，我们再编写一个程序，启动多个 Go 协程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func numbers() { for i := 1; i \u0026lt;= 5; i++ { time.Sleep(250 * time.Millisecond) fmt.Printf(\u0026#34;%d \u0026#34;, i) } } func alphabets() { for i := \u0026#39;a\u0026#39;; i \u0026lt;= \u0026#39;e\u0026#39;; i++ { time.Sleep(400 * time.Millisecond) fmt.Printf(\u0026#34;%c \u0026#34;, i) } } func main() { go numbers() go alphabets() time.Sleep(3000 * time.Millisecond) fmt.Println(\u0026#34;main terminated\u0026#34;) } 在上面程序中的第 23 行和第 24 行，启动了两个 Go 协程。现在，这两个协程并发地运行。numbers 协程首先休眠 250 微秒，接着打印 1，然后再次休眠，打印 2，依此类推，一直到打印 5 结束。alphabete 协程同样打印从 a 到 e 的字母，并且每次有 400 微秒的休眠时间。 Go 主协程启动了 numbers 和 alphabete 两个 Go 协程，休眠了 3000 微秒后终止程序。\n1 1 a 2 3 b 4 c 5 d e main terminated 程序的运作如下图所示。为了更好地观看图片，请在新标签页中打开。\n第一张蓝色的图表示 numbers 协程，第二张褐红色的图表示 alphabets 协程，第三张绿色的图表示 Go 主协程，而最后一张黑色的图把以上三种协程合并了，表明程序是如何运行的。在每个方框顶部，诸如 0 ms 和 250 ms 这样的字符串表示时间（以微秒为单位）。在每个方框的底部，1、2、3 等表示输出。蓝色方框表示：250 ms 打印出 1，500 ms 打印出 2，依此类推。最后黑色方框的底部的值会是 1 a 2 3 b 4 c 5 d e main terminated，这同样也是整个程序的输出。以上图片非常直观，你可以用它来理解程序是如何运作的。\nGo 协程的介绍到此结束。感谢你的阅读。祝你过得愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/21-golang-goroutine/","tags":["Golang"],"title":"Go系列教程（二十一） | Go协程(goroutine)"},{"categories":["Go系列教程"],"contents":"Go 是并发式语言，而不是并行式语言。 在讨论 Go 如何处理并发之前，我们必须理解何为并发，以及并发与并行的区别。\n并发是什么？ 并发是指立即处理多个任务的能力。举个例子就能很好地说明这一点。\n我们可以想象一个人正在跑步。假如在他晨跑时，鞋带突然松了。于是他停下来，系一下鞋带，接下来继续跑。这个例子就是典型的并发。这个人能够一下搞定跑步和系鞋带两件事，即立即处理多个任务。\n并行是什么？并行和并发有何区别？ 并行是指同时处理多个任务。这听起来和并发差不多，但其实完全不同。\n我们同样用这个跑步的例子来帮助理解。假如这个人在慢跑时，还在用他的 iPod 听着音乐。在这里，他是在跑步的同时听音乐，也就是同时处理多个任务。这称之为并行。\n从技术上看并发和并行 通过现实中的例子，我们已经明白了什么是并发，以及并发与并行的区别。作为一名极客，我们接下来从技术的角度来考察并发和并行。🤣\n假如我们正在编写一个 web 浏览器。这个 web 浏览器有各种组件。其中两个分别是 web 页面的渲染区和从网上下载文件的下载器。假设我们已经构建好了浏览器代码，各个组件也都可以相互独立地运行（通过像 Java 里的线程，或者通过即将介绍的 Go 语言中的 Go 协程来实现）。当浏览器在单核处理器中运行时，处理器会在浏览器的两个组件间进行上下文切换。它可能在一段时间内下载文件，转而又对用户请求的 web 页面进行渲染。这就是并发。并发的进程从不同的时间点开始，分别交替运行。在这里，就是在不同的时间点开始进行下载和渲染，并相互交替运行的。\n如果该浏览器在一个多核处理器上运行，此时下载文件的组件和渲染 HTML 的组件可能会在不同的核上同时运行。这称之为并行。\n并行不一定会加快运行速度，因为并行运行的组件之间可能需要相互通信。在我们浏览器的例子里，当文件下载完成后，应当对用户进行提醒，比如弹出一个窗口。于是，在负责下载的组件和负责渲染用户界面的组件之间，就产生了通信。在并发系统上，这种通信开销很小。但在多核的并行系统上，组件间的通信开销就很高了。所以，并行不一定会加快运行速度！\nGo 对并发的支持 Go 编程语言原生支持并发。Go 使用 Go 协程（Goroutine） 和信道（Channel）来处理并发。在接下来的教程里，我们还会详细介绍它们。\n并发的介绍到此结束。请留下你的反馈和评论。感谢你的阅读。祝你过得愉快。\n","date":"2021-07-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/19/20-getting-started-with-concurrency/","tags":["Golang"],"title":"Go系列教程（二十） | 并发入门(Concurrency Getting Started)"},{"categories":["Tools"],"contents":"Wireshark 和 TShark 共享一个强大的过滤引擎，有助于消除数据包跟踪中的噪音，让您只看到您感兴趣的数据包。如果数据包满足过滤器中表达的要求，则它会显示在数据包列表中。显示过滤器让您可以将协议中的字段与特定值进行比较，将字段与字段进行比较，并检查指定的字段或协议是否存在。\n检查字段或协议是否存在 最简单的过滤器允许您检查协议或字段是否存在。如果您想查看所有包含 IP 协议的数据包，过滤器将是ip。要查看包含令牌环 RIF 字段的所有数据包，请使用tr.rif。\n将过滤器中的协议或字段视为隐式具有“存在”运算符。\n比较运算符 字段也可以与值进行比较。比较运算符可以通过类似英文的缩写或类似 C 语言的符号表示：\n1 2 3 4 5 6 7 8 运算符 描述 ——————————————————————————————————————————— eq, == (等于)Equal ne, != (不等于)Not Equal gt, \u0026gt; (大于)Greater Than lt, \u0026lt; (小于)Less Than ge, \u0026gt;= (大于等于)Greater than or Equal to le, \u0026lt;= (小于等于)Less than or Equal to 搜索和匹配操作符 其他运算符仅以英语表达，而不是类似 C 语言的语法：\n1 2 3 4 5 运算符 描述 ——————————————————————————————————————————— contains 协议、字段或切片是否包含值 matches, ~ 协议或文本字符串是否与给定匹配 不区分大小写的perl兼容正则表达式 “contains” 运算符允许过滤器搜索一系列字符，表示为字符串（带引号或不带引号），或字节，表示为字节数组，或单个字符，表示为 C 语言样式字符常量。例如，要在捕获中搜索给定的 HTTP URL，可以使用以下过滤器：\n1 http contains \u0026#34;https://www.google.com\u0026#34; “contains” 运算符不能用于原子字段，例如数字或 IP 地址。\n“matches” 或 “~” 运算符允许过滤器应用于指定的 Perl 兼容正则表达式 (PCRE)。 “matches” 操作符仅用于协议和具有文本字符串表示的协议字段。默认情况下，匹配不区分大小写。例如，要搜索给定的 HTTP Chrome User-Agent，您可以编写：\n1 http.user_agent matches \u0026#34;chrome\u0026#34; 这将匹配“chrome”、“CHROME”、“ChRome”或任何其他大小写字母组合。当然，您可以使用强制区分大小写\n1 http.user_agent matches \u0026#34;(?-i)chrome\u0026#34; 这是 PCRE (?option) 结构的一个示例。 (?-i) 执行区分大小写的模式匹配，但也可以指定其他选项。更多信息可以在 https://perldoc.perl.org/perlre.html 的 pcrepattern(3) 手册页中找到。\n功能 过滤语言有以下功能:\n1 2 3 4 5 upper(string-field) - 将字符串字段转换为大写 lower(string-field) - 将字符串字段转换为小写 len(field) - 返回字符串或bytes字段的字节长度 count(field) - 返回帧中出现的字段数 string(field) - 将非字符串字段转换为字符串 upper() 和 lower() 可用于执行不区分大小写的字符串比较。例如：\n1 2 upper(http.user_agent) matches \u0026#34;CHROME\u0026#34; lower(mysql.user) == \u0026#34;root\u0026#34; string()将字段值转换为字符串，适合与“matches”或“contains”等操作符一起使用。整数字段被转换为十进制表示。它可以用于IP/以太网地址(以及其他地址)，但不能用于字符串或字节字段。例如:\n1 string(frame.number) matches \u0026#34;[13579]$\u0026#34; 展示出所有frame为奇数的数据包。\n协议字段类型 每个协议字段都被输入。类型是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ASN.1 object identifier Boolean Character string Compiled Perl-Compatible Regular Expression (GRegex) object Date and time Ethernet or other MAC address EUI64 address Floating point (double-precision) Floating point (single-precision) Frame number Globally Unique Identifier IPv4 address IPv6 address IPX network number Label Protocol Sequence of bytes Signed integer, 1, 2, 3, 4, or 8 bytes Time offset Unsigned integer, 1, 2, 3, 4, or 8 bytes 1-byte ASCII character 整数可以用十进制、八进制或十六进制表示法表示，或者表示为 C 语言风格的字符常量。以下六个显示过滤器是等效的：\n1 2 3 4 5 6 frame.pkt_len \u0026gt; 10 frame.pkt_len \u0026gt; 012 frame.pkt_len \u0026gt; 0xa frame.pkt_len \u0026gt; \u0026#39;\\n\u0026#39; frame.pkt_len \u0026gt; \u0026#39;\\xa\u0026#39; frame.pkt_len \u0026gt; \u0026#39;\\012\u0026#39; 布尔值是真或假。在测试布尔字段值的显示过滤器表达式中，“真”表示为 1 或任何其他非零值，“假”表示为 0。例如，令牌环数据包的源路由字段是布尔值。要查找任何源路由数据包，显示过滤器将是：\n1 tr.sr == 1 可以通过以下方式找到非源路由数据包：\n1 tr.sr == 0 以太网地址和字节数组由十六进制数字表示。十六进制数字可以用冒号、句点或连字符分隔：\n1 2 3 4 eth.dst eq ff:ff:ff:ff:ff:ff aim.data == 0.1.0.d fddi.src == aa-aa-aa-aa-aa-aa echo.data == 7a IPv4 地址可以用点分十进制表示：\n1 2 ip.src == 192.168.0.105 ip.dst == 39.156.69.79 IPv4 地址可以用与数字相同的逻辑关系进行比较：eq、ne、gt、ge、lt 和 le。 IPv4 地址按主机顺序存储，因此在显示过滤器中使用 IPv4 地址时不必担心 IPv4 地址的字节序。\n无类别域间路由 (CIDR) 表示法可用于测试 IPv4 地址是否在某个子网中。例如，此显示过滤器将查找 129.111 B 类网络中的所有数据包：\n1 ip.addr == 192.168.0.0/16 IPX 网络由无符号 32 位整数表示。在测试 IPX 网络值时，您很可能会使用十六进制：\n1 ipx.src.net == 0xc0a82c00 字符串用双引号括起来:\n1 http.request.method == \u0026#34;POST\u0026#34; 在双引号内，您可以使用反斜杠嵌入双引号或以八进制或十六进制表示的任意字节。\n1 browser.comment == \u0026#34;An embedded \\\u0026#34; double-quote\u0026#34; 使用十六进制查找“HEAD”：\n1 http.request.method == \u0026#34;\\x48EAD\u0026#34; 使用八进制查找“HEAD”：\n1 http.request.method == \u0026#34;\\110EAD\u0026#34; 这意味着您必须使用双引号内的反斜杠来转义反斜杠。\n1 smb.path contains \u0026#34;\\\\\\\\SERVER\\\\SHARE\u0026#34; 在“smb.path”中查找 \\SERVER\\SHARE。\n切片操作 如果字段是文本字符串或字节数组，则您可以对字段进行切片。例如，您可以过滤以太网地址的供应商部分（前三个字节），如下所示：\n1 eth.src[0:3] == 00:00:83 另一个例子是：\n1 http.content_type[0:4] == \u0026#34;text\u0026#34; 您也可以在协议名称上使用切片运算符。 “frame”协议可能很有用，它包含 Wireshark 或 TShark 捕获的所有数据。\n1 2 3 token[0:5] ne 0.0.0.1.1 llc[0] eq aa frame[100-199] contains \u0026#34;wireshark\u0026#34; 以下语法管理切片：\n1 2 3 4 5 [i:j] i = start_offset, j = length [i-j] i = start_offset, j = end_offset, inclusive. [i] i = start_offset, length = 1 [:j] start_offset = 0, length = j [i:] start_offset = i, end_offset = end_of_field 偏移量可以是负数，在这种情况下，它们表示距字段末尾的偏移量。该字段的最后一个字节在偏移量 -1 处，最后一个字节在偏移量 -2 处，依此类推。以下是检查帧的最后四个字节的方法：\n1 2 3 frame[-4:4] == 0.1.2.3 # or frame[-4:] == 0.1.2.3 切片总是与字符串或字节序列进行比较。作为一种特殊情况，当切片只有 1 个字节宽时，您可以将其与 0xff 或更小的十六进制整数进行比较（这意味着它适合一个字节）。这对于大于一个字节的字节序列是不允许的，因为这样就需要指定多字节整数的字节序。此外，这对于十进制数是不允许的，因为它们会与已经允许作为字节字符串的十六进制数混淆。然而，单字节十六进制整数可能很方便：\n1 frame[4] == 0xff 切片可以组合。您可以使用逗号运算符连接它们：\n1 ftp[1,3-5,9:] == 01:03:04:05:09:0a:0b 这将偏移量 1、偏移量 3-5 和偏移量 9 连接到 ftp 数据的末尾。\n集合操作 只需使用成员组运算符，就可以检查字段是否与一组值匹配。例如，您可以使用以下过滤器查找常见 HTTP/HTTPS 端口上的流量：\n1 tcp.port in {80 443 8080} 以上操作等价于：\n1 tcp.port == 80 or tcp.port == 443 or tcp.port == 8080 要使用 HEAD 或 GET 方法查找 HTTP 请求：\n1 http.request.method in {\u0026#34;HEAD\u0026#34; \u0026#34;GET\u0026#34;} 这组值还可以包含范围：\n1 2 3 tcp.port in {443 4430..4434} ip.addr in {10.0.0.5 .. 10.0.0.9 192.168.1.1..192.168.1.9} frame.time_delta in {10 .. 10.5} 类型转换 如果字段是文本字符串或字节数组，则可以用最方便的方式表示。\n因此，例如，以下过滤器是等效的：\n1 2 http.request.method == \u0026#34;GET\u0026#34; http.request.method == 47.45.54 范围也可以用任何一种方式表示：\n1 2 frame[60:2] gt 50.51 frame[60:2] gt \u0026#34;PQ\u0026#34; 位域操作 也可以使用位域操作来定义测试。目前支持以下位域操作：\n1 bitwise_and, \u0026amp; Bitwise AND 按位与操作允许测试以查看是否设置了一位或多位。按位 AND 对整数协议字段和切片进行操作。\n在测试 TCP SYN 数据包时，您可以编写：\n1 tcp.flags \u0026amp; 0x02 该表达式将匹配所有包含“tcp.flags”字段且设置了 0x02 位（即 SYN 位）的数据包。\n同样，通过以下方式过滤所有 WSP GET 和扩展 GET 方法：\n1 wsp.pdu_type \u0026amp; 0x40 使用切片时，位掩码必须指定为字节字符串，并且必须与切片本身具有相同的字节数，如下所示：\n1 ip[42:2] \u0026amp; 40:ff 逻辑表达式 可以使用逻辑表达式组合测试。这些也可以用类似 C 语言的语法或类似英语的缩写来表达：\n1 2 3 4 5 运算符 描述 ——————————————————————————————————————————— and, \u0026amp;\u0026amp; 逻辑与 or, || 逻辑或 not, ! 逻辑非 表达式也可以按括号分组。以下是所有有效的显示过滤器表达式：\n1 2 3 4 tcp.port == 80 and ip.src == 192.168.2.1 not llc http and frame[100-199] contains \u0026#34;wireshark\u0026#34; (ipx.src.net == 0xbad \u0026amp;\u0026amp; ipx.src.node == 0.0.0.0.0.1) || ip 请记住，只要表达式中出现协议或字段名称，就会隐式调用“exists”运算符。 “exists”运算符具有最高优先级。这意味着第一个过滤器表达式必须读作“向我显示 tcp.port 存在且等于 80 且 ip.src 存在且等于 192.168.2.1 的数据包”。第二个过滤器表达式的意思是“向我显示不存在（llc 存在）的数据包”，或者换句话说“在 llc 不存在的地方”，因此将匹配所有不包含 llc 协议的数据包。第三个过滤器表达式包括帧中存在偏移199的约束，即帧的长度至少为200。\n对于每个数据包出现多次的字段，必须特别注意。 “ip.addr”在每个 IP 数据包中出现两次，一次用于源地址，一次用于目标地址。同样，“tr.rif.ring”字段可以在每个数据包中出现多次。以下两个表达式不等价：\n1 2 ip.addr ne 192.168.4.1 not ip.addr eq 192.168.4.1 第一个过滤器说“向我显示存在不等于 192.168.4.1 的 ip.addr 的数据包”。也就是说，只要数据包中的一个ip.addr不等于192.168.4.1，数据包就通过了显示过滤器。另一个 ip.addr 可能等于 192.168.4.1 并且数据包仍会显示。第二个过滤器说“不要向我显示任何具有等于 192.168.4.1 的 ip.addr 字段的数据包”。如果一个ip.addr是192.168.4.1，则数据包不通过。如果 ip.addr 字段都不是 192.168.4.1，则显示数据包。\n在处理多次重复字段时，很容易将 \u0026rsquo;ne\u0026rsquo; 和 \u0026rsquo;eq\u0026rsquo; 运算符视为具有隐式 “exists” 修饰符。 “ip.addr ne 192.168.4.1” 可以认为是 “存在一个不等于192.168.4.1的ip.addr”。 “not ip.addr eq 192.168.4.1”可以认为是“不存在等于192.168.4.1的ip.addr”。\n小心重复出现的字段；他们可能会令人困惑。\n使用显示过滤器从数据包跟踪中去除噪声时也必须小心。例如，如果您想过滤掉所有地址为 224.1.2.3 的 IP 多播数据包，则使用：\n1 ip.dst ne 224.1.2.3 可能太严格了。使用“ip.dst”过滤只会选择那些满足规则的 IP 数据包。不会显示任何其他数据包，包括所有非 IP 数据包。要同时显示非 IP 数据包，您可以使用以下两个表达式之一：\n1 2 not ip or ip.dst ne 224.1.2.3 not ip.addr eq 224.1.2.3 第一个过滤器使用“not ip”来包含所有非 IP 数据包，然后让“ip.dst ne 224.1.2.3”过滤掉不需要的 IP 数据包。上面已经解释了第二个过滤器，其中讨论了使用多个出现的字段进行过滤。\n特定使用场景 针对IP地址过滤 IP地址过滤可以通过 ip.addr 进行过滤，也可以通过 ip.dst 和 ip.src 进行过滤，它们之间有些区别，下面具体来看。\nip.addr 进行过滤时，源和目标IP地址只要包含时，都会被展示，具体使用方式如下\n1 2 # ip.addr eq 10.10.10.183 ip.addr == 10.10.10.183 ip.dst 进行过滤时，只展示目标IP地址匹配的数据包列表\n1 2 # ip.dst eq 10.10.10.183 ip.dst == 10.10.10.183 ip.src 进行过滤时，只展示源IP地址匹配的数据包列表\n1 2 # ip.src eq 10.10.10.183 ip.src == 10.10.10.183 针对端口过滤 针对端口过滤数据包，这个需要根据具体的传输协议及端口来过滤数据包。\n通过如下的方式，过滤TCP协议433端口数据包\n1 tcp.port == 433 通过如下的方式，过滤UDP协议9408端口数据包\n1 udp.port == 9408 通过如下的方式，过滤DNS协议数据包\n1 dns 针对长度和内容过滤 1 udp.lenght \u0026lt; 30 针对数据包内容过滤 针对HTTP请求方法类型过滤 下面这条表达式意为，过滤HTTP请求类型是POST，并且目标IP地址是118.186.60.194的数据包。\n1 http.request.method == \u0026#34;POST\u0026#34; \u0026amp;\u0026amp; ip.dst == 118.186.60.194 相关参考 显示过滤器的整个列表太大，无法在此处列出。您可以在以下位置找到参考资料和示例：\n在线显示过滤器参考：https://www.wireshark.org/docs/dfref/。 帮助：Wireshark 中支持的协议。 tshark -G 命令行中的字段。 Wireshark 维基：https://gitlab.com/wireshark/wireshark/-/wikis/D​​isplayFilters ","date":"2021-07-13","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/13/wireshark-related-use/","tags":["wireshark","filter"],"title":"Wireshark文档 | Wireshark 过滤器"},{"categories":["Linux"],"contents":"Git 大文件存储 (LFS) 使用 Git 内部的文本指针替换音频样本、视频、数据集和图形等大文件，同时将文件内容存储在 GitHub.com 或 GitHub Enterprise 等远程服务器上。\n1 $ curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash 执行这个命令将会自动为您系统添加YUM源，具体的安装过程如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Detected operating system as centos/7. Checking for curl... Detected curl... Downloading repository file: https://packagecloud.io/install/repositories/github/git-lfs/config_file.repo?os=centos\u0026amp;dist=7\u0026amp;source=script done. Installing pygpgme to verify GPG signatures... Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirrors.huaweicloud.com * extras: mirrors.huaweicloud.com * updates: mirrors.huaweicloud.com github_git-lfs-source/signature | 833 B 00:00:00 github_git-lfs-source/signature | 1.0 kB 00:00:00 !!! Package pygpgme-0.3-9.el7.x86_64 already installed and latest version Nothing to do Installing yum-utils... Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * base: mirrors.huaweicloud.com * extras: mirrors.huaweicloud.com * updates: mirrors.huaweicloud.com Package yum-utils-1.1.31-54.el7_8.noarch already installed and latest version Nothing to do Generating yum cache for github_git-lfs... Generating yum cache for github_git-lfs-source... The repository is setup! You can now install packages. 接下来就可以使用 YUM 命令进行安装 GIT LFS啦，可以以下命令进行安装\n1 $ yum install -y git-lfs 执行以下命令，拉取远程仓库大文件\n1 $ git lfs pull ","date":"2021-07-07","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/07/centos7-install-git-lfs/","tags":["CentOS","git-lfs"],"title":"CentOS7 安装 Git LFS"},{"categories":["Docker"],"contents":"要在 CentOS 上开始使用 Docker Engine，请确保满足先决条件，然后安装 Docker。\n先决条件 操作系统要求 要安装 Docker 引擎，您需要 CentOS 7 或 8 的维护版本。不支持或测试存档版本。 必须启用 centos-extras 储存库。默认情况下启用此存储库，但如果您已禁用它，则需要重新启用它。 推荐使用 overlay2 存储驱动。 卸载旧版本 旧版本的 Docker 被称为 docker 或 docker-engine。如果安装了这些，请卸载它们以及相关的依赖项。\n1 2 3 4 5 6 7 8 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 如果yum报告没有安装这些软件包，这是可以的。\n保留/var/lib/docker/的内容，包括图像、容器、卷和网络。 Docker Engine 包现在称为 docker-ce。\n安装方法 您可以根据需要以不同方式安装 Docker Engine：\n大多数用户设置 Docker 的存储库并从中安装，以便于安装和升级任务。这是推荐的方法。 一些用户下载 RPM 包并手动安装并完全手动管理升级。这在诸如在无法访问互联网的情况下在操作系统上安装 Docker 等情况下非常有用。 在测试和开发环境中，一些用户选择使用自动化的便捷脚本来安装 Docker。 方式一、使用存储库安装 在新主机上首次安装 Docker Engine 之前，您需要设置 Docker 存储库。之后，您可以从存储库安装和更新 Docker。\n设置存储库 安装 yum-utils 包（提供 yum-config-manager 实用程序）并设置稳定存储库。\n1 2 3 4 5 $ sudo yum install -y yum-utils $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 可选：启用夜间或测试存储库\n这些存储库包含在上面的 docker.repo 文件中，但默认情况下是禁用的。您可以在稳定存储库旁边启用它们。以下命令启用夜间存储库。\n1 $ sudo yum-config-manager --enable docker-ce-nightly 要启用测试通道，请运行以下命令：\n1 $ sudo yum-config-manager --enable docker-ce-test 您可以通过运行带有 --disable 标志的 yum-config-manager 命令来禁用夜间或测试存储库。要重新启用它，请使用 --enable 标志。以下命令禁用夜间存储库。\n1 $ sudo yum-config-manager --disable docker-ce-nightly 了解夜间频道和测试频道的更新细节\n安装 Docker 引擎 1.安装最新版本的 Docker Engine 和 containerd，或者参考官方安装特定版本：\n1 $ sudo yum install docker-ce docker-ce-cli containerd.io Docker 已安装但未启动。 docker 组已创建，但没有用户添加到组中。\n3.启动 Docker。\n1 $ sudo systemctl start docker 4.通过运行 hello-world 映像验证 Docker Engine 是否已正确安装。\n1 $ sudo docker run hello-world 方式二、从RPM包安装Docker 如果您无法使用 Docker 的存储库来安装 Docker，您可以为您的版本下载 .rpm 文件并手动安装。每次要升级 Docker Engine 时都需要下载一个新文件。\nStep1、前往 https://download.docker.com/linux/centos/ 并选择您的 CentOS 版本。然后浏览到 x86_64/stable/Packages/ 并下载要安装的 Docker 版本的 .rpm 文件。\n注意：要安装 nightly 或 test（预发布）包，请将上述 URL 中的单词 stable 更改为 nightly 或 test。了解夜间频道和测试频道。\nStep2、安装 Docker Engine，将下面的路径更改为您下载 Docker 包的路径。\n1 $ sudo yum install /path/to/package.rpm Docker 已安装但未启动。 docker 组已创建，但没有用户添加到组中。\nStep3、启动Docker\n1 $ sudo systemctl start docker Step4、通过运行 hello-world 映像验证 Docker Engine 是否已正确安装。\n1 $ sudo docker run hello-world 卸载 Docker 引擎 Step1、首先，卸载 Docker Engine、CLI 和 Containerd 包\n1 $ sudo yum remove docker-ce docker-ce-cli containerd.io Step2、主机上的镜像、容器、卷或自定义配置文件不会自动删除。删除所有镜像、容器和卷：\n1 2 $ sudo rm -rf /var/lib/docker $ sudo rm -rf /var/lib/containerd 您必须手动删除任何已编辑的配置文件。\n","date":"2021-07-05","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/05/centos-install-docker/","tags":["Linux","CentOS"],"title":"CentOS7 安装 Docker"},{"categories":["MYSQL"],"contents":"为应用程序创建特定的用户特定的数据库，不要直接使用root用户直接在应用程序中执行数据库操作，如果条件允许请将root用户设置为禁止远程登录，以提高系统的安全性，通常情况下，在开发或测试时可以将环境中的MYSQL设置为允许远程登录，以提高开发或上线效率，生产环境下是严禁MYSQL数据库远程登录的，应用程序应该通过内部网络进行通信完成数据的相关操作。特定的用户只对特定数据库有权限，退一万步讲，即使特定用户的密码被破解，也不会对同一节点下的数据库造成什么影响，还有千万不要使用弱口令，下文中的 @@helloworld@@ 是演示说明使用，可以忽略不计~\nStep1.以root用户登录MYSQL 1 2 3 4 5 6 7 8 9 10 11 12 13 $ mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 16 Server version: 8.0.23 MySQL Community Server - GPL Copyright (c) 2000, 2021, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. Step2.选择mysql数据库 使用 use 选择 mysql 数据库。\n1 2 3 4 5 mysql\u0026gt; use mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed Step3.创建用户并设定密码 创建一个用户名为 gitea 的用户，并且设置密码为 helloworld 。请注意这里的百分号 % 是允许 gitea 用户远程登录。如果不想允许 gitea 用户远程登录请将百分号 % 替换为 localhost 或 127.0.0.1。\n1 2 mysql\u0026gt; create user \u0026#39;gitea\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;helloworld\u0026#39;; Query OK, 0 rows affected (0.01 sec) Step4.为用户创建数据库 这里假定要为这个 gitea 用户，指定一个专属的数据库进行数据的存储，如 gitea，不要搞混了，这里的数据库名也为 gitea，即 gitea 用户，只能操作 gitea 数据库，执行下面的语句进行创建：\n1 2 mysql\u0026gt; create database if not exists gitea; Query OK, 1 row affected (0.00 sec) Step5.为用户创建操作数据库所有权限 这里为 gitea 用户，指定操作 gitea 数据库的全部权限。更多权限的细化设置请参考 grant 命令。\n1 2 mysql\u0026gt; grant all on gitea.* to \u0026#39;gitea\u0026#39;@\u0026#39;%\u0026#39;; Query OK, 0 rows affected (0.01 sec) 退出登录。添加用户并赋于操作某个数据库权限已完成，可以使用新创建的用户登录进行验证。\nStep6.退出root用户 1 2 mysql\u0026gt; exit Bye Step7.使用新用户gitea登录MSYQL 1 2 3 4 5 6 7 8 9 10 11 12 13 $ mysql -u gitea -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 17 Server version: 8.0.23 MySQL Community Server - GPL Copyright (c) 2000, 2021, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. Step8.查看所有数据库 1 2 3 4 5 6 7 8 mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | gitea | | information_schema | +--------------------+ 2 rows in set (0.00 sec) Step9.查看所有权限 1 2 3 4 5 6 7 8 mysql\u0026gt; show grants for gitea; +--------------------------------------------------+ | Grants for gitea@% | +--------------------------------------------------+ | GRANT USAGE ON *.* TO `gitea`@`%` | | GRANT ALL PRIVILEGES ON `gitea`.* TO `gitea`@`%` | +--------------------------------------------------+ 2 rows in set (0.00 sec) ","date":"2021-07-03","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/03/mysql-creates-a-new-user-and-grants-permissions/","tags":["user","permissions"],"title":"MYSQL创建新用户并赋于权限"},{"categories":["Docker"],"contents":"Gitea是一个开源软件包，用于托管使用Git以及其他协作特性(如bug跟踪、wiki和代码审查)的软件开发版本控制。它支持自托管，但也提供一个免费的公共第一方实例托管在滴滴的中国云，它是Gogs的分支，Gitea使用Go语言编写，可以托管在Go支持的所有平台上，包括Linux、macOS和Windows。项目由Open Collective资助。以上来自维基百科\n建立一个管理Gitea服务的项目 项目目录结构如下：\n1 2 3 4 5 $ tree ├── docker-compose.yaml └── etc ├── localtime └── timezone 项目目录正如你所见是不是特别的简单呀！有一个docker-compose.yaml文件和一个etc目录，docker-compose.yaml这个文件是定义具体的容器服务，而etc目录则是为了保障容器环境时区为北京时间，添加的两个文件配置文件，localtime文件是拷贝于我本机Mac，而timezone是我手动添加的，这个timezone文件的具体内容为Asia/Shanghai，这个可以根据你的国家进行设置。\ndocker-compose.yaml 这个docker-compose.yaml是docker compose工具在运行容器服务时默认加载的配置文件，当然你也可以是其它的文件名，不过还是使用官方的建立吧，就叫docker-compose.yaml，遵守规则还是很有必要的，会省去很多麻烦，如果你非得不叫这个文件名，你在使用docker-compose运行容器服务时要指明配置文件。再来说一下何为docker compose? 说白了它就是对一组容器统一管理，而不用单个的运行容器，可以使用build、up、down来快速的管理容器服务，当然还有其它的一些命令，常用的就这几个，具体可以参数官方文档进行更深入的了解。这个文件定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 version: \u0026#34;3.6\u0026#34; services: gitea-server: image: gitea/gitea:latest container_name: wmx-gitea-server environment: - USER_UID=1000 - USER_GID=1000 - DB_TYPE=mysql - DB_HOST=db-server:3306 - DB_NAME=gitea - DB_USER=gitea - DB_PASSWD=helloworld restart: always networks: - gitea - externals volumes: - /usr/local/data/docker/gitea:/data - ./etc/timezone:/etc/timezone:ro - ./etc/localtime:/etc/localtime:ro ports: - \u0026#34;22:22\u0026#34; networks: gitea: driver: bridge externals: external: true 这个文件特别简单，需要特别注意的是DB_HOST=db-server:3306这个环境变量，还有networks中定义的externals外部网络，当前这个docker-compose.yaml中定义的gitea-server服务，要想访问容器环境中的另外容器服务，必须让这个两个容器在同一外部网络内(当然容器之间的链接还其它方式)，这里是externals，db-server这个容器服务是我在另外一个单独的容器管理项目中定义的(用于单独的管理MYSQL容器服务)，他们都在externals外部网络内。对于这个文件需要特别说明一点，当容器服务在宿主主机或外部网络不需要使用的时候不需要指定容器端口号与宿主主机端口关联操作，容器与容器之间的服务访问只需要在同一外部网络内，然后指定相应的服务名加端口号进行链接，即可实现我们的需求，具体的用于单独管理MYSQL容器服务的docker-compose.yaml文件定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 version: \u0026#34;3.6\u0026#34; services: db-server: image: mysql:8.0 container_name: wmx-db-server restart: always environment: - MYSQL_ROOT_PASSWORD=helloworld networks: - dbnet - externals volumes: - /usr/local/data/docker/mysql/8.0:/var/lib/mysql - ./etc/timezone:/etc/timezone:ro - ./etc/localtime:/etc/localtime:ro ports: - \u0026#34;3308:3306\u0026#34; networks: dbnet: driver: bridge externals: external: true 你可以参数我的另一博文《Docker下如何优雅的管理你的NGINX》来了解更多的docker-compose.yaml文件定义。\n建立MYSQL用户及数据库 建议为你的每一个应用创建单独的用户及数组库，不要使用root用户，权限太大，在你的宿主主机上连接到MYSQL容器服务进行操作，如果你觉得在远程服务器命令行操作实在不方便，你可以在本地使用MYSQL管理工具连接到远程MYSQL容器服务，如Navicat，当然如果你使用的是阿里云ECS服务器，你需要先将3308端口添加到安全组，要不然姜子牙再生他也帮你连接不成功远程ECS服务器中的MYSQL容器服务，还有就是你还需要将3308添加到防火墙对外开放，才可以(如何开放端口可以参考我的另一博文《CentOS7开放端口号》)。图形化操作应该不是问题吧！\n创建容器挂载数据目录 你在上面的docker-compose.yaml文件中也看到了，在定义gitea-server服务时指定了数据卷挂载/usr/local/data/docker/gitea:/data操作，这个宿主主机/usr/local/data/docker/gitea目录，你可以随意创建任何位置便于管理即可，说一下这里为什么不用数据卷容器，而直接指定其宿主主机目录位置，不用再多一个环节创建数据卷容器，少了中间一层，主要是方便，还需要明确一点，挂载宿主主机目录到容器的目的是什么? 是不是想让容器产生的数据关联到宿主主机也就是数据持久性保存，而不至于容器干掉了，数据也丢失了，目的达到了也就可以了，不要把问题复杂化。\n1 $ mkdir -p /usr/local/data/docker/gitea 使用docker compose运行容器服务 这里还是需要强调一下，什么时候使用build命令，什么时候使用up命令，好多小伙伴分不清，build命令是在你的docker-compose.yaml文件中指定了服务需要构建镜像时(定义服务时有build: \u0026quot;.\u0026quot;或build: \u0026quot;./config\u0026quot;之类的)，才需要使用先使用docker-compose build 来构建镜像，之后再使用docker-compose up 来启动容器服务，当然你也可以直接docker-compose up它会先构建镜像然后再启动容器服务。如果在你的docker-compose.yaml文件中定义服务时直接使用了第三方镜像如上面的image: gitea/gitea:latest，这时你使用docker-compose build它会直接跳过，为什么呢? Docker Compose 工具会检测你这个docker-compose.yaml文件定义，它一看gitea-server这个服务定义使用的是镜像，直接跳过并提示db-server uses an image, skipping，docker-compose build它会依赖容器服务定义中的build: \u0026quot;.\u0026quot;指定目录中的Dockerfile文件，以Dockerfile定义来构建服务所要使用到的镜像。直接了当地说，build先构建镜像，而up使用镜像启动容器服务，就是这么简单。\n1 $ docker-compose up -d -d参数是后台启动对吧，跟你在启动单个容器时执行的docker run -d ....是一样的。后台启动这个服务守护进程！\n建立二级域名NGINX反向代理 在我的另一博客《Docker下如何优雅的管理你的NGINX》已经有介绍，可以参考一下！现在只需要在NGINX容器服务单独管理项目(docker-nginx)中添加一个的config/ss/git.wumoxi.com.conf文件即可，这个文件定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 server { listen 443 ssl; server_name git.wumoxi.com; # SSL signature. ssl_certificate /etc/nginx/ca/git.wumoxi.com/cert.pem; ssl_certificate_key /etc/nginx/ca/git.wumoxi.com/cert.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; # Http response body max size. client_max_body_size 8m; # Proxy application backend api service. location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://gitea-server:3000/; } location ~ /\\.ht { deny all; } } server { listen 80; server_name git.wumoxi.com; rewrite ^(.*) http://$host$1 permanent; } 注意了，这里最主要的是反向代理proxy_pass http://gitea-server:3000/;，上面已经强调过了gitea-server这个服务必须和(docker-nginx中定义的服务)nginx-server是在同一外部网络内。重新启动NGINX容器服务，在项目目录下直接执行docker-compose build构建镜像(因为有自定义Dockerfile存在)，然后使用docker-compose down将之前的容器服务先停掉，再执行docker-compose up -d 即可！这个二级域名为git.wumoxi.com。\n使用浏览器访问Gitea服务 输入二级域名git.wumoxi.com访问Gitea服务，结果如下所示：\n不错嘛，可以访问了，是不是距离成功又进了一步。\n安装Gitea服务 刚刚访问首页预览成功，你点点看嘛，是不是直接跳转取了安装页面，如下所示：\n数据库设置 数据库设置这里，基本上不用改动，这些信息是Gitea读取到上面的docker-compose.yaml文件配置的容器环境变量，只需要将字符集改为utf8mb4，因为当前所使用的MYSQL版本是8.0，8.0默认字符集就是utf8mb4，并且校对集为utf8mb4_0900_ai_ci；\n1 2 3 4 5 6 7 mysql\u0026gt; SHOW CREATE DATABASE gitea; +----------+---------------------------------------------------------------------------------------------------------------------------------+ | Database | Create Database | +----------+---------------------------------------------------------------------------------------------------------------------------------+ | gitea | CREATE DATABASE `gitea` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION=\u0026#39;N\u0026#39; */ | +----------+---------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.01 sec) 一般设置 字段 值 站点名称 你可以指定一个站点描述信息 仓库根目录 不用动，默认就好 LFS根目录 不用动，默认就好 以用户名运行 默认git就可以不用动 SSH 服务域名 如: git.wumoxi.com SSH 服务端口 默认22不用动 HTTP 服务端口 要修改为 80 或 443 Gitea 基本 URL 如：http://git.wumoxi.com/ 日志路径 不用动，默认就好 可选设置(Gitea邮件服务) 字段 值 SMTP 主机 如果你使用的foxmail: 如：smtp.qq.com:465，如果你使用其它的邮箱服务请勿必将SMTP地址设置正确 电子邮件发件人 发送邮件的发件人名称(经过测试它必须是一个邮箱地址)：如：example@foxmail.com SMTP 用户名 发送邮件的邮箱地址：如：example@foxmail.com SMTP 密码 如果使用Foxmail请生成授权码，如: hello-world-email-secret 需要发电子邮件确认注册 勾选 启用邮件通知提醒 勾选 这样就可以了，它会是Gitea服务发送邮件的默认邮箱。下面是全部配置如：\n安装Gitea应用 这里要说一下，当你点击立即安装时，Gitea会初始化数据库(主要是生成数据表)、Gitea服务生成应用配置文件(你可以到你指定的挂载目录/usr/local/data/docker/gitea去查看)，然后跳转到用户登录页面，如下所示：\n创建hello-world仓库走流程 注册用户 需要注意了，第一个注册的用户将会成为管理员。注册成功之后会自动登录。\n创建仓库 注意，勾选初始化存储库(添加.gitignore、许可证和自述文件)，你好歹也让它有点文件！\n修改提交 将README.md文件内容从hello-world修改为hello-world-change-online, 直接提交变更。\n咦~不好了吧，提交不成功，可以看到它调用了http://localhost:443/api/internal/hook/pre-receive/wumoxi/hello-world这个地址，那就是gitea-server这个服务有问题，什么问题呢？从官网这里可以找到答案！\n1 注意：如果在http上使用非3000端口，请将app.ini更改为match LOCAL_ROOT_URL = http://localhost:3000/。 有了这一句解释之后就可以打开/usr/local/data/docker/gitea/gitea/conf/app.ini配置文件在[server]配置区块中加入LOCAL_ROOT_URL = http://localhost:3000/：\n1 2 [server] LOCAL_ROOT_URL = http://localhost:3000/ 修改这个配置文件之后，再次提交，即可提交成功！\n克隆到本地做修改测试(HTTPS方式) 克隆\n1 2 3 4 5 6 7 $ git clone http://git.wumoxi.com/wumoxi/hello-world.git Cloning into \u0026#39;hello-world\u0026#39;... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (2/2), done. remote: Total 6 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (6/6), done. 修改提交\n1 2 3 4 5 6 7 8 $ git push origin master Counting objects: 3, done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: . Processing 1 references remote: Processed 1 references in total To http://git.wumoxi.com/wumoxi/hello-world.git 3e66c6b..507fb76 master -\u0026gt; master 正如上面所见，因为是公有项目，无需添加SSH公私即可克隆和提交代码，注意哦，上面是通过HTTPS方式，而非SSH，试试SSH方式如何！\n克隆到本地做修改测试(SSH方式) 将仓库修改为私有，添加SSH公钥到你注册的账号，进行仓库克隆操作。\n克隆\n1 2 3 4 5 6 7 $ git clone git@git.wumoxi.com:wumoxi/hello-world.git Cloning into \u0026#39;hello-world\u0026#39;... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (2/2), done. remote: Total 6 (delta 0), reused 0 (delta 0) Receiving objects: 100% (6/6), done. 修改提交\n1 2 3 4 5 6 7 8 $ git push origin master Counting objects: 3, done. Writing objects: 100% (3/3), 293 bytes | 293.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: . Processing 1 references remote: Processed 1 references in total To git.wumoxi.com:wumoxi/hello-world.git 6a56230..f13019d master -\u0026gt; master 经过上面的简单测试HTTPS和SSH方式可都完成项目的版本操作，特别说明一下我的服务器SSH端口号非标准22，而让这个Gitea服务使用标准的SSH端口号22，这样很容易配置。这样在仓库的SSH链接上也不会有很难看的端口号。其它方面的安全问题，你动手都测试一下做到相对安全。就是这个样子简单吧！\n","date":"2021-07-03","image":null,"permalink":"https://shaichunfeng.com/post/2021/07/03/docker-environment-builds-the-gitea-repository-service/","tags":["gitea","git","repository"],"title":"Docker环境构建Gitea版本库服务"},{"categories":["Git"],"contents":"项目中包含大上件时\n推送已有项目到新仓库时报错 1 2 3 4 5 6 7 8 9 10 11 12 $ git push -u origin master 枚举对象中: 1585, 完成. 对象计数中: 100% (1585/1585), 完成. 使用 4 个线程进行压缩 压缩对象中: 100% (1466/1466), 完成. 写入对象中: 100% (1585/1585), 13.66 MiB | 6.49 MiB/s, 完成. 总共 1585（差异 667），复用 0（差异 0），包复用 0 remote: Resolving deltas: 100% (667/667), done. remote: GitLab: LFS objects are missing. Ensure LFS is properly set up or try a manual \u0026#34;git lfs push --all\u0026#34;. To ssh://git.hello.org/hello.git ! [remote rejected] master -\u0026gt; master (pre-receive hook declined) error: 推送一些引用到 \u0026#39;ssh://git.hello.org/hello.git\u0026#39; 失败 遇到这种问题首先要进行大文件的推送，然后再进行分支的推送。\n1 2 $ git lfs ls-files -l | awk \u0026#39;{ print $1 }\u0026#39; | xargs git lfs push --object-id origin Uploading LFS objects: 100% (1/1), 64 MB | 11 MB/s, done. 1 2 3 4 5 6 7 8 9 10 11 $ git push -u origin master 枚举对象中: 1585, 完成. 对象计数中: 100% (1585/1585), 完成. 使用 4 个线程进行压缩 压缩对象中: 100% (1466/1466), 完成. 写入对象中: 100% (1585/1585), 13.66 MiB | 6.45 MiB/s, 完成. 总共 1585（差异 665），复用 0（差异 0），包复用 0 remote: Resolving deltas: 100% (665/665), done. To ssh://git.hello.org/hello.git * [new branch] master -\u0026gt; master 分支 \u0026#39;master\u0026#39; 设置为跟踪来自 \u0026#39;origin\u0026#39; 的远程分支 \u0026#39;master\u0026#39;。 ","date":"2021-06-28","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/28/git-push-contain-lsf-file/","tags":["shell","wc"],"title":"Git 推送LSF（大文件）到远程"},{"categories":["Tool"],"contents":"FreeRDP是一个远程桌面协议(RDP)的实现，开源免费软件，在Apache许可下发布。要在MacOS系统下安装使用还是有些特别需要注意的地方，记录一下在Mac系统的安装具体步骤方便遇到类似问题的开发者进行参考。\nSection1.安装openssl并配置环境变量 如果没有安装openssl请打开 terminal 或 item2 （以下统称终端）执行以下brew命令安装：\n1 $ brew install openssl 配置openssl库包配置路径环境变量 编辑 ~/.bashrc 或 ~/.zshrc 配置文件，导出PKG_CONFIG_PATH环境变量，具体如下：\n1 export PKG_CONFIG_PATH=$(brew --prefix)/opt/openssl/lib/pkgconfig 保存之后要记得source一下配置文件，否则在当前终端下不生效：\n1 $ source ~/.bashrc // 或 source ~/.zshrc Section2.安装X11及配置环境变量 在终端下执行如下命令，安装xquartz(X11)：\n1 $ brew install xquartz 设置X11的环境变量 在/tmp/com.apple.launchd.XXXXX目录下找到包含 org.xquartz:0 文件的具体路径。\n1 2 $ ls /tmp/com.apple.launchd.7M2pVCoBMU/org.xquartz:0 /tmp/com.apple.launchd.7M2pVCoBMU/org.xquartz:0 将这个路径添加到 ~/.bashrc 或 ~/.zshrc 配置文件，具体如下：\n1 export DISPLAY=/private/tmp/com.apple.launchd.7M2pVCoBMU/org.xquartz:0 保存之后记得source一下，不然在当前终端下不生效。\n1 $ source ~/.bashrc // 或 source ~/.zshrc Section3.安装FreeRDP FreeRDP项目网址为https://www.freerdp.com/，请点击链接打开项目官网。\n打开后直接点击 Download Now! 进入下载页面，可以看到MacOS下安装FreeRDP，官方推荐使用 brew 进行安装，在终端下执行如下命令安装：\n1 $ brew install freerdp 连接远程桌面 成功安装freerdp工具后可以在终端下通过命令连接到远程Windows桌面。注意：Windows系统必须要打开允许远程协助功能，也可是开启3389端口，否则连接不成功！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ xfreerdp /v:192.168.1.3:3389 /w:1520 /h:820 /u:PC +wallpaper /sec-rdp /sound +glyph-cache [12:18:45:473] [83501:0e2fc000] [INFO][com.freerdp.core] - freerdp_connect:freerdp_set_last_error_ex resetting error state [12:18:45:473] [83501:0e2fc000] [INFO][com.freerdp.client.common.cmdline] - loading channelEx rdpdr [12:18:45:473] [83501:0e2fc000] [INFO][com.freerdp.client.common.cmdline] - loading channelEx rdpsnd [12:18:45:473] [83501:0e2fc000] [INFO][com.freerdp.client.common.cmdline] - loading channelEx cliprdr [12:18:45:473] [83501:0e2fc000] [INFO][com.freerdp.client.common.cmdline] - loading channelEx drdynvc [12:18:45:492] [83501:0e2fc000] [INFO][com.freerdp.client.x11] - Property 352 does not exist [12:18:45:828] [83501:0e2fc000] [INFO][com.freerdp.primitives] - primitives autodetect, using optimized [12:18:45:833] [83501:0e2fc000] [INFO][com.freerdp.core] - freerdp_tcp_is_hostname_resolvable:freerdp_set_last_error_ex resetting error state [12:18:45:833] [83501:0e2fc000] [INFO][com.freerdp.core] - freerdp_tcp_connect:freerdp_set_last_error_ex resetting error state [12:18:45:920] [83501:0e2fc000] [WARN][com.freerdp.crypto] - Certificate verification failure \u0026#39;self signed certificate (18)\u0026#39; at stack position 0 [12:18:45:920] [83501:0e2fc000] [WARN][com.freerdp.crypto] - CN = DESKTOP-6KIP342 Password: [12:18:51:547] [83501:0e2fc000] [INFO][com.freerdp.gdi] - Local framebuffer format PIXEL_FORMAT_BGRX32 [12:18:51:547] [83501:0e2fc000] [INFO][com.freerdp.gdi] - Remote framebuffer format PIXEL_FORMAT_RGB16 [12:18:51:562] [83501:0e2fc000] [INFO][com.winpr.clipboard] - initialized POSIX local file subsystem [12:18:51:751] [83501:0e2fc000] [INFO][com.freerdp.channels.rdpsnd.client] - [static] Loaded mac backend for rdpsnd [12:18:51:751] [83501:0e2fc000] [INFO][com.freerdp.channels.drdynvc.client] - Loading Dynamic Virtual Channel rdpsnd [12:18:52:415] [83501:0e9a3000] [INFO][com.freerdp.channels.rdpsnd.client] - [dynamic] Loaded mac backend for rdpsnd [12:18:57:626] [83501:0e2fc000] [INFO][com.freerdp.core] - rdp_set_error_info:freerdp_set_last_error_ex resetting error state [12:18:57:689] [83501:0e9a3000] [INFO][com.freerdp.channels.rdpsnd.client] - [dynamic] Loaded mac backend for rdpsnd 注意/size:\u0026quot;1520x820\u0026quot;这个参数及值，它可以是这种方式设置本地桌面显示远程桌面的大小，还可以通过 /w:1520 或 /h:820 这种宽和高的方式指定。可以看到指定了一堆的参数，以下是这些具体的参数说明：\n/v:IP:PORT: 要连接的远程Windows电脑IP和端口号。 /size:\u0026quot;1520x820\u0026quot;: 设置连接成功后展示的远程桌面的窗口大小。 /u:USERNAME: 要连接到远程Windows电脑的用户名。 +wallpaper: 使用远程桌面壁纸。 /sec-rdp: 关闭RDP协议安全性。 /sound: 指定远程连接成功后可以接收到音频输出。 +glyph-cache: 开启Glyph缓存。 这些只是使用了一部分，更多FreeRDP命令行接口参数可以参考项目官方GithubWiki页面。\n上面的启动过程也一并帖出来了，在加载到 Password: 时提示您输入远程Windows电脑的密码，输入密码后会启动 X11 并载入远程桌面：\n这个时间你就可以远程操作连接到的Window系统了，它有很多功能，你可以去具体学习一下，如通过调用功能函数库实现不使用密码截图远程登录界面等等吧~\n参考: capture screen with scrot and remote to Windows with freerdp ","date":"2021-06-23","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/23/mac-use-freerdp/","tags":["FreeRDP","Windows","Screenshot"],"title":"Mac下使用FreeRDP"},{"categories":["Golang"],"contents":"Go 语言除了语法精炼、并发支持好外，还有一个优点就是可以调用 C 代码。可以直接在 Go 源代码里写 C 代码，也可以引 C 语言的外部库。这样在性能遇到瓶颈的地方可以重写，或者某些功能 Go 和第三方还缺失，但 C 语言有现成的库就可以直接用了。官方 Cgo 这块目前有一篇博客 https://blog.golang.org/c-go-cgo 和 命令行文档 https://golang.org/cmd/cgo/ 对 Cgo 进行了说明，其中某些地方还不够明确或者没有提到的地方。\nSection1：Go语言内联C语言代码 下面例子是直接将 C 代码内嵌在 Go 源代码里，引入了一个不存在的包 “C”, 然后将 C 代码写在了引入上面，注意只能写在 “C” 包上面。这里定义了一个sum函数, 然后通过 C.sum 在 Go 代码里使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main /* 内联C语言代码 Start */ // // sum calc a and b sum value. // int sum(int a, int b) { // return a + b; // } import \u0026#34;C\u0026#34; /* 内联C语言代码 End */ import ( \u0026#34;fmt\u0026#34; ) func main() { cA := C.int(1) cB := C.int(2) sum := C.sum(cA, cB) fmt.Printf(\u0026#34;sum value: %+v\\n\u0026#34;, sum) } 运行一下这个简单的程序，会得到如下执行结果：\n1 2 $ go run main.go sum value: 3 Section2：Go语言调用独立的C语言源代码 小巧的 C 语言代码可以方便的通过内联使用，但是代码比较庞大的话可以将 C 语言代码独立编码为包。下面将上面内嵌的C语言代码定义为相应的源文件，当前目录如下：\n1 2 3 4 5 $ ll example total 24 -rw-r--r-- 1 helloshaohua staff 229B Jun 21 18:11 main.go -rw-r--r-- 1 helloshaohua staff 64B Jun 21 16:33 simple_sum.c -rw-r--r-- 1 helloshaohua staff 39B Jun 21 18:13 simple_sum.h C语言simple_sum.h头文件 simple_sum.h文件，具体代码如下：\n1 2 // sum 函数签名. int sum(int, int); C语言simple_sum.c源文件 simple_sum.c文件，具体代码如下：\n1 2 3 4 // sum 函数定义. int sum(int a, int b) { return a + b; } Go语言main.go源文件 main.go文件，具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main /* 调用独立的C语言源代码 Start */ // #include \u0026#34;simple_sum.h\u0026#34; import \u0026#34;C\u0026#34; /* 调用独立的C语言源代码 End */ import \u0026#34;fmt\u0026#34; func main() { cA := C.int(1) cB := C.int(2) sum := C.sum(cA, cB) fmt.Printf(\u0026#34;sum value: %v\\n\u0026#34;, sum) } 当前示例将 Section1：Go语言内联C语言代码 部分中内嵌C语言代码，拆分为独立的C语言文件 simple_sum.h 和 simple_sum.c 。Go语言源文件代码只需要将 simple_sum.h 头文件引入，即可调用C语言定义的 sum 函数。需要注意的是，main包引用多个文件后就不能再直接使用go run命令直接运行了，需要使用go build命令先对其编译，然后通过执行编译后的可执行文件来运行。go build会检测cgo引用的文件，以 .h 和 .c 为扩展名的C语言源文件也会一起被编译。\n1 2 $ go build -o ./example/simple_sum ./example \u0026amp;\u0026amp; ./example/simple_sum sum value: 3 Section3：Go语言调用C语言外部库 将 Section2：Go语言调用独立的C语言源代码 部分的C语言源代码重新组织为C语言功能库，具体目录结构如下：\n1 2 3 4 5 6 $ tree -L 2 example example ├── main.go └── simple ├── sum.c └── sum.h 其中simple目录就一个整合后的C语言外部库，C语言simple/sum.h、simple/sum.c源文件分别对应 Section2：Go语言调用独立的C语言源代码 部分中的 simple_sum.h、simple_sum.c 源文件，代码和之前一样，只是整合到了simple目录，目的是强制让Go语言不编译它。\n假定simple目录就是Go程序需要用到的C语言外部库，先编译静态库，在simple目录下生成libsimplesum.a静态链接库文件。\n编译C语言外部库simple。\n1 $ gcc -c example/simple/sum.c -o example/simple/sum.o 生成C语言动态链接库。\n1 $ ar -rv example/simple/libsimplesum.a example/simple/sum.o 生成静态链接库后的目录结构如下：\n1 2 3 4 5 6 7 8 $ tree -L 2 example example ├── main.go └── simple ├── libsimplesum.a ├── sum.c ├── sum.h └── sum.o 具体的main.go文件，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main /* Go语言调用C语言外部库 Start */ // #cgo CFLAGS: -I./simple // #cgo LDFLAGS: -L./simple -lsimplesum // #include \u0026#34;sum.h\u0026#34; import \u0026#34;C\u0026#34; /* Go语言调用C语言外部库 End */ import \u0026#34;fmt\u0026#34; func main() { cA := C.int(1) cB := C.int(2) sum := C.sum(cA, cB) fmt.Printf(\u0026#34;sum value: %v\\n\u0026#34;, sum) } 执行go build编译这个example程序：\n1 2 $ CGO_ENABLED=1 GOOS=darwin GOARCH=amd64 go build -o ./example/simple_sum ./example \u0026amp;\u0026amp; ./example/simple_sum sum value: 3 调用外部库需要用到 #cgo 伪指令，他可以指定编译和链接参数，如 CFLAGS, CPPFLAGS, CXXFLAGS, FFLAGS and LDFLAGS。CFLAGSS可以配置C语言编译器参数，其中 -I 可以指定头文件目录，例如 -I/path/to/include 。LDFLAGS 可以配置引用库的参数，其中 -L 指定引用库的目录，-l指定库名称。如果引用的头文件或者库在系统默认的目录下（例如 /usr/include, /usr/local/include 和 /usr/lib, /usr/local/lib）则可以不用指定目录。\n#cgo指令中可以添加限制平台的参数，例如只针对 linux 或者 darwin 平台，详情参考 https://golang.org/pkg/go/build/#hdr-Build_Constraints 。同时可以使用${SRCDIR}代替源代码目录。\n1 2 3 // #cgo linux CFLAGS: -I$./simple // #cgo darwin CFLAGS: -I$./another_simple // #cgo LDFLAGS: -L${SRCDIR}/simple -lsimplesum ","date":"2021-06-21","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/21/go-call-c/","tags":["golang","cgo","C"],"title":"Go语言调用C语言代码"},{"categories":["Golang"],"contents":"在Go语言中字符串处理操作，可用的内建包有strings、bytes、strconv、regexp、fmt等等吧，不管在任何语言中字符串处理、数组处理在日常开发中都是非常频繁的，当然了，Go语言中用的最多的是不数组而是slice切片，写这篇文章的目的不是记录标准库的常规操作，而是记录一些配合标准库处理字符串的技巧性操作，这篇文章不会一下记录所有的字符串处理场景，但是会持续性的更新，希望我这些遇到的字符串处理案例可以对您的开发工作有所帮助~\n完成这个字符串场景处理需要使用到正则表达式，Go语言提供的标准库为regexp，以及文件操作。具体思路这样子的，读取文件内容，使用正则表达式去匹配指定字符串所在的行，然后删除即可，最后将处理后的字符串保存到文件，这个字符串处理场景需要也就完成了，来看具体的代码如何实现。\n现在，在demo目录下有一个文本文件，如helloshaohua.txt内容如下：\n1 2 3 4 $ cat ./demo/helloshaohua.txt helloshaohua WillDeleteLine wu.shaohua@foxmail.com 可以看到，现在这个文件有3行，比如说想要删除 WillDeleteLine 这个特定字符串所在的行，让这个文件变为2行，最终的文件内容应该如下：\n1 2 3 $ cat ./demo/helloshaohua.txt helloshaohua wu.shaohua@foxmail.com 这是我们预期想要达到的目标，有了这个简单的小场景需求，来编写具体的代码实现，在demo目录下创建demo.go具体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package demo import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;regexp\u0026#34; ) // DeleteFileSpecificContentLine Deletes lines of a file that contain specific content. func DeleteFileSpecificContentLine(filename, findStr string) error { // Write file. bytes, err := ioutil.ReadFile(filename) if err != nil \u0026amp;\u0026amp; os.IsNotExist(err) { return errors.New(fmt.Sprintf(\u0026#34;%s file not exists\u0026#34;, filename)) } // Delete line. bytes = regexp.MustCompile(fmt.Sprintf(`%s\\n`, findStr)).ReplaceAll(bytes, []byte(\u0026#34;\u0026#34;)) // Write file. return ioutil.WriteFile(filename, bytes, 0644) } 并且在demo目录下创建了一个测试文件demo_test.go具体内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 package demo import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) func TestDeleteFileSpecificContentLine(t *testing.T) { err := DeleteFileSpecificContentLine(\u0026#34;helloshaohua.txt\u0026#34;, \u0026#34;WillDeleteLine\u0026#34;) assert.NoError(t, err) } 来跑一下demo目录下的这个测试：\n1 2 3 4 5 $ go test -v ./demo === RUN TestDeleteFileSpecificContentLine --- PASS: TestDeleteFileSpecificContentLine (0.00s) PASS ok github.com/helloshaohua/demo 0.459s 从测试结果来看，它已经成功了，来看一下demo目录下的helloshaohua.txt:\n1 2 3 $ cat demo/helloshaohua.txt helloshaohua wu.shaohua@foxmail.com 现在它已经更改成了我们的预期文件内容。需要特别说明的就是在 demo.go 文件中，regexp.MustCompile这个函数具体会根据传递的参数具体编译，如，在当前的案例中传递的参数值为 WillDeleteLine，regexp.MustCompile函数最终编译的字符串为 WillDeleteLine\\n，*Regexp.ReplaceAll函数是直接处理的字节切片，因为，ioutil.ReadFile函数读取的文件最终结果为字节切片，我们不需要将它转换为字符串就可以使用*Regexp.ReplaceAll函数进行处理，如果是字符串您可以选择使用字符串处理函数进行处理，如*Regexp.ReplaceAllString函数等等。\n","date":"2021-06-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/19/golang-string-processing/","tags":["string"],"title":"Golang 字符串处理，删除文件中的指定行"},{"categories":["Golang"],"contents":"匹配多个字符 匹配多个空格 1 \\s+ 可以将包含一个或多个的空格统一处理为一个空格，如有如下字符串：\n1 2 $ ll drwx------@ 3 helloshaohua staff 96B 1 29 09:48 Applications ","date":"2021-06-18","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/18/regular-expression-use-case/","tags":["RegExp"],"title":"正则表达式用例"},{"categories":["Docker"],"contents":" ","date":"2021-06-17","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/17/docker-image-pull-aliyun/","tags":["image","push","aliyun"],"title":"Docker镜像Push到阿里云"},{"categories":["Golang"],"contents":"json-to-go 该工具立即将 JSON 转换为 Go 类型定义。在左侧粘贴一个 JSON 结构，右侧将生成等效的 Go 类型，您可以将其粘贴到您的程序中。该脚本必须做出一些假设，因此请仔细检查输出！\n服务地址 JSON-TO-GO\n示例截图 ","date":"2021-06-17","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/17/json-to-go-structure/","tags":["json","struct","convert"],"title":"JSON 转换到 Go 结构体类型"},{"categories":["Golang"],"contents":"Go语言是强类型语言，不支持类型的隐式类型转换，所有类型都需要显示进行转换，那么bytes数组如何转换为Float64，以及Float64将转换为bytes数组，也就是它们之间的互相转换如何做到。这两种类型的转换不能直接转换需要转换为中间类型然后再转换为对应的类型。\nbytes数组转换为Float64 1 2 3 4 5 6 7 8 9 10 11 12 package converter import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;math\u0026#34; ) func BytesToFloat64(bytes []byte) float64 { bits := binary.LittleEndian.Uint64(bytes) float := math.Float64frombits(bits) return float } float64转换为bytes数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package converter import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;math\u0026#34; ) func Float64ToBytes(float float64) []byte { bits := math.Float64bits(float) bytes := make([]byte, 8) binary.LittleEndian.PutUint64(bytes, bits) return bytes } ","date":"2021-06-17","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/17/golang-and-interchange-between-bytes/","tags":["float64","bytes","convert"],"title":"Golang Float64和字节数组之间的交换"},{"categories":["Linux"],"contents":"Step1、执行以下命令发现安装包的名称 1 $ rpm -qa | grep package_name 例如要卸载LibreOffice软件的RPM安装包，首先需要执行上面的命令进行查看已经安装了哪些包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ rpm -qa | grep \u0026#34;libreoffice\u0026#34; libreoffice7.0-freedesktop-menus-7.0.6-2.noarch libreoffice7.0-7.0.6.2-2.x86_64 libreoffice7.0-math-7.0.6.2-2.x86_64 libreoffice7.0-calc-7.0.6.2-2.x86_64 libreoffice7.0-dict-es-7.0.6.2-2.x86_64 libreoffice7.0-draw-7.0.6.2-2.x86_64 libreoffice7.0-impress-7.0.6.2-2.x86_64 libreoffice7.0-zh-CN-7.0.6.2-2.x86_64 libobasis7.0-libreofficekit-data-7.0.6.2-2.x86_64 libreoffice7.0-ure-7.0.6.2-2.x86_64 libreoffice7.0-base-7.0.6.2-2.x86_64 libreoffice7.0-dict-en-7.0.6.2-2.x86_64 libreoffice7.0-dict-fr-7.0.6.2-2.x86_64 libreoffice7.0-en-US-7.0.6.2-2.x86_64 libreoffice7.0-writer-7.0.6.2-2.x86_64 这将返回 PackageName，这是 LibreOffice 产品的 RPM 名称，用于标识安装包。\nStep2、执行以下命令卸载产品 1 $ rpm -e libreoffice7.0-freedesktop-menus-7.0.6-2.noarch 同时卸载多个安装包 1 $ rpm -e --allmatches [ PackageName ] 1 $ rpm -e --allmatches \u0026#34;libreoffice\u0026#34; ","date":"2021-06-13","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/13/linux-uninstall-rpm/","tags":["rpm","uninstall"],"title":"Linux 卸载 RPM 安装包"},{"categories":["Linux"],"contents":"LibreOffice是由文档基金会开发的自由及开放源代码的办公室套件。LibreOffice套件包含文字处理器、电子表格、演示文稿程序、矢量图形编辑器和图表工具、数据库管理程序及创建和编辑数学公式的应用程序。\nSection1、下载LibreOffice 到LibreOffice官网进行下载。\n如上图所示选择操作系统类型为Linux(64-bit)(rpm)，然后下载 7.0.6 LTS 版本，然后上传到服务。如果您不想这么操作，可以在跳转的下载页面复制下载链接到服务器上使用wget工具进行下载，都是可以的，怎么方便怎么来嘛~\n1 bash-4.4# wget https://download.documentfoundation.org/libreoffice/stable/7.0.6/rpm/x86_64/LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz 下载后的LibreOffice软件RPM安装如下所示：\n1 2 3 bash-4.4# ll -h 总用量 251M -rw-r--r-- 1 root root 251M 5月 7 19:37 LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz Section2、下载内建帮助RPM包 1 bash-4.4# tar -zxvf LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz 解压后的目录结构如下，会将 LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz 归案文件解压到 LibreOffice_7.0.6.2_Linux_x86-64_rpm 目录。\n1 2 3 4 bash-4.4# ll -h 总用量 251M drwxr-xr-x 4 root root 4.0K 5月 7 11:03 LibreOffice_7.0.6.2_Linux_x86-64_rpm -rw-r--r-- 1 root root 251M 5月 7 19:37 LibreOffice_7.0.6_Linux_x86-64_rpm.tar.gz Section3、下载中文相关RPM包 首先进入到LibreOffice_7.0.6.2_Linux_x86-64_rpm目录\n1 bash-4.4# cd LibreOffice_7.0.6.2_Linux_x86-64_rpm 您会看到类似如下的目录结构\n1 2 3 4 5 bash-4.4# ll -h 总用量 20K -rwxr-xr-x 1 root root 11K 5月 7 11:03 install drwxr-xr-x 2 root root 4.0K 5月 7 11:03 readmes drwxrwxr-x 2 root root 4.0K 5月 7 11:03 RPMS 进入到 RPMS 目录\n1 bash-4.4# cd RPMS/ 你会到下有许多RPM安装包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 bash-4.4# ll -h 总用量 254M -rw-r--r-- 1 root root 1.9M 5月 7 10:59 libobasis7.0-base-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 9.5M 5月 7 10:59 libobasis7.0-calc-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 103M 5月 7 10:58 libobasis7.0-core-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 6.2K 5月 7 11:00 libobasis7.0-draw-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 89K 5月 7 10:59 libobasis7.0-en-US-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 394K 5月 7 11:03 libobasis7.0-extension-beanshell-script-provider-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 626K 5月 7 11:00 libobasis7.0-extension-javascript-script-provider-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.2M 5月 7 11:00 libobasis7.0-extension-mediawiki-publisher-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 1.2M 5月 7 11:02 libobasis7.0-extension-nlpsolver-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 1.1M 5月 7 11:03 libobasis7.0-extension-pdf-import-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 3.2M 5月 7 10:58 libobasis7.0-extension-report-builder-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 3.4M 5月 7 10:58 libobasis7.0-firebird-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 806K 5月 7 11:01 libobasis7.0-gnome-integration-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 1.7M 5月 7 10:58 libobasis7.0-graphicfilter-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 48M 5月 7 10:59 libobasis7.0-images-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 748K 5月 7 11:01 libobasis7.0-impress-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.3M 5月 7 10:59 libobasis7.0-kde-integration-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 227K 5月 7 11:00 libobasis7.0-librelogo-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 3.6K 5月 7 11:03 libobasis7.0-libreofficekit-data-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 541K 5月 7 11:01 libobasis7.0-math-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 125K 5月 7 10:58 libobasis7.0-ogltrans-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 217K 5月 7 11:01 libobasis7.0-onlineupdate-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 31M 5月 7 11:03 libobasis7.0-ooofonts-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.6K 5月 7 11:01 libobasis7.0-ooolinguistic-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 1.5M 5月 7 11:03 libobasis7.0-postgresql-sdbc-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 14K 5月 7 11:01 libobasis7.0-python-script-provider-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 7.8M 5月 7 11:01 libobasis7.0-pyuno-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 4.9M 5月 7 10:59 libobasis7.0-writer-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 457K 5月 7 11:00 libobasis7.0-xsltfilter-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 755K 5月 7 10:59 libreoffice7.0-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.3K 5月 7 10:59 libreoffice7.0-base-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.3K 5月 7 11:01 libreoffice7.0-calc-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 6.3M 5月 7 11:03 libreoffice7.0-dict-en-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 1.4M 5月 7 11:01 libreoffice7.0-dict-es-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.2M 5月 7 11:03 libreoffice7.0-dict-fr-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.3K 5月 7 10:59 libreoffice7.0-draw-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 7.3K 5月 7 10:50 libreoffice7.0-en-US-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.5M 5月 6 18:41 libreoffice7.0-freedesktop-menus-7.0.6-2.noarch.rpm -rw-r--r-- 1 root root 2.3K 5月 7 10:58 libreoffice7.0-impress-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.3K 5月 7 11:03 libreoffice7.0-math-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 17M 5月 7 10:59 libreoffice7.0-ure-7.0.6.2-2.x86_64.rpm -rw-r--r-- 1 root root 2.3K 5月 7 10:59 libreoffice7.0-writer-7.0.6.2-2.x86_64.rpm Section3.1、下载内建帮助RPM包 返回到之前下载LibreOffice跳转的页面\n复制 LibreOffice built-in help 下载链接地址，到Linux服务器还是之前的 RPMS 目录下去下载内建的帮助RPM安装包\n1 wget https://download.documentfoundation.org/libreoffice/stable/7.0.6/rpm/x86_64/LibreOffice_7.0.6_Linux_x86-64_rpm_helppack_zh-CN.tar.gz 下载成功后会多出一个归案文件如下所示\n1 2 bash-4.4# ll -l | grep tar.gz -rw-r--r-- 1 root root 3995067 5月 7 19:37 LibreOffice_7.0.6_Linux_x86-64_rpm_helppack_zh-CN.tar.gz 将其解压\n1 2 3 4 bash-4.4# tar -zxvf LibreOffice_7.0.6_Linux_x86-64_rpm_helppack_zh-CN.tar.gz LibreOffice_7.0.6.2_Linux_x86-64_rpm_helppack_zh-CN/ LibreOffice_7.0.6.2_Linux_x86-64_rpm_helppack_zh-CN/RPMS/ LibreOffice_7.0.6.2_Linux_x86-64_rpm_helppack_zh-CN/RPMS/libobasis7.0-zh-CN-help-7.0.6.2-2.x86_64.rpm 然后将解压后的RPM包移动到当前目录\n1 bash-4.4# mv LibreOffice_7.0.6.2_Linux_x86-64_rpm_helppack_zh-CN/RPMS/* . Section3.2、下载中文语言RPM包 返回到之前下载LibreOffice跳转的页面\n复制 Translated User Interface 下载链接地址，到Linux服务器还是之前的 RPMS 目录下去下载中文语言RPM安装包\n1 bash-4.4# wget https://download.documentfoundation.org/libreoffice/stable/7.0.6/rpm/x86_64/LibreOffice_7.0.6_Linux_x86-64_rpm_langpack_zh-CN.tar.gz 下载成功后会多出一个归案文件LibreOffice_7.0.6_Linux_x86-64_rpm_langpack_zh-CN.tar.gz如下所示\n1 2 3 bash-4.4# ll -l | grep tar.gz -rw-r--r-- 1 root root 3995067 5月 7 19:37 LibreOffice_7.0.6_Linux_x86-64_rpm_helppack_zh-CN.tar.gz -rw-r--r-- 1 root root 847058 5月 7 19:37 LibreOffice_7.0.6_Linux_x86-64_rpm_langpack_zh-CN.tar.gz 将其解压\n1 2 3 4 5 bash-4.4# tar -zxvf LibreOffice_7.0.6_Linux_x86-64_rpm_langpack_zh-CN.tar.gz LibreOffice_7.0.6.2_Linux_x86-64_rpm_langpack_zh-CN/ LibreOffice_7.0.6.2_Linux_x86-64_rpm_langpack_zh-CN/RPMS/ LibreOffice_7.0.6.2_Linux_x86-64_rpm_langpack_zh-CN/RPMS/libobasis7.0-zh-CN-7.0.6.2-2.x86_64.rpm LibreOffice_7.0.6.2_Linux_x86-64_rpm_langpack_zh-CN/RPMS/libreoffice7.0-zh-CN-7.0.6.2-2.x86_64.rpm 然后将解压后的RPM包移动到当前目录\n1 bash-4.4# mv LibreOffice_7.0.6.2_Linux_x86-64_rpm_langpack_zh-CN/RPMS/* . Section4、安装LibreOffice 还是在 RPMS 目录执行以下命令进行LibreOfficeRPM安装包的安装\n1 bash-4.4# su -c \u0026#39;yum install *.rpm\u0026#39; Section5、验证安装及修复相关依赖 1 2 bash-4.4# libreoffice7.0 -h /opt/libreoffice7.0/program/soffice.bin: error while loading shared libraries: libcairo.so.2: cannot open shared object file: No such file or directory 你会发现它并没有给出相关的命令提示帮助信息而是报了个错，libcairo.so 这个动态链接库找不到，执行以下YUM命令进行安装\n1 bash-4.4# yum install -y cairo 再次执行LibreOffice相关命令进行验证\n1 2 bash-4.4# libreoffice7.0 -h /opt/libreoffice7.0/program/soffice.bin: error while loading shared libraries: libcups.so.2: cannot open shared object file: No such file or directory 依然报错说 libcups.so 这个动态链接库找不到，执行以下YUM命令进行安装\n1 bash-4.4# yum install -y cups-libs 再次执行LibreOffice相关命令进行验证\n1 2 bash-4.4# libreoffice7.0 -h /opt/libreoffice7.0/program/soffice.bin: error while loading shared libraries: libSM.so.6: cannot open shared object file: No such file or directory 还是报错说 libSM.so 这个动态链接库找不到，执行以下YUM命令进行安装\n1 bash-4.4# yum install -y libSM 再次执行LibreOffice相关命令进行验证\n1 2 bash-4.4# libreoffice7.0 -h /opt/libreoffice7.0/program/soffice.bin: error while loading shared libraries: libX11-xcb.so.1: cannot open shared object file: No such file or directory 还是报错说 libX11-xcb.so 这个动态链接库找不到，执行以下YUM命令进行安装\n1 bash-4.4# yum install -y libX11-xcb 再次执行LibreOffice相关命令进行验证，这次终于出来了！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 bash-4.4# libreoffice7.0 -h LibreOffice 7.0.6.2 144abb84a525d8e30c9dbbefa69cbbf2d8d4ae3b Usage: soffice [argument...] argument - switches, switch parameters and document URIs (filenames). Using without special arguments: Opens the start center, if it is used without any arguments. {file} Tries to open the file (files) in the components suitable for them. {file} {macro:///Library.Module.MacroName} Opens the file and runs specified macros from the file. Getting help and information: --help | -h | -? Shows this help and quits. --helpwriter Opens built-in or online Help on Writer. --helpcalc Opens built-in or online Help on Calc. --helpdraw Opens built-in or online Help on Draw. --helpimpress Opens built-in or online Help on Impress. --helpbase Opens built-in or online Help on Base. --helpbasic Opens built-in or online Help on Basic scripting language. --helpmath Opens built-in or online Help on Math. --version Shows the version and quits. --nstemporarydirectory (MacOS X sandbox only) Returns path of the temporary directory for the current user and exits. Overrides all other arguments. General arguments: --quickstart[=no] Activates[Deactivates] the Quickstarter service. --nolockcheck Disables check for remote instances using one installation. --infilter={filter} Force an input filter type if possible. For example: --infilter=\u0026#34;Calc Office Open XML\u0026#34; --infilter=\u0026#34;Text (encoded):UTF8,LF,,,\u0026#34; --pidfile={file} Store soffice.bin pid to {file}. --display {display} Sets the DISPLAY environment variable on UNIX-like platforms to the value {display} (only supported by a start script). User/programmatic interface control: --nologo Disables the splash screen at program start. --minimized Starts minimized. The splash screen is not displayed. --nodefault Starts without displaying anything except the splash screen (do not display initial window). --invisible Starts in invisible mode. Neither the start-up logo nor the initial program window will be visible. Application can be controlled, and documents and dialogs can be controlled and opened via the API. Using the parameter, the process can only be ended using the taskmanager (Windows) or the kill command (UNIX-like systems). It cannot be used in conjunction with --quickstart. --headless Starts in \u0026#34;headless mode\u0026#34; which allows using the application without GUI. This special mode can be used when the application is controlled by external clients via the API. --norestore Disables restart and file recovery after a system crash. --safe-mode Starts in a safe mode, i.e. starts temporarily with a fresh user profile and helps to restore a broken configuration. --accept={connect-string} Specifies a UNO connect-string to create a UNO acceptor through which other programs can connect to access the API. Note that API access allows execution of arbitrary commands. The syntax of the {connect-string} is: connection-type,params;protocol-name,params e.g. pipe,name={some name};urp or socket,host=localhost,port=54321;urp --unaccept={connect-string} Closes an acceptor that was created with --accept. Use --unaccept=all to close all acceptors. --language={lang} Uses specified language, if language is not selected yet for UI. The lang is a tag of the language in IETF language tag. Developer arguments: --terminate_after_init Exit after initialization complete (no documents loaded) --eventtesting Exit after loading documents. New document creation arguments: The arguments create an empty document of specified kind. Only one of them may be used in one command line. If filenames are specified after an argument, then it tries to open those files in the specified component. --writer Creates an empty Writer document. --calc Creates an empty Calc document. --draw Creates an empty Draw document. --impress Creates an empty Impress document. --base Creates a new database. --global Creates an empty Writer master (global) document. --math Creates an empty Math document (formula). --web Creates an empty HTML document. File open arguments: The arguments define how following filenames are treated. New treatment begins after the argument and ends at the next argument. The default treatment is to open documents for editing, and create new documents from document templates. -n Treats following files as templates for creation of new documents. -o Opens following files for editing, regardless whether they are templates or not. --pt {Printername} Prints following files to the printer {Printername}, after which those files are closed. The splash screen does not appear. If used multiple times, only last {Printername} is effective for all documents of all --pt runs. Also, --printer-name argument of --print-to-file switch interferes with {Printername}. -p Prints following files to the default printer, after which those files are closed. The splash screen does not appear. If the file name contains spaces, then it must be enclosed in quotation marks. --view Opens following files in viewer mode (read-only). --show Opens and starts the following presentation documents of each immediately. Files are closed after the showing. Files other than Impress documents are opened in default mode , regardless of previous mode. --convert-to OutputFileExtension[:OutputFilterName] \\ [--outdir output_dir] [--convert-images-to] Batch convert files (implies --headless). If --outdir isn\u0026#39;t specified, then current working directory is used as output_dir. If --convert-images-to is given, its parameter is taken as the target filter format for *all* images written to the output format. If --convert-to is used more than once, the last value of OutputFileExtension[:OutputFilterName] is effective. If --outdir is used more than once, only its last value is effective. For example: --convert-to pdf *.odt --convert-to epub *.doc --convert-to pdf:writer_pdf_Export --outdir /home/user *.doc --convert-to \u0026#34;html:XHTML Writer File:UTF8\u0026#34; \\ --convert-images-to \u0026#34;jpg\u0026#34; *.doc --convert-to \u0026#34;txt:Text (encoded):UTF8\u0026#34; *.doc --print-to-file [--printer-name printer_name] [--outdir output_dir] Batch print files to file. If --outdir is not specified, then current working directory is used as output_dir. If --printer-name or --outdir used multiple times, only last value of each is effective. Also, {Printername} of --pt switch interferes with --printer-name. --cat Dump text content of the following files to console (implies --headless). Cannot be used with --convert-to. --script-cat Dump text content of any scripts embedded in the files to console (implies --headless). Cannot be used with --convert-to. -env:\u0026lt;VAR\u0026gt;[=\u0026lt;VALUE\u0026gt;] Set a bootstrap variable. For example: to set a non-default user profile path: -env:UserInstallation=file:///tmp/test Ignored switches: -psn Ignored (MacOS X only). -Embedding Ignored (COM+ related; Windows only). --nofirststartwizard Does nothing, accepted only for backward compatibility. --protector {arg1} {arg2} Used only in unit tests and should have two arguments. Section6、别名配置 也许聪明的你已经发现了，LibreOffice的命令行工具在 linux 下是 libreoffice7.0 这种有版本号的，而在 MacOS 中一般是手动添加命令映射 soffice，您可以在我的另一篇博文 《MacOS环境在终端使用Libreoffice的soffice命令》中找到相关说明。一个是 libreoffice\u0026lt;version\u0026gt; 一个是 soffice ，非常不够统一，为了方便起见我们需要在linux环境中配置一下别名。编辑 /etc/profile 文件在最后添加一行代码如下所示：\n1 alias soffice=\u0026#34;libreoffice7.0\u0026#34; 保存之前执行一个 source 命令\n1 bash-4.4# source /etc/profile 现在我们就可以在多个不同的系统平台使用相同的命令了，如\n1 bash-4.4# soffice -h Section7、使用 接下来我们尝试将PDF转换为Word文档。\n1 2 3 bash-4.4# soffice --invisible --convert-to docx:\u0026#34;MS Word 2007 XML\u0026#34; libreoffice.pdf javaldx: Could not find a Java Runtime Environment! Warning: failed to read path from javaldx 正如你所见它说打不到JAVA运行时环境，好嘛，又来了，我们干掉你，执行如下YUM命令\n1 bash-4.4# yum install -y java 再次尝试转换，这次成功啦~\n1 2 bash-4.4# soffice --invisible --infilter=\u0026#34;writer_pdf_import\u0026#34; --convert-to docx:\u0026#34;MS Word 2007 XML\u0026#34; libreoffice.pdf convert /root/libreoffice.pdf -\u0026gt; /root/libreoffice.docx using filter : MS Word 2007 XML 下面是后的Word文档第一页截图\n参考官方文档 Ref1. LibreOfficeInstallFromLinux Ref2. LibreOfficeCLIExamples ","date":"2021-06-13","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/13/linux-install-libreoffice/","tags":["LibreOffce","rockylinux","CentOS"],"title":"Linux 安装 LibreOffice"},{"categories":["Linux"],"contents":"如果您在 GNU / Linux 上将其与 Wine 一起使用，那么您肯定已经知道如何使用 Microsoft 办公套件中包含的功能将原生 Microsoft Office 文档转换为 PDF。即使您使用 LibreOffice 或其他办公套件，由于已经包含此类套件的工具，您也可以轻松地将文档转换为 PDF 以更舒适的方式共享它。在您不得不使用其他工具来执行此操作之前，某些插件已经出现，最后它们已经集成到套件中。\n但这不是我们在本文中将要解释的，而是我们感兴趣的是相反的过程，即将 PDF 转换为 Word 文档或 LibreOffice，无论是 .doc、.docx 等。 虽然它不是典型的作为我在第一段中解释的反向转换，有很多人需要将PDF文档转换为更友好的格式来编辑它们。这就是为什么我们要解释将 PDF 转换为 Word 的简单步骤。\nPDF 和其他格式有什么区别： PDF 代表 Portable Document Format，即一种可移植的文档格式。它由 Adob​​e Systems 开发，目前是最流行的格式之一，因为它独立于我们使用的软件和硬件平台，因此是可移植的。这意味着我们将能够可视化来自几个非常不同的操作系统和程序的内容，这使得它成为访问现有异构计算机的互联网之王。\n它变得如此重要，以至于它在 2008 年在 ISO 32000-1 下标准化，但并非所有优点，如便携性、易于查看、小尺寸和个性化配置，它也有其隐藏的面孔。例如，这些 PDF 文件的版本涉及购买付费软件，例如专业版的 Adob​​e Acrobat 产品。如果没有特定软件，很难编辑或不可能进行编辑，因此很难使用它，这就是为什么我们将在本教程中教您将其转换为可编辑文档的原因。\n顺便说一句，Linux 确实有一些替代品，例如 PDF Studio Pro 或 PDF Edit，但老实说，这些替代品还不够成熟或不像 Adob​​e 的那样完整\u0026hellip;\u0026hellip;\n如何将 Word 转换为 PDF 使用微软Office 要从任何Office文档进行转换，可以是 .doc、.docx、.ppt、.pptx 等。等，如果您在Web平台使用Microsoft Office或Office 365的办公套件，则可以按照以下步骤转到PDF格式：\n打开您要使用的程序。它可以是 Word、PowerPoint 等。 转到文件菜单。 单击导出。 并选择PDF格式。 在下拉菜单中，您可以选择 PDF 文档的名称和保存位置，还可以选择普通格式或轻型格式（尤其是在线发布时）。如果您显示选项，它还允许您选择要转换的页面、书签等。 接受并保存时，office 文档将开始导出为 PDF，我们将准备好它。 如果从云中的 Office Web 界面或从适用于 Android 的 Microsoft Office 365 办公应用程序工作，则相同\u0026hellip;\n使用LibreOffice/OpenOffice： 如果您使用的是免费的办公套件，它也是相同的或更简单的。从 LibreOffice 或 OpenOffice 开始，您只需执行以下步骤：\n打开您正在使用的程序，例如 Presentation、Writer、\u0026hellip; 打开要导出为 PDF 的文档后，转到“文件”菜单。 选择导出为 PDF 选项。 选择名称和保存位置。 准备好，您已经创建了 PDF。 将 PDF 转换为 Word 在反向操作的情况下，办公套件通常没有将 PDF 转换为可编辑文档的选项，或者即使有，它们也不像将文档转换为 PDF 的选项那样可见。例如，如果我们在我们的发行版中安装了 LibreOffice（和 libreoffice-common 包），我们可以使用一个简单的命令将 PDF 转换为与我们最喜欢的免费套件兼容的格式之一。如何？嗯，这样：\n首先进入到PDF文件所在目录，当然你也可以指定绝对路径：\n1 $ cd /Users/wushaohua/dev/pdf-documents 然后执行如下命令：\n1 $ soffice --infilter=\u0026#34;writer_pdf_import\u0026#34; --convert-to doc helloshaohua.pdf 执行以下命令后libreoffice将会将helloshaohua.pdf这个PDF文件转换为helloshaohua.doc文件，以便能够轻松地对其进行编辑。当然，您必须从 PDF 所在的目录运行它……如果您愿意，您可以更改 doc 格式以使用不同的格式，例如.odt等。\n另一种方式可能是这里，在这种情况下，对于 Word 兼容的 .docx：\n1 $ libreoffice --invisible --convert-to docx:\u0026#34;MS Word 2007 XML\u0026#34; helloshaohua.pdf 它们并不是进行此类转换的唯一选择，还有更多选择。如果您愿意，可以安装 Abiword 包并运行以下命令：\n1 $ abiword --to=doc helloshaohua.pdf 最后的资源是获取 Adob​​e Acrobar Pro 软件，以便能够编辑 PDF 或将其转换为其他格式，其中包括 .doc 和 .docx 等。但为此，您应该使用 Mac 或 Windows 的虚拟机才能运行它，或者直接在 Wine 的帮助下安装 Adob​​e Acrobat Pro。\n参考: ConvertPDFToWordFromLinux\nstackoverflow is not working\n","date":"2021-06-13","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/13/convert-pdf-to-word-from-linux/","tags":["PDF","Word","Convert"],"title":"从Linux转换PDF到Word"},{"categories":["Golang"],"contents":"Golang项目开发完成后最终是要放到服务器上去跑的，那么就需要编译出对应平台及CPU构架类型的可执行程序上传到服务器。由于业务需要构建多个平台，每一次都需要多次构建，非常不方便，于是乎可以将其在Shell脚本中自动化的快速构建多个不台平台程序，这样可以省去不必要的没有意义的操作。\n查看Golang支持的平台及CPU框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 $ go tool dist list aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/amd64 darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm freebsd/arm64 illumos/amd64 js/wasm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x netbsd/386 netbsd/amd64 netbsd/arm netbsd/arm64 openbsd/386 openbsd/amd64 openbsd/arm openbsd/arm64 plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64 windows/arm 可以看到当前系统安装的Go语言支持的操作类型及CPU构架详情列表信息，注意，每一行是一种平台及CPU构架描述，非常直观一看就会明白，不用让我们一个一个去到对应服务器上去查看平台类型及CPU构架，非常方便。\n构建Shell脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #!/bin/bash # # # Use shell script build go program applications. # Author: helloshaohua. # Date: 2021.6.13. BUILD_COMPILE_DIR=\u0026#34;../compile\u0026#34; PLATFORM_AND_CPU_ARCH=(\u0026#34;linux/amd64\u0026#34; \u0026#34;darwin/amd64\u0026#34; \u0026#34;linux/arm64\u0026#34; \u0026#34;linux/mips64\u0026#34;) PLATFORM=\u0026#34;\u0026#34; CPU_ARCH=\u0026#34;\u0026#34; # PrintLogFunc Format the print log function. # This function takes two arguments： # This first parameter: Description of the log information. # The second parameter: Output text rendering colors. function PrintLogFunc() { log_info=$1 use_color=$2 # 如果{输出文字渲染颜色}长度为0时，则使用默认颜色. if [ -z \u0026#34;$use_color\u0026#34; ]; then use_color=0 fi # 如果{输出文字渲染颜色}参数为1时，时使用{蓝色}文字，否则默认文字颜色. if [ $use_color = \u0026#34;WARNING\u0026#34; ]; then echo -e \u0026#34;\\033[31m[`date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;`] WARNING - ${log_info} \\033[0m\u0026#34; elif [ $use_color = \u0026#34;INFO\u0026#34; ]; then echo -e \u0026#34;\\033[32m[`date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;`] INFO - ${log_info} \\033[0m\u0026#34; else echo \u0026#34;[`date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;`] DEBUG - ${log_info}\u0026#34; fi # 输出两行空行. echo; } # GetPlatformAndCPUArchFunc get platfrom and cpu arch info. function GetPlatformAndCPUArchFunc() { info=$1 if [ ${#info} == 0 ]; then PrintLogFunc \u0026#34;platfrom and cpu arch info can\u0026#39;t empty\u0026#34; WARNING exit 1 fi INFO_ARR=(${info//// }) for (( i = 0; i \u0026lt; ${#INFO_ARR[@]}; i++ )); do case $i in 0) PLATFORM=${INFO_ARR[i]};; 1) CPU_ARCH=${INFO_ARR[i]};; esac done } # Build on the loop. for INFO in \u0026#34;${PLATFORM_AND_CPU_ARCH[@]}\u0026#34;; do GetPlatformAndCPUArchFunc \u0026#34;$INFO\u0026#34; BUILD_PROGRAM_NAME=\u0026#34;features.$PLATFORM.$CPU_ARCH\u0026#34; GOOS=\u0026#34;$PLATFORM\u0026#34; GOARCH=\u0026#34;$CPU_ARCH\u0026#34; go build -o \u0026#34;$BUILD_COMPILE_DIR/$BUILD_PROGRAM_NAME\u0026#34; ../cmd/features PrintLogFunc \u0026#34;Build $BUILD_PROGRAM_NAME successfully~\u0026#34; INFO done ","date":"2021-06-13","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/13/golang-cross-compile/","tags":["compile","arch","platform"],"title":"Golang交叉编译"},{"categories":["MacOS"],"contents":"MacOS使用过程中遇到的各种问题汇总。\nMac Big Sur 清除DNS缓存 1 $ sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder ","date":"2021-06-12","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/12/mac-using-skills/","tags":["skills","use"],"title":"Mac使用技巧"},{"categories":["MacOS"],"contents":"由于业务需要，需要将PDF文档转换为Word文档，这种类似的工具软件比较多，如OpenOffice、LibreOffice、Abiword等，都是可以的，使用的话主要是在服务器上使用，本地一般用个WPSOffice就够用了，因为要在本地开发调试，所以为了方便起见需要在MacOS系统安装 LibreOffice ，安装之后你会发现这个工具，没有默认支持终端下使用命令的功能。在程序中完成文档的格式转换就需要调用命令，需要手动去设置shell脚本访问 soffice 这个命令，当然，你也可以使用全路径就调用这个 soffice 命令，当然，话有说回来既然就能看到这篇博文说明你也在找类型的解决方案，来吧，来看一下具体怎么设置，其实也非常简单~\n创建Shell脚本 在 /usr/local/bin 目录下创建一个名为 soffice 的Shell脚本，并添加以下内容：\n1 2 3 4 5 #!/bin/bash # 需要这样做，因为符号链接不起作用， # 因为它抱怨包含了一些 .plist 文件。 /Applications/LibreOffice.app/Contents/MacOS/soffice \u0026#34;#@\u0026#34; 赋予可执行权限 1 $ sudo chmod +x /usr/local/bin/soffice 用法 ","date":"2021-06-11","image":null,"permalink":"https://shaichunfeng.com/post/2021/06/11/make-soffice-of-libreoffice-work-on-macos/","tags":["LibreOffice","soffice","PDF","Word"],"title":"MacOS环境在终端使用Libreoffice的soffice命令"},{"categories":["Elasticsearch"],"contents":":::tip 在CentOS上安装Headless Chromium的分步指南。 :::\n索引操作 索引(也就是index)的常用的相关操作包括：新建索引、删除索引、\n如何新建索引? 新建索引， 可以直接向 ElasticSearch 服务器发送 PUT 请求。例如，下面的例子是新建一个名为 users 的索引。\n1 curl -XPUT \u0026#34;http://localhost:9200/users?pretty=true\u0026#34; 服务器将返回一个JSON对象，其中 acknowledged 代表是否操作成功，shards_acknowledged 是否分片成功，index 表示操作的索引名称，当前就是 users。\n1 2 3 4 5 { \u0026#34;acknowledged\u0026#34; : true, \u0026#34;shards_acknowledged\u0026#34; : true, \u0026#34;index\u0026#34; : \u0026#34;users\u0026#34; } 如何删除索引？ 删除索引，直接向 ElasticSearch 服务器发送 DELETE 请求，即可删除索引。例如，下面的例子是删除一个名为 users 的索引。\n1 curl -XDELETE \u0026#34;http://localhost:9200/users?pretty=true\u0026#34; 服务器将返回一个JSON对象，具体如下所示：\n1 2 3 { \u0026#34;acknowledged\u0026#34; : true } 如何查看所有索引? 查看所有索引可以通过 _cat 加 _indices 的方式向 ElasticSearch 服务器发送一个 GET 请求，即可查看 ElasticSearch 服务器的所有索引列表，具体可以执行如下请求：\n1 curl -XGET \u0026#39;http://localhost:9200/_cat/indices?v\u0026#39; 如何查看某个索引下的所有文档总数? 统计一个索引下的所有文档总数，也是一个非常常见的操作，可以直接通过 索引名称 加 _count 方式，向 ElasticSearch 服务器发送一个 GET 快速实现，具体可以执行如下命令：\n1 curl -XGET \u0026#34;http://localhost:9200/{index_name}/_count?pretty=true\u0026#34; 分组聚合数据 1 $ curl -XGET http://localhost:9200/fofaee_service/_search?pretty=true\u0026amp;q={\u0026#34;size\u0026#34;:0,\u0026#34;aggs\u0026#34;:{\u0026#34;group_by_ip\u0026#34;:{\u0026#34;terms\u0026#34;:{\u0026#34;field\u0026#34;:\u0026#34;ip\u0026#34;}}}} 文档操作 ElasticSearch中索引就是关系型数据库中的表，而文档就相当于关系型数据库中的记录，这样理解起来也非常简单。\n在elasticsearch 7.0.0版本必须使用单index,单type，多type结构则会完全移除。\n如何添加文档？ 在 ElasticSearch 7.0.0 及以后的版本中，官方要求必须使用单index，单type索引数据，并且默认type是 _doc，添加文档有两种方式:\n第一种是指定id值，id可以是整型，也可以是字符串，这个时候HTTP请求类型只能是 PUT。 第二种是不指定id值，这个时候HTTP请求类型只能是 POST，最终的文档数据 _id 字段是一个随机字符串。 如下面示例是通过明确指定id值的方式索引文档。注意这里的索引文档，与索引不是一个概念，索引作为名词是表示索引，索引作为动词时表示将文档添加到索引。\n1 2 3 4 5 6 curl -XPUT \u0026#34;http://localhost:9200/users/_doc/1?pretty=true\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39; { \u0026#34;username\u0026#34;: \u0026#34;helloshaohua\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;developer\u0026#34;, \u0026#34;sex\u0026#34;: \u0026#34;male\u0026#34; }\u0026#39; ElasticSearch 服务器，将会返回一个 JSON 对象，具体如下所示，其中 result，表示文档的添加状态，当前的执行结果为 created。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;users\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 1, \u0026#34;result\u0026#34; : \u0026#34;created\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 2, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 3, \u0026#34;_primary_term\u0026#34; : 1 } 如何查询文档？ 对于查询指定id值的文档，还是比较简单的，可以向 ElasticSearch 服务器发送一个 GET 请求，即可获取到指定id值的文档。例如，如下示例则是查询索引为 users 并且 id 为 1 的文档操作。\n1 curl -XGET \u0026#34;http://localhost:9200/users/_doc/1?pretty=true\u0026#34; ElasticSearch 服务器，则会返回如下 JSON 对象。注意，如果文档存在则 found 字段值为 true，否则为 false。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;users\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 1, \u0026#34;_seq_no\u0026#34; : 9, \u0026#34;_primary_term\u0026#34; : 1, \u0026#34;found\u0026#34; : true, \u0026#34;_source\u0026#34; : { \u0026#34;username\u0026#34; : \u0026#34;helloshaohua\u0026#34;, \u0026#34;title\u0026#34; : \u0026#34;developer\u0026#34;, \u0026#34;sex\u0026#34; : \u0026#34;male\u0026#34; } } 这里只是简单的通过指定 id 查询文档数据，后面会介绍数据检索查询文档操作。\n如何更新文档？ 对于上面添加的 user 用户，id 为 1，现在想将其用户名 username 修改为 tom，你可以指定全部字段，也可以指定部分字段，例如下面这个例子仅仅只是指定了提交的JSON数据对象为 {\u0026quot;username\u0026quot;: \u0026quot;tom\u0026quot;}，并没有指定 title 和 sex 字段，这完全是可以的。\n1 2 3 4 curl -XPUT \u0026#34;http://localhost:9200/users/_doc/1?pretty=true\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39; { \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34; }\u0026#39; ElasticSearch 服务器将会返回如下JSON对象，请注意当前的 result 为 updated，表示数据已经更新成功，而 _version 版本号也发生了变化，之前添加数据时，_version 版本号为 1，现在因为有数据更新了，它的数值也就更新了，具体数值为 2，注意哦，只要文档更新一次，_version 版本号也会随之加 1 更新，它表示当前文档存在多少次更新操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;users\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 2, \u0026#34;result\u0026#34; : \u0026#34;updated\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 2, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 5, \u0026#34;_primary_term\u0026#34; : 1 } 如何删除文档？ 删除文档操作，通过向 ElasticSearch 服务器发送一个 DELETE 请求来完成该操作。例如，如下示例则是删除 _id 为 1 的文档操作。\n1 curl -XDELETE \u0026#34;http://localhost:9200/users/_doc/1?pretty=true\u0026#34; ElasticSearch 服务器，将返回如下所示 JSON 对象。注意，当前 result 字段值为 deleted，表示 _id 为 1 的文档存在并且已经成功删除。如果文档记录不存在，则 result 字段值将为 not_found。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;_index\u0026#34; : \u0026#34;users\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_version\u0026#34; : 4, \u0026#34;result\u0026#34; : \u0026#34;deleted\u0026#34;, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 2, \u0026#34;successful\u0026#34; : 2, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;_seq_no\u0026#34; : 7, \u0026#34;_primary_term\u0026#34; : 1 } 文档检索 如何查看某个索引下的所有文档？ 查看一个索引下的所有文档，几乎是最简单的搜索了，可以直接通过 索引名称 加 _search 方式，向 ElasticSearch 服务器发送一个 GET 请求即可快速实现，例如，如下示例则是查询索引为 users 下的所示文档。\n1 curl -XGET \u0026#34;http://localhost:9200/users/_search?pretty=true\u0026#34; ElasticSearch 服务器，则会返回如下所示 JSON 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 { \u0026#34;took\u0026#34; : 15, \u0026#34;timed_out\u0026#34; : false, \u0026#34;_shards\u0026#34; : { \u0026#34;total\u0026#34; : 1, \u0026#34;successful\u0026#34; : 1, \u0026#34;skipped\u0026#34; : 0, \u0026#34;failed\u0026#34; : 0 }, \u0026#34;hits\u0026#34; : { \u0026#34;total\u0026#34; : { \u0026#34;value\u0026#34; : 2, \u0026#34;relation\u0026#34; : \u0026#34;eq\u0026#34; }, \u0026#34;max_score\u0026#34; : 1.0, \u0026#34;hits\u0026#34; : [ { \u0026#34;_index\u0026#34; : \u0026#34;users\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;LW4KbnsBtXWyKufeRPdK\u0026#34;, \u0026#34;_score\u0026#34; : 1.0, \u0026#34;_source\u0026#34; : { \u0026#34;username\u0026#34; : \u0026#34;helloshaohua\u0026#34;, \u0026#34;title\u0026#34; : \u0026#34;developer\u0026#34;, \u0026#34;sex\u0026#34; : \u0026#34;male\u0026#34; } }, { \u0026#34;_index\u0026#34; : \u0026#34;users\u0026#34;, \u0026#34;_type\u0026#34; : \u0026#34;_doc\u0026#34;, \u0026#34;_id\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;_score\u0026#34; : 1.0, \u0026#34;_source\u0026#34; : { \u0026#34;username\u0026#34; : \u0026#34;tom\u0026#34;, \u0026#34;title\u0026#34; : \u0026#34;developer, gopher, phper\u0026#34;, \u0026#34;sex\u0026#34; : \u0026#34;male\u0026#34; } } ] } } 其中 took 表示检测操作耗时，单位是毫秒。timed_out 字段表示该检索操作是否超时。hits 字段表示命中的记录，hits 子字段的具体含义如下所示：\ntotal: 返回记录数。 value: 具体的记录条数，当前示例是 2 条。 relation: 亲属关系，当前示例是 eq 相等。 max_score: 最高的匹配程度，当前示例是 1.0。 hits: 命中的记录组成的数组。 命中的 hits 文档数组中的每一条文档，都有一个 _score 字段，表示匹配的程度，值越大说明匹配程度就越相似，默认是按照这个 _score 字段降序排列。\n如何进行全文搜索？ 1 2 3 4 curl -XGET \u0026#34;http://localhost:9200/users/_search?pretty=true\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39; { \u0026#34;query\u0026#34;: {\u0026#34;match\u0026#34;: {\u0026#34;title\u0026#34;: \u0026#34;gopher\u0026#34;}} }\u0026#39; 相关参考 全文搜索引擎 Elasticsearch 入门教程 ","date":"2021-05-27","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/27/elasticsearch-use-logging/","tags":["elastic","search","logging"],"title":"ElasticSearch日常开发使用"},{"categories":["linux"],"contents":"无头Chrome就像是在没有UI（浏览器）的情况下运行chrome浏览器一样，也就是说，它在无头环境中运行，这对于运行自动化测试非常有用。\n那么，无头Chrome可以为我们做些什么呢？\n最令人兴奋的事情之一就是能够测试最新和最强大的Web平台功能，例如ES6模块，服务工作者和流。使用无头chrome，您可以编写应用程序并使用最新的渲染功能测试这些应用程序。它解锁的另一件事是这些很棒的功能，例如网络限制，设备仿真和代码覆盖。 使用无头chrome，您甚至无需编写任何代码即可执行测试，那不是很爽！\n您可以仅通过命令行执行它们。\n1 2 3 4 $ google-chrome-stable \\ --headless \\ --disable-gpu \\ --print-to-pdf=www.meipian.cn.pdf https://www.meipian.cn/ 1 2 3 4 $ google-chrome-stable \\ --headless \\ --disable-gpu \\ --screenshot=www.meipian.cn.png https://www.meipian.cn/ 1 2 3 4 5 $ google-chrome-stable \\ --headless \\ --disable-gpu \\ --dump-dom \\ https://www.meipian.cn/ \u0026gt;\u0026gt; www.meipian.cn.html 以上是一些常用的功能！更多功能可以学习Chrome浏览器功能具体列表。\nStep1:更新CentOS 使用以下命令更新CentOS系统。\n1 $ sudo yum update Step2:创建Chrome存储库YUM源 将google chrome存储库添加到系统。在/etc/yum.repos.d/中创建一个文件google-chrome.repo，并添加如下配置数据信息。\n1 2 3 4 5 6 [google-chrome] name=google-chrome baseurl=http://dl.google.com/linux/chrome/rpm/stable/$basearch enabled=1 gpgcheck=1 gpgkey=https://dl-ssl.google.com/linux/linux_signing_key.pub Step3:安装Chrome 运行下面的yum命令以在CentOS系统上安装google chrome。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 $ sudo yum -y install google-chrome-stable Loaded plugins: fastestmirror Determining fastest mirrors base | 3.6 kB 00:00:00 docker-ce-stable | 3.5 kB 00:00:00 epel | 4.7 kB 00:00:00 extras | 2.9 kB 00:00:00 google-chrome | 1.3 kB 00:00:00 updates | 2.9 kB 00:00:00 (1/7): epel/x86_64/group_gz | 96 kB 00:00:00 (2/7): epel/x86_64/updateinfo | 1.0 MB 00:00:00 (3/7): extras/7/x86_64/primary_db | 232 kB 00:00:00 (4/7): google-chrome/x86_64/primary | 1.7 kB 00:00:00 (5/7): epel/x86_64/primary_db | 6.9 MB 00:00:00 (6/7): updates/7/x86_64/primary_db | 7.1 MB 00:00:00 (7/7): docker-ce-stable/x86_64/primary_db | 60 kB 00:00:01 google-chrome 3/3 Resolving Dependencies --\u0026gt; Running transaction check ---\u0026gt; Package google-chrome-stable.x86_64 0:90.0.4430.85-1 will be installed --\u0026gt; Processing Dependency: xdg-utils for package: google-chrome-stable-90.0.4430.85-1.x86_64 --\u0026gt; Processing Dependency: liberation-fonts for package: google-chrome-stable-90.0.4430.85-1.x86_64 --\u0026gt; Processing Dependency: libvulkan.so.1()(64bit) for package: google-chrome-stable-90.0.4430.85-1.x86_64 --\u0026gt; Running transaction check ---\u0026gt; Package liberation-fonts.noarch 1:1.07.2-16.el7 will be installed --\u0026gt; Processing Dependency: liberation-serif-fonts = 1:1.07.2-16.el7 for package: 1:liberation-fonts-1.07.2-16.el7.noarch --\u0026gt; Processing Dependency: liberation-sans-fonts = 1:1.07.2-16.el7 for package: 1:liberation-fonts-1.07.2-16.el7.noarch --\u0026gt; Processing Dependency: liberation-narrow-fonts = 1:1.07.2-16.el7 for package: 1:liberation-fonts-1.07.2-16.el7.noarch --\u0026gt; Processing Dependency: liberation-mono-fonts = 1:1.07.2-16.el7 for package: 1:liberation-fonts-1.07.2-16.el7.noarch ---\u0026gt; Package vulkan.x86_64 0:1.1.97.0-1.el7 will be installed --\u0026gt; Processing Dependency: vulkan-filesystem = 1.1.97.0-1.el7 for package: vulkan-1.1.97.0-1.el7.x86_64 ---\u0026gt; Package xdg-utils.noarch 0:1.1.0-0.17.20120809git.el7 will be installed --\u0026gt; Running transaction check ---\u0026gt; Package liberation-mono-fonts.noarch 1:1.07.2-16.el7 will be installed --\u0026gt; Processing Dependency: liberation-fonts-common = 1:1.07.2-16.el7 for package: 1:liberation-mono-fonts-1.07.2-16.el7.noarch ---\u0026gt; Package liberation-narrow-fonts.noarch 1:1.07.2-16.el7 will be installed ---\u0026gt; Package liberation-sans-fonts.noarch 1:1.07.2-16.el7 will be installed ---\u0026gt; Package liberation-serif-fonts.noarch 1:1.07.2-16.el7 will be installed ---\u0026gt; Package vulkan-filesystem.noarch 0:1.1.97.0-1.el7 will be installed --\u0026gt; Running transaction check ---\u0026gt; Package liberation-fonts-common.noarch 1:1.07.2-16.el7 will be installed --\u0026gt; Finished Dependency Resolution Dependencies Resolved ======================================================================================================== Package Arch Version Repository Size ======================================================================================================== Installing: google-chrome-stable x86_64 90.0.4430.85-1 google-chrome 79 M Installing for dependencies: liberation-fonts noarch 1:1.07.2-16.el7 base 13 k liberation-fonts-common noarch 1:1.07.2-16.el7 base 27 k liberation-mono-fonts noarch 1:1.07.2-16.el7 base 227 k liberation-narrow-fonts noarch 1:1.07.2-16.el7 base 202 k liberation-sans-fonts noarch 1:1.07.2-16.el7 base 279 k liberation-serif-fonts noarch 1:1.07.2-16.el7 base 298 k vulkan x86_64 1.1.97.0-1.el7 base 3.6 M vulkan-filesystem noarch 1.1.97.0-1.el7 base 6.3 k xdg-utils noarch 1.1.0-0.17.20120809git.el7 base 70 k Transaction Summary ======================================================================================================== Install 1 Package (+9 Dependent packages) Total download size: 84 M Installed size: 273 M Downloading packages: (1/10): liberation-fonts-1.07.2-16.el7.noarch.rpm | 13 kB 00:00:00 (2/10): liberation-fonts-common-1.07.2-16.el7.noarch.rpm | 27 kB 00:00:00 (3/10): liberation-mono-fonts-1.07.2-16.el7.noarch.rpm | 227 kB 00:00:00 (4/10): liberation-narrow-fonts-1.07.2-16.el7.noarch.rpm | 202 kB 00:00:00 (5/10): liberation-sans-fonts-1.07.2-16.el7.noarch.rpm | 279 kB 00:00:00 (6/10): liberation-serif-fonts-1.07.2-16.el7.noarch.rpm | 298 kB 00:00:00 (7/10): vulkan-filesystem-1.1.97.0-1.el7.noarch.rpm | 6.3 kB 00:00:00 (8/10): xdg-utils-1.1.0-0.17.20120809git.el7.noarch.rpm | 70 kB 00:00:00 (9/10): vulkan-1.1.97.0-1.el7.x86_64.rpm | 3.6 MB 00:00:00 warning: /var/cache/yum/x86_64/7/google-chrome/packages/google-chrome-stable-90.0.4430.85-1.x86_64.rpm: Header V4 DSA/SHA1 Signature, key ID 7fac5991: NOKEY Public key for google-chrome-stable-90.0.4430.85-1.x86_64.rpm is not installed (10/10): google-chrome-stable-90.0.4430.85-1.x86_64.rpm | 79 MB 00:00:06 -------------------------------------------------------------------------------------------------------- Total 13 MB/s | 84 MB 00:00:06 Retrieving key from https://dl-ssl.google.com/linux/linux_signing_key.pub GPG key retrieval failed: [Errno 14] curl#7 - \u0026#34;Failed connect to dl-ssl.google.com:443; Operation now in progress\u0026#34; 报错了！没有安装成功哦，可以看到它从https://dl-ssl.google.com/linux/linux_signing_key.pub检索一个签署文件，也就是公私文件。由于国内的网络环境，服务器不能直接访问到Google的服务器，所示它GPG密钥检索失败了。可以到可以访问到Google的网络中下载linux_signing_key.pub这个文件。然后上传到服务。\nStep4: 手动导入签名密钥 如果没有报错请直接到Step5, 一般不出意外都会报错哦，哈哈~\n上传文件后执行导入签名密钥操作。\n1 $ sudo rpm --import linux_signing_key.pub 执行以上命令后即可将签名密钥导入到rpm包管理器，再次执行第三步即可安装成功。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 $ sudo yum -y install google-chrome-stable Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile Resolving Dependencies --\u0026gt; Running transaction check ---\u0026gt; Package google-chrome-stable.x86_64 0:90.0.4430.85-1 will be installed --\u0026gt; Processing Dependency: xdg-utils for package: google-chrome-stable-90.0.4430.85-1.x86_64 --\u0026gt; Processing Dependency: liberation-fonts for package: google-chrome-stable-90.0.4430.85-1.x86_64 --\u0026gt; Processing Dependency: libvulkan.so.1()(64bit) for package: google-chrome-stable-90.0.4430.85-1.x86_64 --\u0026gt; Running transaction check ---\u0026gt; Package liberation-fonts.noarch 1:1.07.2-16.el7 will be installed --\u0026gt; Processing Dependency: liberation-serif-fonts = 1:1.07.2-16.el7 for package: 1:liberation-fonts-1.07.2-16.el7.noarch --\u0026gt; Processing Dependency: liberation-sans-fonts = 1:1.07.2-16.el7 for package: 1:liberation-fonts-1.07.2-16.el7.noarch --\u0026gt; Processing Dependency: liberation-narrow-fonts = 1:1.07.2-16.el7 for package: 1:liberation-fonts-1.07.2-16.el7.noarch --\u0026gt; Processing Dependency: liberation-mono-fonts = 1:1.07.2-16.el7 for package: 1:liberation-fonts-1.07.2-16.el7.noarch ---\u0026gt; Package vulkan.x86_64 0:1.1.97.0-1.el7 will be installed --\u0026gt; Processing Dependency: vulkan-filesystem = 1.1.97.0-1.el7 for package: vulkan-1.1.97.0-1.el7.x86_64 ---\u0026gt; Package xdg-utils.noarch 0:1.1.0-0.17.20120809git.el7 will be installed --\u0026gt; Running transaction check ---\u0026gt; Package liberation-mono-fonts.noarch 1:1.07.2-16.el7 will be installed --\u0026gt; Processing Dependency: liberation-fonts-common = 1:1.07.2-16.el7 for package: 1:liberation-mono-fonts-1.07.2-16.el7.noarch ---\u0026gt; Package liberation-narrow-fonts.noarch 1:1.07.2-16.el7 will be installed ---\u0026gt; Package liberation-sans-fonts.noarch 1:1.07.2-16.el7 will be installed ---\u0026gt; Package liberation-serif-fonts.noarch 1:1.07.2-16.el7 will be installed ---\u0026gt; Package vulkan-filesystem.noarch 0:1.1.97.0-1.el7 will be installed --\u0026gt; Running transaction check ---\u0026gt; Package liberation-fonts-common.noarch 1:1.07.2-16.el7 will be installed --\u0026gt; Finished Dependency Resolution Dependencies Resolved ======================================================================================================================== Package Arch Version Repository Size ======================================================================================================================== Installing: google-chrome-stable x86_64 90.0.4430.85-1 google-chrome 79 M Installing for dependencies: liberation-fonts noarch 1:1.07.2-16.el7 base 13 k liberation-fonts-common noarch 1:1.07.2-16.el7 base 27 k liberation-mono-fonts noarch 1:1.07.2-16.el7 base 227 k liberation-narrow-fonts noarch 1:1.07.2-16.el7 base 202 k liberation-sans-fonts noarch 1:1.07.2-16.el7 base 279 k liberation-serif-fonts noarch 1:1.07.2-16.el7 base 298 k vulkan x86_64 1.1.97.0-1.el7 base 3.6 M vulkan-filesystem noarch 1.1.97.0-1.el7 base 6.3 k xdg-utils noarch 1.1.0-0.17.20120809git.el7 base 70 k Transaction Summary ======================================================================================================================== Install 1 Package (+9 Dependent packages) Total size: 84 M Installed size: 273 M Downloading packages: Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : 1:liberation-fonts-common-1.07.2-16.el7.noarch 1/10 Installing : 1:liberation-narrow-fonts-1.07.2-16.el7.noarch 2/10 Installing : 1:liberation-mono-fonts-1.07.2-16.el7.noarch 3/10 Installing : 1:liberation-sans-fonts-1.07.2-16.el7.noarch 4/10 Installing : 1:liberation-serif-fonts-1.07.2-16.el7.noarch 5/10 Installing : 1:liberation-fonts-1.07.2-16.el7.noarch 6/10 Installing : vulkan-filesystem-1.1.97.0-1.el7.noarch 7/10 Installing : vulkan-1.1.97.0-1.el7.x86_64 8/10 Installing : xdg-utils-1.1.0-0.17.20120809git.el7.noarch 9/10 Installing : google-chrome-stable-90.0.4430.85-1.x86_64 10/10 Verifying : vulkan-1.1.97.0-1.el7.x86_64 1/10 Verifying : 1:liberation-fonts-1.07.2-16.el7.noarch 2/10 Verifying : 1:liberation-fonts-common-1.07.2-16.el7.noarch 3/10 Verifying : 1:liberation-narrow-fonts-1.07.2-16.el7.noarch 4/10 Verifying : xdg-utils-1.1.0-0.17.20120809git.el7.noarch 5/10 Verifying : 1:liberation-mono-fonts-1.07.2-16.el7.noarch 6/10 Verifying : 1:liberation-sans-fonts-1.07.2-16.el7.noarch 7/10 Verifying : 1:liberation-serif-fonts-1.07.2-16.el7.noarch 8/10 Verifying : google-chrome-stable-90.0.4430.85-1.x86_64 9/10 Verifying : vulkan-filesystem-1.1.97.0-1.el7.noarch 10/10 Installed: google-chrome-stable.x86_64 0:90.0.4430.85-1 Dependency Installed: liberation-fonts.noarch 1:1.07.2-16.el7 liberation-fonts-common.noarch 1:1.07.2-16.el7 liberation-mono-fonts.noarch 1:1.07.2-16.el7 liberation-narrow-fonts.noarch 1:1.07.2-16.el7 liberation-sans-fonts.noarch 1:1.07.2-16.el7 liberation-serif-fonts.noarch 1:1.07.2-16.el7 vulkan.x86_64 0:1.1.97.0-1.el7 vulkan-filesystem.noarch 0:1.1.97.0-1.el7 xdg-utils.noarch 0:1.1.0-0.17.20120809git.el7 Complete! Step5: 验证是否安装成功 1 2 $ google-chrome-stable -version Google Chrome 90.0.4430.85 Step6: 你可以探索了 使用无头的Chrome可以做很多事情，AJAX爬虫、截屏、保存网页为PDF等等吧~\n参考文档 Google Linux Software Repositories. ","date":"2021-05-27","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/27/centos-install-headless-chrome/","tags":["chrome","headless"],"title":"CentOS安装无头Chrome"},{"categories":["tool"],"contents":"可以这么理解Makefile是用于管理项目的一种工具，它来自GNU，比如您呢好在项目下使用docker-compose工具运行容器，这个时候呢，您一般会输入docker-compose -f docker-compose.yaml up -d 进行项目容器的启动，如果您要把这个容器及网卡等一系列与这个容器服务相关的服务也停止掉的话，您会执行 docker-compose down 命令进行操作，这很好，您如果不嫌麻烦的话您可以先停止掉依赖的网卡了（如果有的话），然后再停止掉容器，这样也是可以的，不过呢，您有没有感觉这么一来，就会很麻烦，Makefile给我们来解决这些个麻烦，您只需要在项目目录下添加一个Makefile即可给您带来极大的方便，如果我们有多个容器要管理的话这个方便之处简直会让您为之大叫~\n二、如何编写Makefile？ 我们来说一下就上面我们使用docker-compose管理容器时执行的一系列命令如果让Makefile为我们执行，废话不多话，写一个Makefile，来说明！\n2.1、添加Makefile 在您的项目目录下添加一个Makefile\n1 $ touch Makefile 2.2、编写Makefile命令 在这个Makefile中我们编写以下代码：\n1 2 3 4 5 6 7 .PHONY: docker-compose-up docker-compose-up: docker-compose -f docker-compose.yaml up -d .PHONY: docker-compose-down docker-compose-down: docker-compose down 以上呢我们添加了两个伪命令，这两个伪命令就可以为我们执行容器的启动与停止操作。定义一个伪命令以 .PHONY: 开头，后面就是伪命令名称，然后另起一行，顶格声明这个伪命令以冒号:结尾，然后再另起一行输入这个伪命令要执行的命令，注意要有一个TAB键的缩进，每一个要执行的命令要占一行！这样就声明了一个Makefile伪命令了！\n注意：我们一直说它是伪命令，这是相对于系统级别命令而言的命令，所以它在Makefile也只能算是伪命令了！\n三、如果使用？ 这些在Makefile文件中定义的伪命令不能像系统级别的命令那样直接输入：\n1 $ docker-compose-up 这样执行，系统它不认识它哦！要使用 make 加伪命令的形式才可以：\n1 $ make docker-compose-up 启动容器\n1 $ make docker-compose-down 停止容器\n四、后续？ 关于Makefile您可以更深入的学习哦~\n","date":"2021-05-27","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/27/makefile-simple-use/","tags":["tool","makefile"],"title":"Makefile快速入门"},{"categories":["tool"],"contents":"在开发的过程中会使用CURL命令请求API接口，而一般情况下API接口也是返回JSON数据，但是如果直接使用 curl -X GET https://news-at.zhihu.com/api/4/news/latest 这种方式访问API接口的话，你会发现终端输出的是一行JSON数据，如果可以美化一下JSON数据在终端输出岂不美哉~\n二、格式化CURL返回的JSON数据有两种方式 分别是 PYTHON格式化 和 NODEJS格式化。\n2.1、PYTHON格式化 在CURL命令后面添加 | python -m json.tool 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 $ curl -X GET https://news-at.zhihu.com/api/4/news/latest | python -m json.tool % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 3376 100 3376 0 0 39255 0 --:--:-- --:--:-- --:--:-- 39255 { \u0026#34;date\u0026#34;: \u0026#34;20210314\u0026#34;, \u0026#34;stories\u0026#34;: [ { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;VOL.1280\u0026#34;, \u0026#34;id\u0026#34;: 9734064, \u0026#34;image_hue\u0026#34;: \u0026#34;0x7d99b3\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic4.zhimg.com/v2-20daa5159cfc755c20f5f3551ce0d973.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u5c0f\\u4e8b \\u00b7 \\u5e78\\u597d\\uff0c\\u8fd8\\u6709\\u300c\\u89e3\\u8bed\\u82b1\\u300d\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9734064\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4e01\\u9999\\u533b\\u751f \\u00b7 2 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9734000, \u0026#34;image_hue\u0026#34;: \u0026#34;0xb3887d\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic2.zhimg.com/v2-957091b824ded683e0cba948a6b71eb8.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u4eba\\u7684\\u773c\\u76ae\\u4e3a\\u4ec0\\u4e48\\u4f1a\\u8df3\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9734000\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u77e5\\u4e4e\\u7528\\u6237 \\u00b7 4 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9734009, \u0026#34;image_hue\u0026#34;: \u0026#34;0xa19170\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic4.zhimg.com/v2-a74d3680fc11fcf18bc6646f44f07135.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u4e3a\\u4ec0\\u4e48\\u79d2\\u7684\\u5b9a\\u4e49\\u8fd9\\u4e48\\u590d\\u6742\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9734009\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u8d75\\u5fb7\\u4f4f \\u00b7 1 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9733995, \u0026#34;image_hue\u0026#34;: \u0026#34;0x523c31\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic1.zhimg.com/v2-5ee75baffaac2e06099a5ddef02df5d0.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u6709\\u54ea\\u4e9b\\u4ee5\\u524d\\u5f88\\u706b\\uff0c\\u73b0\\u5728\\u5374\\u88ab\\u53d1\\u73b0\\u662f\\u5f88\\u5371\\u9669\\u7684\\u53d1\\u660e\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733995\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u80e1\\u8000\\u5b87 \\u00b7 4 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9733994, \u0026#34;image_hue\u0026#34;: \u0026#34;0xa5846c\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic1.zhimg.com/v2-e44b65ecfdda76e21df0aa0d5f16d50e.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u73b0\\u4ee3\\u4eba\\u7684\\u56f4\\u68cb\\u6280\\u827a\\u4e0e\\u53e4\\u4eba\\u76f8\\u6bd4\\u662f\\u5426\\u6709\\u63d0\\u9ad8\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733994\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u8fd0\\u52a8\\u5206\\u5b50 \\u00b7 2 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9733993, \u0026#34;image_hue\u0026#34;: \u0026#34;0x453830\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic2.zhimg.com/v2-a0e70b2062517f0e6cfa28dfdfd17126.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u5965\\u8fd0\\u4f1a\\u5c04\\u51fb\\u662f\\u5426\\u5141\\u8bb8\\u72d9\\u51fb\\u624b\\u53c2\\u8d5b\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733993\u0026#34; } ], \u0026#34;top_stories\u0026#34;: [ { \u0026#34;ga_prefix\u0026#34;: \u0026#34;030707\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u53f8\\u9a6c\\u671b\\u7530\u0026#34;, \u0026#34;id\u0026#34;: 9733765, \u0026#34;image\u0026#34;: \u0026#34;https://pic2.zhimg.com/v2-24a178e99daa4833b6c2e5bb8b318366.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0xb3847d\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u5730\\u94c1\\u5217\\u8f66\\u665a\\u4e0a\\u90fd\\u505c\\u5728\\u54ea\\u91cc\\u5462\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733765\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;030507\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u963f\\u6e90\\u8001\\u5e08\u0026#34;, \u0026#34;id\u0026#34;: 9733704, \u0026#34;image\u0026#34;: \u0026#34;https://pic4.zhimg.com/v2-11697abd3c557ac1394c829506379789.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0x29303b\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u4e3a\\u4ec0\\u4e48\\u6709\\u4eba\\u7ecf\\u5e38\\u751f\\u75c5\\uff0c\\u6709\\u4eba\\u5374\\u5f88\\u5065\\u5eb7\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733704\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;022807\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u751c\\u8349\\u8393\u0026#34;, \u0026#34;id\u0026#34;: 9733550, \u0026#34;image\u0026#34;: \u0026#34;https://pic1.zhimg.com/v2-25ed43abad9026b203746e9c22d4a35d.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0x253625\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u6ca1\\u6709\\u4fe1\\u53f7\\u7684\\u65f6\\u5019\\u628a\\u624b\\u673a\\u4e3e\\u9ad8\\u9ad8\\u6709\\u7528\\u5417\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733550\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;022607\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u662f\\u963f\\u5f6c\\u4e0d\\u662f\\u963f\\u5bbe\u0026#34;, \u0026#34;id\u0026#34;: 9733459, \u0026#34;image\u0026#34;: \u0026#34;https://pic1.zhimg.com/v2-b67669750f46868af39cafce3a0cd278.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0x3c3b19\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u53e4\\u4ee3\\u4eba\\u53d1\\u73b0\\u8fc7\\u6050\\u9f99\\u5316\\u77f3\\u5417\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733459\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;022407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u4e94\\u83b2\\u82b1\\u5f00\u0026#34;, \u0026#34;id\u0026#34;: 9733383, \u0026#34;image\u0026#34;: \u0026#34;https://pic4.zhimg.com/v2-35592f1482474f7515f6e0b585839f9b.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0x7d95b3\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u732b\\u4ece\\u9ad8\\u5904\\u843d\\u4e0b\\uff0c\\u4e3a\\u4ec0\\u4e48\\u603b\\u80fd\\u56db\\u811a\\u7740\\u5730\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733383\u0026#34; } ] } 如果不想显示CURL的统计信息，可以参考这篇文章，添加 -s 参数即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 $ curl -X GET https://news-at.zhihu.com/api/4/news/latest -s | python -m json.tool { \u0026#34;date\u0026#34;: \u0026#34;20210314\u0026#34;, \u0026#34;stories\u0026#34;: [ { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;VOL.1280\u0026#34;, \u0026#34;id\u0026#34;: 9734064, \u0026#34;image_hue\u0026#34;: \u0026#34;0x7d99b3\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic4.zhimg.com/v2-20daa5159cfc755c20f5f3551ce0d973.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u5c0f\\u4e8b \\u00b7 \\u5e78\\u597d\\uff0c\\u8fd8\\u6709\\u300c\\u89e3\\u8bed\\u82b1\\u300d\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9734064\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4e01\\u9999\\u533b\\u751f \\u00b7 2 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9734000, \u0026#34;image_hue\u0026#34;: \u0026#34;0xb3887d\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic2.zhimg.com/v2-957091b824ded683e0cba948a6b71eb8.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u4eba\\u7684\\u773c\\u76ae\\u4e3a\\u4ec0\\u4e48\\u4f1a\\u8df3\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9734000\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u77e5\\u4e4e\\u7528\\u6237 \\u00b7 4 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9734009, \u0026#34;image_hue\u0026#34;: \u0026#34;0xa19170\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic4.zhimg.com/v2-a74d3680fc11fcf18bc6646f44f07135.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u4e3a\\u4ec0\\u4e48\\u79d2\\u7684\\u5b9a\\u4e49\\u8fd9\\u4e48\\u590d\\u6742\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9734009\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u8d75\\u5fb7\\u4f4f \\u00b7 1 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9733995, \u0026#34;image_hue\u0026#34;: \u0026#34;0x523c31\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic1.zhimg.com/v2-5ee75baffaac2e06099a5ddef02df5d0.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u6709\\u54ea\\u4e9b\\u4ee5\\u524d\\u5f88\\u706b\\uff0c\\u73b0\\u5728\\u5374\\u88ab\\u53d1\\u73b0\\u662f\\u5f88\\u5371\\u9669\\u7684\\u53d1\\u660e\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733995\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u80e1\\u8000\\u5b87 \\u00b7 4 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9733994, \u0026#34;image_hue\u0026#34;: \u0026#34;0xa5846c\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic1.zhimg.com/v2-e44b65ecfdda76e21df0aa0d5f16d50e.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u73b0\\u4ee3\\u4eba\\u7684\\u56f4\\u68cb\\u6280\\u827a\\u4e0e\\u53e4\\u4eba\\u76f8\\u6bd4\\u662f\\u5426\\u6709\\u63d0\\u9ad8\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733994\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;031407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u8fd0\\u52a8\\u5206\\u5b50 \\u00b7 2 \\u5206\\u949f\\u9605\\u8bfb\u0026#34;, \u0026#34;id\u0026#34;: 9733993, \u0026#34;image_hue\u0026#34;: \u0026#34;0x453830\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;https://pic2.zhimg.com/v2-a0e70b2062517f0e6cfa28dfdfd17126.jpg?source=8673f162\u0026#34; ], \u0026#34;title\u0026#34;: \u0026#34;\\u5965\\u8fd0\\u4f1a\\u5c04\\u51fb\\u662f\\u5426\\u5141\\u8bb8\\u72d9\\u51fb\\u624b\\u53c2\\u8d5b\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733993\u0026#34; } ], \u0026#34;top_stories\u0026#34;: [ { \u0026#34;ga_prefix\u0026#34;: \u0026#34;030707\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u53f8\\u9a6c\\u671b\\u7530\u0026#34;, \u0026#34;id\u0026#34;: 9733765, \u0026#34;image\u0026#34;: \u0026#34;https://pic2.zhimg.com/v2-24a178e99daa4833b6c2e5bb8b318366.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0xb3847d\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u5730\\u94c1\\u5217\\u8f66\\u665a\\u4e0a\\u90fd\\u505c\\u5728\\u54ea\\u91cc\\u5462\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733765\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;030507\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u963f\\u6e90\\u8001\\u5e08\u0026#34;, \u0026#34;id\u0026#34;: 9733704, \u0026#34;image\u0026#34;: \u0026#34;https://pic4.zhimg.com/v2-11697abd3c557ac1394c829506379789.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0x29303b\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u4e3a\\u4ec0\\u4e48\\u6709\\u4eba\\u7ecf\\u5e38\\u751f\\u75c5\\uff0c\\u6709\\u4eba\\u5374\\u5f88\\u5065\\u5eb7\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733704\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;022807\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u751c\\u8349\\u8393\u0026#34;, \u0026#34;id\u0026#34;: 9733550, \u0026#34;image\u0026#34;: \u0026#34;https://pic1.zhimg.com/v2-25ed43abad9026b203746e9c22d4a35d.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0x253625\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u6ca1\\u6709\\u4fe1\\u53f7\\u7684\\u65f6\\u5019\\u628a\\u624b\\u673a\\u4e3e\\u9ad8\\u9ad8\\u6709\\u7528\\u5417\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733550\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;022607\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u662f\\u963f\\u5f6c\\u4e0d\\u662f\\u963f\\u5bbe\u0026#34;, \u0026#34;id\u0026#34;: 9733459, \u0026#34;image\u0026#34;: \u0026#34;https://pic1.zhimg.com/v2-b67669750f46868af39cafce3a0cd278.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0x3c3b19\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u53e4\\u4ee3\\u4eba\\u53d1\\u73b0\\u8fc7\\u6050\\u9f99\\u5316\\u77f3\\u5417\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733459\u0026#34; }, { \u0026#34;ga_prefix\u0026#34;: \u0026#34;022407\u0026#34;, \u0026#34;hint\u0026#34;: \u0026#34;\\u4f5c\\u8005 / \\u4e94\\u83b2\\u82b1\\u5f00\u0026#34;, \u0026#34;id\u0026#34;: 9733383, \u0026#34;image\u0026#34;: \u0026#34;https://pic4.zhimg.com/v2-35592f1482474f7515f6e0b585839f9b.jpg?source=8673f162\u0026#34;, \u0026#34;image_hue\u0026#34;: \u0026#34;0x7d95b3\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;\\u732b\\u4ece\\u9ad8\\u5904\\u843d\\u4e0b\\uff0c\\u4e3a\\u4ec0\\u4e48\\u603b\\u80fd\\u56db\\u811a\\u7740\\u5730\\uff1f\u0026#34;, \u0026#34;type\u0026#34;: 0, \u0026#34;url\u0026#34;: \u0026#34;https://daily.zhihu.com/story/9733383\u0026#34; } ] } 2.2、NODEJS格式化 使用NODEJS格式化需要使用NPM安装一个JSON处理库。执行 npm install -g json 后，在CURL命令后面添加 | json 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 curl -X GET https://news-at.zhihu.com/api/4/news/latest -s | json { \u0026#34;date\u0026#34;:\u0026#34;20210314\u0026#34;, \u0026#34;stories\u0026#34;:[ { \u0026#34;image_hue\u0026#34;:\u0026#34;0x7d99b3\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;小事 · 幸好，还有「解语花」\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9734064\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;VOL.1280\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;031407\u0026#34;, \u0026#34;images\u0026#34;:[ \u0026#34;https://pic4.zhimg.com/v2-20daa5159cfc755c20f5f3551ce0d973.jpg?source=8673f162\u0026#34; ], \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9734064 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0xb3887d\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;人的眼皮为什么会跳？\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9734000\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;丁香医生 · 2 分钟阅读\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;031407\u0026#34;, \u0026#34;images\u0026#34;:[ \u0026#34;https://pic2.zhimg.com/v2-957091b824ded683e0cba948a6b71eb8.jpg?source=8673f162\u0026#34; ], \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9734000 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0xa19170\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;为什么秒的定义这么复杂？\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9734009\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;知乎用户 · 4 分钟阅读\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;031407\u0026#34;, \u0026#34;images\u0026#34;:[ \u0026#34;https://pic4.zhimg.com/v2-a74d3680fc11fcf18bc6646f44f07135.jpg?source=8673f162\u0026#34; ], \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9734009 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0x523c31\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;有哪些以前很火，现在却被发现是很危险的发明？\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9733995\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;赵德住 · 1 分钟阅读\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;031407\u0026#34;, \u0026#34;images\u0026#34;:[ \u0026#34;https://pic1.zhimg.com/v2-5ee75baffaac2e06099a5ddef02df5d0.jpg?source=8673f162\u0026#34; ], \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9733995 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0xa5846c\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;现代人的围棋技艺与古人相比是否有提高？\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9733994\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;胡耀宇 · 4 分钟阅读\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;031407\u0026#34;, \u0026#34;images\u0026#34;:[ \u0026#34;https://pic1.zhimg.com/v2-e44b65ecfdda76e21df0aa0d5f16d50e.jpg?source=8673f162\u0026#34; ], \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9733994 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0x453830\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;奥运会射击是否允许狙击手参赛？\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9733993\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;运动分子 · 2 分钟阅读\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;031407\u0026#34;, \u0026#34;images\u0026#34;:[ \u0026#34;https://pic2.zhimg.com/v2-a0e70b2062517f0e6cfa28dfdfd17126.jpg?source=8673f162\u0026#34; ], \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9733993 } ], \u0026#34;top_stories\u0026#34;:[ { \u0026#34;image_hue\u0026#34;:\u0026#34;0xb3847d\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;作者 / 司马望田\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9733765\u0026#34;, \u0026#34;image\u0026#34;:\u0026#34;https://pic2.zhimg.com/v2-24a178e99daa4833b6c2e5bb8b318366.jpg?source=8673f162\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;地铁列车晚上都停在哪里呢？\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;030707\u0026#34;, \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9733765 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0x29303b\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;作者 / 阿源老师\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9733704\u0026#34;, \u0026#34;image\u0026#34;:\u0026#34;https://pic4.zhimg.com/v2-11697abd3c557ac1394c829506379789.jpg?source=8673f162\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;为什么有人经常生病，有人却很健康？\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;030507\u0026#34;, \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9733704 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0x253625\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;作者 / 甜草莓\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9733550\u0026#34;, \u0026#34;image\u0026#34;:\u0026#34;https://pic1.zhimg.com/v2-25ed43abad9026b203746e9c22d4a35d.jpg?source=8673f162\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;没有信号的时候把手机举高高有用吗？\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;022807\u0026#34;, \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9733550 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0x3c3b19\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;作者 / 是阿彬不是阿宾\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9733459\u0026#34;, \u0026#34;image\u0026#34;:\u0026#34;https://pic1.zhimg.com/v2-b67669750f46868af39cafce3a0cd278.jpg?source=8673f162\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;古代人发现过恐龙化石吗？\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;022607\u0026#34;, \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9733459 }, { \u0026#34;image_hue\u0026#34;:\u0026#34;0x7d95b3\u0026#34;, \u0026#34;hint\u0026#34;:\u0026#34;作者 / 五莲花开\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;https://daily.zhihu.com/story/9733383\u0026#34;, \u0026#34;image\u0026#34;:\u0026#34;https://pic4.zhimg.com/v2-35592f1482474f7515f6e0b585839f9b.jpg?source=8673f162\u0026#34;, \u0026#34;title\u0026#34;:\u0026#34;猫从高处落下，为什么总能四脚着地？\u0026#34;, \u0026#34;ga_prefix\u0026#34;:\u0026#34;022407\u0026#34;, \u0026#34;type\u0026#34;:0, \u0026#34;id\u0026#34;:9733383 } ] } 2.3、PYTHON格式化与NODEJS格式化的区别 PYTHON格式化，有于 json.tool 实现问题不支持处理UTF-8字符集，自然也就无法处理中文。NODEJS格式化使用的JSON库可以完美支持处理UTF-8字符集。\n三、更多可以参考：CSDN | 格式化Curl返回的Json字符 ","date":"2021-05-27","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/27/format-the-json-data-returned-by-curl/","tags":["curl","json","format"],"title":"格式化curl返回的JSON数据"},{"categories":["Git"],"contents":"当远程分支不再使用或者需要废弃时，你可以通过登录到远程仓库进行删除分支操作，但是这样不够方便快捷，我们可以通过在本地执行一个Git命令即可快速将远程分支删除掉。\nStep1、查看远程分支 要删除远程分支首先要查询一下远程到底有哪些分支可以执行以下命令，进行查询：\n1 $ git branch -r 具体输出如下所示：\n1 2 3 4 5 6 $ git branch -r origin/gin origin/master origin/middleware origin/step1 (END) 在清楚的知道了远程有哪分支后，就可以执行删除命令了，请参考 。\nStep2、删除远程分支 具体的命令如下：\n1 $ git push origin --delete \u0026lt;origin-branch-name\u0026gt; 请您记住喽，删除远程分支的过程就是在推送的过程中添加 --delete 参数 并指定分支名称，具体如下所示：\n1 2 3 4 5 $ git push origin --delete step1 remote: . Processing 1 references remote: Processed 1 references in total To git.wumoxi.com:fleabane/validator.git - [deleted] step1 ","date":"2021-05-27","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/27/how-does-git-delete-a-remote-branch/","tags":["git","github","branch","delete"],"title":"Git如何删除远程分支"},{"categories":["Shell"],"contents":"在使用Hugo写博客的时候，添加一遍博文，如果内容是支持多语言的话，添加每种语言markdown文件都需要执行一次Hugo命令，着实非常不方便，于是乎写一个Shell脚本就可以解决这个非常不愉快的操作体验，具体可以写一个Shell脚本去一次性的完成这个重复而没有任何意义的操作。仔细分析一下这个要写的Shell脚本，其实非常简单就可以实现: 定义一个目录常量，定义一语言数组，让用户输入三个参数，其中前两个是必传参数，最后一个参数是可选参数，依次表示，要生成的markdown文件存放目录，markdown文件名，以及是否要使用日期目录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #!/bin/bash #################################################################### # 定义变量区 #################################################################### # Markdown 文件扩展名. MARKDOWN_FILE_EXTENSION=\u0026#34;.md\u0026#34; # Markdown 目录. MARKDOWN_CONTENT_DIR=\u0026#34;./content\u0026#34; # 语言数组定义 MARKDOWN_CONTENT_LANGUAGES=(\u0026#34;chinese\u0026#34; \u0026#34;english\u0026#34;) # 当前日期 CURRENT_DATE=`date +\u0026#34;%Y-%m-%d\u0026#34;` #################################################################### # 定义函数区 #################################################################### # PrintLogFunc 格式化打印日志函数. # 该函数有两个参数： # 第一个参数: 日志信息的描述信息. # 第二个参数: 输出文字渲染颜色. function PrintLogFunc() { log_info=$1 use_color=$2 # 如果{输出文字渲染颜色}长度为0时，则使用默认颜色. if [ -z \u0026#34;$use_color\u0026#34; ]; then use_color=0 fi # 如果{输出文字渲染颜色}参数为1时，时使用{蓝色}文字，否则默认文字颜色. if [ $use_color = \u0026#34;WARNING\u0026#34; ]; then echo -e \u0026#34;\\n\\033[31m[`date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;`] WARNING - ${log_info} \\033[0m\u0026#34; elif [ $use_color = \u0026#34;INFO\u0026#34; ]; then echo -e \u0026#34;\\n\\033[32m[`date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;`] INFO - ${log_info} \\033[0m\u0026#34; else echo \u0026#34;[`date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;`] DEBUG - ${log_info}\u0026#34; fi } # Shell脚本主流程参数检测. if [ $# -lt 2 ]; then PrintLogFunc \u0026#34;Please enter the correct number of parameters\u0026#34; \u0026#34;WARNING\u0026#34; exit 1 fi # 获取对应的参数. MARKDOWN_CONTENT_RELATIVE_DIR=$1 MARKDOWN_FILENAME=$2 MARKDOWN_CATEGORY_WITH_DATE=\u0026#34;false\u0026#34; if [ \u0026#34;$3\u0026#34; != \u0026#34;\u0026#34; ]; then MARKDOWN_CATEGORY_WITH_DATE=\u0026#34;true\u0026#34; fi # 实现具体的功能. for (( i = 0; i \u0026lt; ${#MARKDOWN_CONTENT_LANGUAGES[@]}; i++ )); do # Hugo 多语言Markdown文件目录. dir=\u0026#34;${MARKDOWN_CONTENT_DIR}\u0026#34; dir=\u0026#34;${dir}/${MARKDOWN_CONTENT_LANGUAGES[${i}]}\u0026#34; dir=\u0026#34;${dir}/${MARKDOWN_CONTENT_RELATIVE_DIR}\u0026#34; # 是否使用日期目录. if [ \u0026#34;$MARKDOWN_CATEGORY_WITH_DATE\u0026#34; = \u0026#34;true\u0026#34; ]; then dir=\u0026#34;${dir}/${CURRENT_DATE}\u0026#34; fi # 检测目录是否存在，不存在则创建 if [ ! -d \u0026#34;${dir}\u0026#34; ]; then mkdir -p \u0026#34;${dir}\u0026#34; PrintLogFunc \u0026#34;${dir} Directory created successfully\u0026#34; \u0026#34;INFO\u0026#34; fi fullname=\u0026#34;${dir}/${MARKDOWN_FILENAME}${MARKDOWN_FILE_EXTENSION}\u0026#34; hugo new \u0026#34;${fullname}\u0026#34; done ","date":"2021-05-25","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/26/shell-scirpt-code-structure/","tags":["Hugo","Shell"],"title":"使用Shell脚本新建博文生成多个语言Markdown文件"},{"categories":["Git"],"contents":"解决过程 通过 https://www.ipaddress.com/ 查询获取Github官方的CDN地址，分别查询 github.com，assets-cdn.github.com，github.global.ssl.fastly.net 这几个域名对应的DNS解析地址，添加到 /etc/hosts 文件。例如：\n1 2 3 4 5 6 7 # Github.com 140.82.114.3\tgithub.com 199.232.69.194\tgithub.global.ssl.fastly.net 185.199.108.153\tassets-cdn.github.com 185.199.109.153\tassets-cdn.github.com 185.199.110.153\tassets-cdn.github.com 185.199.111.153\tassets-cdn.github.com 更多可以参考：解决Github打不开问题 ","date":"2021-05-23","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/23/solve-the-issue-of-github-not-being-able-to-open/","tags":["git","wall"],"title":"解决Github打不开问题"},{"categories":["docker"],"contents":"Section1.容器操作 Section1.1.如何将容器保存为镜像 1 $ docker commit -m \u0026lt;Version Description\u0026gt; -a \u0026lt;Author\u0026gt; \u0026lt;容器ID|容器名称\u0026gt; \u0026lt;组织名称\u0026gt;/\u0026lt;镜像名称\u0026gt;:\u0026lt;版本号\u0026gt; Section1.2.如何查看容器前10行实时日志？ 1 $ docker logs -f -t --tail 10 \u0026lt;容器ID|容器名称\u0026gt; Section1.3.如何批量删除所有已停止运行的容器 方式有很多，来看一种比较常见也比较好理解的方式：\n1 $ docker rm `docker ps -a | grep \u0026#34;Exited\u0026#34; | awk \u0026#39;{print $1}\u0026#39;` Section1.4.容器环境如何使用宿主机网络 容器环境没有梯子你是访问不了Github的，那么在宿主机已经搬了一把梯子，这个时候你就不用再在Docker容器搬梯子了，只需要让Docker容器环境内的网络使用宿主机网络环境就可以了，你需要在运行容器时加上 \u0026ndash;network 选项，值为 host 即可:\n1 $ docker run -it --privileged=true -d --name=centos --network host centos:8 /bin/bash Docker容器运行的时候有host、bridge、none三种网络可供配置。默认是bridge，即桥接网络，以桥接模式连接到宿主机；host是宿主网络，即与宿主机共用网络；none则表示无网络，容器将无法联网。\nSection2.镜像操作 Docker镜像你可以把它理解为系统光盘，这个比喻其实非常的贴切，系统光盘可以装多台机器(你别跟我抬杠哦)，镜像也可以启动多个容器，记住了，镜像是基础。当然再不要脸一点可以把它理解为面向对象中的类，那与之对应的容器就是一个一个的实例了。\nSection2.1.如何批量删除为none的镜像？ 1 $ docker rmi $(docker images | grep \u0026#34;^\u0026lt;none\u0026gt;\u0026#34; | awk \u0026#34;{print $3}\u0026#34;) Section2.2.如何提交镜像到DockerHub 1 $ docker push \u0026lt;组织名称\u0026gt;/\u0026lt;镜像名称\u0026gt;:\u0026lt;版本号\u0026gt; Section2.3.如何删除多个镜像使用相同镜像ID的镜像 多个镜像如下：\n1 2 3 4 $ docker images | grep \u0026#34;feiba/\u0026#34; feiba/rocky 1.1.0 53aab0bc4443 About an hour ago 1.41GB feiba/rocky-test 1.0.0 034ad52d7665 2 hours ago 754MB feiba/rocky 1.0.0 034ad52d7665 2 hours ago 754MB 这时使用镜像ID进行删除Docker镜像\n1 2 $ docker rmi 034ad52d7665 Error response from daemon: conflict: unable to delete 034ad52d7665 (cannot be forced) - image has dependent child images 这个时候使用镜像ID是白瞎了，那该怎么做为，为什么会出现这种情况？\n先说一下为什么会出现这种情况，原因也非常简单，那就是现在这个 034ad52d7665 镜像ID同时有两个镜像在使用，通过这个共用的镜像ID去删除镜像，Docker为了安全考虑是不允许我们这样操作的，我们需要像下面这样的方式，通过镜像以及版本号一个一个的删除。\n1 2 $ docker rmi feiba/rocky-test:1.0.0 Untagged: feiba/rocky-test:1.0.0 这个时候 feiba/rocky-test:1.0.0 这个Docker镜像也就删除了。另一个 feiba/rocky:1.0.0 Docker镜像也以同样的方式进行删除。\n1 2 3 $ docker rmi feiba/rocky:1.0.0 Untagged: feiba/rocky:1.0.0 Untagged: feiba/rocky@sha256:e0ea484b734e6072527d041e4b455623ad35d77687a035ddc9c43b07eab7793b 3.如何查看docker现在有多少网卡？ 1 $ docker network ls 4.如何删除docker网卡？ 1 $ docker network rm \u0026lt;Network ID | Name\u0026gt; 5.如何查看当前容器占用多少内存？ 1 $ docker ps -s 6.使用docker-compose管理工具运行容器时，发现孤儿容器如何解决？ 1 WARNING: Found orphan containers (wmx_redis_server) for this project. If you removed or renamed this service in your compose file, you can run this command with the --remove-orphans flag to clean it up. 这个是因为如果您有两个相同的项目名称的时候，docker这个时候就在创建容器并运行的时候它办不了了，它不知道是该如何管理这个将要创建的容器和之前创建的容器了，比如您呢之前有一个用于管理个人博客的redis容器，这个容器从docker.redis项目目录启动并运行了，而现在呢您又有一个管理公司项目的redis容器，而启动这个redis容器的目录恰恰也叫docker.redis，这个时候就会报错启动不成功，它让您呢在启动的时候可以加上 --remove-orphans 选项，将之前的删除掉，您可千万别执行哈，这也不是我们想要的结果不是吗，我们可以使用 docker-compose -h 看到有一个 -p, --project-name NAME 选项，好了，就是它，它的英文注释是：Specify an alternate project name，中文意思嘛，就是：指定替代项目名称，这个替代项目名称，您可以随意起名，一般呢以域名为基础进行命令即可，具体命令如下：\n1 $ docker-compose -p helloshaohua-com-docker-redis -f docker-compose.yaml up -d 这个时候就可以成功启动了！\n7.如何进入容器内部？ 1 $ docker exec -it \u0026lt;CONTAINER ID | Name\u0026gt; bash -i: 是保持容器内的shell与宿主主机之间互动。您如果不加 -i 选项呢，您输入一个 echo 'hello world'; 它没有输出哦~，它也就没有与宿主主机之间保持互动，容器内部它确实是执行了，感观上您看不到它的执行！ -t: 分配一个基础的shell命令行！ ","date":"2021-05-23","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/23/docker-users-problem-logging/","tags":["docker","problem","logging"],"title":"Docker日常开发使用"},{"categories":["net safe"],"contents":"Feature1、抓取默认网卡的所有数据包 1 $ tcpdump Feature2、抓取指定IP的所有数据包 1 $ tcpdump host 10.10.11.215 意思是抓取本服务器与IP10.10.11.215设备之间的通信数据包.\nFeature3、抓取指定IP及端口的所有数据包 1 $ tcpdump host 10.10.11.215 and port 7001 意思是抓取本服务器与IP 10.10.11.215 设备的 7001 端口之间的通信数据包.\nFeature4、抓取指定IP及端口的所有数据包并保存为文件以供wireshark工具分析 1 $ tcpdump host 10.10.11.215 and port 7001 -w 10.10.11.215.machine.port.7001.cap 意思是抓取本服务器与IP 10.10.11.215 设备的 7001 端口之间的通信数据包，并将数据包保存到文件 10.10.11.215.machine.port.7001.cap.\n","date":"2021-05-23","image":null,"permalink":"https://shaichunfeng.com/post/2021/04/29/tcpdump-climbing-package/","tags":["tcpdump","climbing","package"],"title":"TCPDUMP抓包工具"},{"categories":["Golang"],"contents":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Editor files. .idea # Binaries for programs and plugins *.exe *.exe~ *.dll *.so *.dylib # Test binary, built with `go test -c` *.test # Output of the go coverage tool, specifically when used with LiteIDE *.out # Dependency directories (remove the comment below to include it) vendor/ ","date":"2021-05-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/19/go-gitignore/","tags":["git","gitignore"],"title":"Golang项目Git忽略文件配置"},{"categories":["linux"],"contents":"变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash # 1. 变量的定义和使用 username=helloshaohua echo \u0026#34;1. $username\u0026#34; # 2. 另一种定义方式 course=\u0026#34;linux shell program\u0026#34; echo 2. ${course} # 3. 只读变量 readonly course # course=\u0026#34;Go program\u0026#34; # available.sh: line 13: course: readonly variable. | On the mac os. # unset course # available.sh: line 14: unset: course: cannot unset: readonly variable. echo \u0026#34;3. ${course}\u0026#34; # 4. 删除变量 unset usernmae echo \u0026#34;4. ${username}\u0026#34; 只读变量不能重新赋值，不能删除！\n普通变量可以重新赋值，可以删除！\n环境变量 定义一个 env.sh shell脚本如下：\n1 2 3 4 5 6 7 #!/bin/bash # 1. export 导出一个环境变量 export SHAOHUA=\u0026#34;helloshaohua\u0026#34; # 2. 查找自定义的环境变量 env | grep \u0026#34;SHAOHUA\u0026#34; 运行 env.sh shell脚本，得到如下结果：\n1 2 3 $ sh env.sh SHAOHUA=helloshaohua 特殊变量 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n是一个数字，表示第几个参数，例如，第一个参数是$1，第二个参数是$2 $# 传递给脚本或函数的参数个数 $* 传递给脚本或函数的所有参数 $@ 传递给脚本或函数的所有参数。被双引号(\u0026quot; \u0026ldquo;)包含时，与$*稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值 $$ 当前shell进程ID。对于shell脚本，就是这些脚本所在的进程ID。 定义一个 special-variable.sh shell脚本如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash # 特殊变量 $0 表示当前脚本的文件名称. echo \u0026#34;当前脚本文件名称：$0\u0026#34; # 获取传递给脚本的第一个参数. echo \u0026#34;参数1：$1\u0026#34; # 获取传递给脚本的第二个参数. echo \u0026#34;参数2：$2\u0026#34; # 传递给脚本或函数的参数个数. echo \u0026#34;参数个数：$#\u0026#34; # 获取传递给脚本的所有参数. echo \u0026#34;所有参数：$@\u0026#34; 运行 special-variable.sh shell脚本，得到如下结果：\n1 2 3 4 5 6 $ sh special.sh hello world helloshaohua hellochina 当前脚本文件名称：special.sh 参数1：hello 参数2：world 参数个数：4 所有参数：hello world helloshaohua hellochina 算术运算 运算符 含义 + 加 - 减 * 乘 / 除 % 取余 定义一个 arithmetic-operation.sh shell脚本如下，以测试具体使用情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/bin/bash a=10 b=25 # 加法 expr 运算符 sum=`expr $a + $b` echo \u0026#34;$a + $b = $sum\u0026#34; # 另一种数值运算 $[expression] sub=$[a-b] echo \u0026#34;$a - $b = $sub\u0026#34; # 乘法 ride_val=$[a*b] echo \u0026#34;$a * $b = $ride_val\u0026#34; # 除法 divide_val=$[b/a] echo \u0026#34;$b / $a = $divide_val\u0026#34; # 取余 surplus_val=$[b%a] echo \u0026#34;$b % $a = $surplus_val\u0026#34; 运行 arithmetic-operation.sh shell脚本，得到如下结果：\n1 2 3 4 5 6 $ sh arithmetic-operation.sh 10 + 25 = 35 10 - 25 = -15 10 * 25 = 250 25 / 10 = 2 25 % 10 = 5 expr 运算符表示运算，意为将expr右侧的表达式进行计算，从上面的脚本文件代码中可以看出，其实这种方式不太常用，而$[expression] 这种方式更加常用，因为写起来比较方便嘛！\n关系运算 运算符 含义 -eq 相等 -ne 不相等 -gt 大于 -ge 大于等于 -lt 小于 -le 小于等于 定义一个 relational-calculus.sh shell脚本如下，以测试 关系运算 具体使用情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/bin/bash a=10 b=25 # -eq 相等 if [ $a -eq $b ]; then echo \u0026#34;$a -eq $b: $a 等于 $b\u0026#34; else echo \u0026#34;$a -eq $b: $a 不等于 $b\u0026#34; fi # -ne 不相等 if [ $a -ne $b ]; then echo \u0026#34;$a -ne $b: $a 不等于 $b\u0026#34; else echo \u0026#34;$a -ne $b: $a 等于 $b\u0026#34; fi # -gt 大于 if [ $a -gt $b ]; then echo \u0026#34;$a -gt $b: $a 大于 $b\u0026#34; else echo \u0026#34;$a -gt $b: $a 不大于 $b\u0026#34; fi # -gt 大于等于 if [ $a -ge $b ]; then echo \u0026#34;$a -ge $b: $a 大于等于 $b\u0026#34; else echo \u0026#34;$a -ge $b: $a 不大于等于 $b\u0026#34; fi # -lt 小于 if [ $a -lt $b ]; then echo \u0026#34;$a -lt $b: $a 小于 $b\u0026#34; else echo \u0026#34;$a -lt $b: $a 不小于 $b\u0026#34; fi # -le 小于等于 if [ $a -le $b ]; then echo \u0026#34;$a -le $b: $a 小于等于 $b\u0026#34; else echo \u0026#34;$a -le $b: $a 不小于等于 $b\u0026#34; fi 运行 relational-calculus.sh shell脚本，得到如下结果：\n1 2 3 4 5 6 7 $ sh relational-calculus.sh 10 -eq 25: 10 不等于 25 10 -ne 25: 10 不等于 25 10 -gt 25: 10 不大于 25 10 -ge 25: 10 不大于等于 25 10 -lt 25: 10 小于 25 10 -le 25: 10 小于等于 25 是不是灰常简单~\n布尔与逻辑运算 运算符 含义 ! 非运算 [ !false ] -o 或运算 -a 与运算 [ $a -lt 100 -a $b -gt 15 ] \u0026amp;\u0026amp; 逻辑与 [[ $a -lt 100 \u0026amp;\u0026amp; $b -gt 1 ]] || 逻辑或 == 相等（数字） != 不行（数字） 定义一个 boolean-logic.sh shell脚本如下，以测试 布尔与逻辑运算 具体使用情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/bin/bash a=10 b=25 # 布尔运算(-eq, -ne, -gt, -ge, -lt, -le)，也可以理解为：由关系运算符组成的布尔运算表达式. if [ $a -eq $b ]; then echo \u0026#34;$a -eq $b: $a 等于 $b\u0026#34; else echo \u0026#34;$a -eq $b: $a 不等于 $b\u0026#34; fi # 逻辑运算， 注意两个[[ ]] 方括号. if [[ $a -gt 0 \u0026amp;\u0026amp; $b -gt 0 ]]; then echo \u0026#34;$a, $b 都大于 0\u0026#34; fi 运行 boolean-logic.sh shell脚本，得到如下结果：\n1 2 3 $ sh boolean-logic.sh 10 -eq 25: 10 不等于 25 10, 25 都大于 0 所有的语言基本都是一样，分支语句都是测试布尔表达式进行代码路由的一个过程，代码路由，这个概念你可以没有听说过，这个是我随口说的哦，其实就是条件执行. 而布尔表达式最终可以得到这些 条件，布尔表达式一般由关系运算符组成。\n文件测试运算 运算符 含义 -d 是否为目录 -f 是否为普通文件 -r 是否可读 -w 是否可写 -x 是否可执行 -s 文件是否为空 -e 文件是否存在 定义一个 file.sh shell脚本如下，以测试 文件测试运算 具体使用情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #!/bin/bash tmp_dir=\u0026#34;/tmp\u0026#34; tmp_helloshaohua_txt=\u0026#34;$tmp_dir/helloshaohua.txt\u0026#34; # 创建一个新文件，没有任何内容，也就是空文件. touch $tmp_helloshaohua_txt # -d 是否为目录 if [ -d $tmp_dir ]; then echo \u0026#34;$tmp_dir 是目录\u0026#34; else echo \u0026#34;$tmp_dir 不是目录\u0026#34; fi # -f 文件是否为普通文件 if [ -f $tmp_helloshaohua_txt ]; then echo \u0026#34;$tmp_helloshaohua_txt 文件是普通文件\u0026#34; else echo \u0026#34;$tmp_helloshaohua_txt 文件不是普通文件\u0026#34; fi # -r 文件是否可读 if [ -r $tmp_helloshaohua_txt ]; then echo \u0026#34;$tmp_helloshaohua_txt 文件可读\u0026#34; else echo \u0026#34;$tmp_helloshaohua_txt 文件不可读\u0026#34; fi # -w 文件是否可写 if [ -w $tmp_helloshaohua_txt ]; then echo \u0026#34;$tmp_helloshaohua_txt 文件可写\u0026#34; else echo \u0026#34;$tmp_helloshaohua_txt 文件不可写\u0026#34; fi # -x 文件是否可执行 if [ -x $tmp_helloshaohua_txt ]; then echo \u0026#34;$tmp_helloshaohua_txt 文件可执行\u0026#34; else echo \u0026#34;$tmp_helloshaohua_txt 文件不可执行\u0026#34; fi # -s 文件是否为空，注意啦：The non zero output indicate that file is empty， # 意为：非零输出表示文件为空。 # 可以参考：https://www.cyberciti.biz/faq/linux-unix-script-check-if-file-empty-or-not/ if [ ! -s $tmp_helloshaohua_txt ]; then echo \u0026#34;$tmp_helloshaohua_txt 文件为空\u0026#34; else echo \u0026#34;$tmp_helloshaohua_txt 文件不为空\u0026#34; fi # -e 文件是否存在 if [ -e $tmp_helloshaohua_txt ]; then echo \u0026#34;$tmp_helloshaohua_txt 文件存在\u0026#34; else echo \u0026#34;$tmp_helloshaohua_txt 文件不存在\u0026#34; fi # 写入内容到文件 echo \u0026#34;写入helloshaohua字符串到${tmp_helloshaohua_txt}文件\u0026#34; echo \u0026#34;helloshaohua\u0026#34; \u0026gt;\u0026gt; $tmp_helloshaohua_txt # 再次检测文件是否为空，这部分和上面部分代码重复可以提取定义为一个函数， # 这里简单起见，暂不定义函数，具体会到函数部分说明. # 这次检测应该是输出 `/tmp/helloshaohua.txt 文件不为空` 才对~ if [ ! -s $tmp_helloshaohua_txt ]; then echo \u0026#34;$tmp_helloshaohua_txt 文件为空\u0026#34; else echo \u0026#34;$tmp_helloshaohua_txt 文件不为空\u0026#34; fi 运行 file.sh shell脚本，得到如下结果：\n1 2 3 4 5 6 7 8 9 10 $ sh file.sh /tmp 是目录 /tmp/helloshaohua.txt 文件是普通文件 /tmp/helloshaohua.txt 文件可读 /tmp/helloshaohua.txt 文件可写 /tmp/helloshaohua.txt 文件不可执行 /tmp/helloshaohua.txt 文件不为空 /tmp/helloshaohua.txt 文件存在 写入helloshaohua字符串到/tmp/helloshaohua.txt文件 /tmp/helloshaohua.txt 文件不为空 字符串 定义方式 含义 单引号 原样输出，变量无效 双引号 可以包含变量 定义一个 string.sh shell脚本如下，以测试 字符串 具体使用情况，其实也特定简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/bash tutorial=\u0026#34;Linux shell脚本编程快速入门\u0026#34; # 单引号 question=\u0026#39;Linux shell脚本编程如何学习？$tutorial\u0026#39; echo $question # 双引号 answer=\u0026#34;请阅读《${tutorial}》博客内容！\u0026#34; echo $answer # 字符串拼接 echo -e \u0026#34;拼接后一起输出：\\n\u0026#34;${question}\u0026#34;\\n\u0026#34;$answer 运行 string.sh shell脚本，得到如下结果：\n1 2 3 4 5 6 $ sh string.sh Linux shell脚本编程如何学习？$tutorial 请阅读《Linux shell脚本编程快速入门》博客内容！ -e 拼接后一起输出： Linux shell脚本编程如何学习？$tutorial 请阅读《Linux shell脚本编程快速入门》博客内容！ 单引号字符串内如果包含变量将原样输出变量名，也就是说它不会解析，双引号字符串内如果包含变量将会解析变量为具体值，单引号 定义字符串并不常用。最常用的是 双引号 定义字符串。\n字符串操作 定义方式 含义 ${#variable} 获取字符串长度。 ${variable:start:end} 获取字符串子串。 expr index \u0026quot;$variable\u0026quot; sub_str 查找字符串子串。 定义一个 string-operate.sh shell脚本如下，以测试 字符串操作 具体使用情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/bin/bash # 普通变量定义 user=\u0026#34;helloshaohua\u0026#34; # 获取字符串长度 echo \u0026#34;字符串${user}的长度为：${#user}\u0026#34; # 获取字符串子串 echo \u0026#34;字符串${user}子串：${user:5:${#user}-1}\u0026#34; # 查找字符串子串位置 matched=`expr index \u0026#34;$user\u0026#34; s` echo \u0026#34;字符串${user}查找字符串子串位置s为：$matched\u0026#34; 运行 string-operate.sh shell脚本，得到如下结果：\n1 2 3 4 $ sh hello.sh 字符串helloshaohua的长度为：12 字符串helloshaohua子串：shaohua 字符串helloshaohua查找字符串子串位置s为：6 字符串操运算符 运算符 含义 = 字符串是否相等[$a = $b] != 字符串是否不相等[$a != $b] -z 字符串长度是否为0[-z $a] -n 字符串长度是否不为0[-n \u0026quot;$a\u0026quot;] $ 字符串是否为空[$a] 注意: 左中括号[之后和右中括号]之前应该有一个空格\n数组 定义，下标从 0 开始. 设置/读取数组元素. 读取数组所有元素 @. 读取数组长度. 定义一个 array.sh shell脚本如下，以测试 数组 具体使用情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash # 1. 数组的定义 oss=(\u0026#34;linux\u0026#34;, \u0026#34;darwin\u0026#34;, \u0026#34;window\u0026#34;, \u0026#34;android\u0026#34;) # 2. 设置数组元素(是可以说是更新某个数组元素) oss[1]=\u0026#34;MacOSX\u0026#34; # 3. 读取数组元素 echo \u0026#34;数组下标(索引)为2的元素：${oss[1]}\u0026#34; # 4. 读取数组所有元素 echo \u0026#34;数组所有元素：${oss[@]}\u0026#34; # 5. 获取数组长度 len=${#oss[@]} echo \u0026#34;数组长度为：$len\u0026#34; 运行 array.sh shell脚本，得到如下结果：\n1 2 3 4 $ sh array.sh 数组下标(索引)为2的元素：MacOSX 数组所有元素：linux, MacOSX window, android 数组长度为：4 分支语句 if 如果您有语言基础，这个分支语句肯定是对您来说是非常简单喽，没有也没有关系，所谓的分支语句就是根据判断条件的真假，选择具体的分支进行执行代码，如果被测试的条件都不为真，有 else 分支时，执行 else 分支，否则当前分支块执行结束，继续向下执行代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash # 普通变量定义 age=18 # 第一种写法：if 分支语句，每一条判断语句后跟一个 then 关键字的使用方式. if [ $age -le 10 ]; then echo \u0026#34;${age}小于等于10：少年\u0026#34; elif [ $age -le 20 ]; then echo \u0026#34;${age}小于等于20：青年\u0026#34; elif [ $age -le 50 ]; then echo \u0026#34;${age}小于等于50：中年\u0026#34; else echo \u0026#34;老年\u0026#34; fi # 第二种写法：if 分支语句，每一条判断语句换行跟一个 then 关键字的使用方式. if [ $age -le 10 ] then echo \u0026#34;${age}小于等于10：少年\u0026#34; elif [ $age -le 20 ] then echo \u0026#34;${age}小于等于20：青年\u0026#34; elif [ $age -le 50 ] then echo \u0026#34;${age}小于等于50：中年\u0026#34; else echo \u0026#34;老年\u0026#34; fi 运行 if.sh shell脚本，得到如下结果：\n1 2 3 $ sh if.sh 18小于等于20：青年 18小于等于20：青年 在上面的 if.sh shell脚本文件中有两种if分支结构的写法，第一种是最常用的用法，第二种使脚本代码不易读。建议使用第一种写法。\ncase 这个case中其它编程语言中就是 switch...case 分支结构喽，在shell中它叫case，所完成的功能是相同的。接下来定义一个 case.sh shell脚本，以测试 case 具体使用情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/bash # 普通变量定义 os=\u0026#34;hello\u0026#34; case $os in \u0026#34;windows\u0026#34;) echo \u0026#34;当前系统是Windows操作系统.\u0026#34; ;; \u0026#34;linux\u0026#34;) echo \u0026#34;当前系统是Linux操作系统.\u0026#34; ;; \u0026#34;darwin\u0026#34;) echo \u0026#34;当前系统是Mac操作系统.\u0026#34; ;; \u0026#34;android\u0026#34;) echo \u0026#34;当前系统是Mac操作系统.\u0026#34; ;; *) echo \u0026#34;当前系统是${os}，未知操作系统类型.\u0026#34; ;; esac 运行 case.sh shell脚本，得到如下结果：\n1 2 $ sh case.sh 当前系统是hello，未知操作系统类型. case的默认分支语句用星号 * 通配符表示，这是shell中与其它常规编程语言的的一个区别。表示当所有其它分支测试条件都不满足时，将会执行默认分支。通俗地讲就是不管测试的具体值是什么总是有一个分支将会被执行。\n循环 通过循环结构让程序重复的执行某种操作，直到条件为真的时，退出循环。\nfor 与其他编程语言类似，Shell支持for循环。 for 循环的一般格式为：\n1 2 3 4 5 6 7 for 变量 in 列表; do command1 command2 command3 ... commandN done 列表是一组值（数字、字符串等）组成的序列，第个值通过空格分隔。每循环一次，就将列表中的下一个值赋值给变量。in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。\n例如，定义一个 for-with-simple-list.sh shell脚本文件，顺序输出当前列表中的数字:\n1 2 3 4 5 #!/bin/bash for val in 1 2 3 4 5 6 7 8 9 10; do echo \u0026#34;当前值为: ${val}\u0026#34; done 执行 for-with-simple-list.sh shell脚本文件，得到如下结果：\n1 2 3 4 5 6 7 8 9 10 11 $ sh for-with-simple-list.sh 当前值为: 1 当前值为: 2 当前值为: 3 当前值为: 4 当前值为: 5 当前值为: 6 当前值为: 7 当前值为: 8 当前值为: 9 当前值为: 10 接下来定义一个 for-with-string-char.sh shell脚本文件，以顺序输出字符串中的子字符串：\n1 2 3 4 5 6 7 8 9 10 #!/bin/bash # 普通变量定义 str=\u0026#39;Hello World, 中国\u0026#39; num=1 for c in ${str}; do echo \u0026#34;字符串{${str}}，第${num}次循环获取到的子字符串为${c}\u0026#34; num=$[num + 1] done 执行 for-with-string-char.sh shell脚本文件，得到如下结果：\n1 2 3 4 $ sh for-with-string-char.sh 字符串{Hello World, 中国}，第1次循环获取到的子字符串为Hello 字符串{Hello World, 中国}，第2次循环获取到的子字符串为World, 字符串{Hello World, 中国}，第3次循环获取到的子字符串为中国 再来看一个使用案例，定义一个 show-home-git-related-files.sh shell脚本文件，以顺序输出家目录下以 .git 开头的文件：\n1 2 3 4 5 6 7 8 9 #!/bin/bash # 普通变量定义 files=$HOME/.git* # 循环输出每一个以 `.git` 开头的文件路径 for f in $files; do echo \u0026#34;以{.git}开头的文件：${f}\u0026#34; done 执行 show-home-git-related-files.sh shell脚本文件，得到如下结果：\n1 2 3 4 $ sh show-home-git-related-files.sh 以{.git}开头的文件：/Users/helloshaohua/.gitconfig 以{.git}开头的文件：/Users/helloshaohua/.gitflow_export 以{.git}开头的文件：/Users/helloshaohua/.gitignore_global while while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为布尔表达式测试条件。其格式为：\n1 2 3 while command; do statements to be executed if command is true done 命令执行完毕，当前一次的循环也就结束了，循环控制返回循环顶部，从头开始直至测试条件为假，while循环退出，继续下向执行代码。\n来定义一个 while-with-counter-less-than-10.sh shell脚本文件，看一个基本的while循环如何使用，测试条件是：如果counter小10，那么返回true，否则返回false，counter从0开始，每次循环处理时，counter加1，当counter为10时，测试条件为false，while循环退出。\n1 2 3 4 5 6 7 8 9 10 #!/bin/bash # 普通变量定义 counter=0 # while 循环输出计数器的值 while [ $counter -lt 10 ]; do counter=$[counter+1] echo \u0026#34;第${counter}次循环，计数器为：${counter}\u0026#34; done 执行 while-with-counter-less-than-10.sh shell脚本文件，得到如下结果：\n1 2 3 4 5 6 7 8 9 10 11 $ sh while-with-counter-less-than-10.sh 第1次循环，计数器为：1 第2次循环，计数器为：2 第3次循环，计数器为：3 第4次循环，计数器为：4 第5次循环，计数器为：5 第6次循环，计数器为：6 第7次循环，计数器为：7 第8次循环，计数器为：8 第9次循环，计数器为：9 第10次循环，计数器为：10 while 读取文件内容，也非常方便，定义一个 read-files.sh shell脚本文件，以读取 /tmp/helloshaohua 目录下的所有文件内容并输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/bash # 普通变量定义 files=\u0026#34;/tmp/helloshaohua/*\u0026#34; for fl in $files; do # 检测是否是普通文件，并且文件内容不为空， # 条件成立时读取，不成立时忽略该文件。 if [[ -f $fl \u0026amp;\u0026amp; -s $fl ]]; then # 循环读取每一行文件内容打印。 while IFS= read -r line; do printf \u0026#39;%s\\n\u0026#39; \u0026#34;$line\u0026#34; done \u0026lt; $fl fi done /tmp/helloshaohua目录具体的文件列表如下：\n1 2 3 4 5 $ ll /tmp/helloshaohua total 24 -rw-r--r-- 1 helloshaohua wheel 47B 5 20 18:11 a.txt -rw-r--r-- 1 helloshaohua wheel 47B 5 20 18:13 b.txt -rw-r--r-- 1 helloshaohua wheel 47B 5 20 18:13 c.txt /tmp/helloshaohua目录具体的文件内容如下：\n1 2 3 4 5 6 7 $ cat /tmp/helloshaohua/a.txt /tmp/helloshaohua/b.txt /tmp/helloshaohua/c.txt This is a.txt file. The file extension is txt. This is b.txt file. The file extension is txt. This is c.txt file. The file extension is txt. 执行 read-files.sh shell脚本文件，得到如下结果：\n1 2 3 4 5 6 7 $ sh read-files.sh This is a.txt file. The file extension is txt. This is b.txt file. The file extension is txt. This is c.txt file. The file extension is txt. 可以看到打印出的文件内容信息，与cat多个文件是一致的。\nwhile 循环可用于读取键盘输入信息。下面定义一个 read-input-data.sh shell脚本文件，以读取从自键盘的输入数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/bash echo \u0026#39;键入\u0026lt;CTRL-C\u0026gt;终止\u0026#39; echo -n \u0026#39;输入您最喜欢的电影：\u0026#39; while read FILE; do # 如果输入的电影名为空，则提示输入， # 否则输出关于该电影的评价。 if [ ${#FILE} -gt 0 ]; then echo \u0026#34;是的！《${FILE}》非常赞的电影~\u0026#34; else echo -n \u0026#39;输入您最喜欢的电影：\u0026#39; fi done 执行 read-input-data.sh shell脚本文件，得到如下结果：\n1 2 3 4 5 6 7 $ sh read-input-data.sh 键入\u0026lt;CTRL-C\u0026gt;终止 输入您最喜欢的电影：人之怒 是的！《人之怒》非常赞的电影~ 输入您最喜欢的电影：hello 是的！《hello》非常赞的电影~ 输入您最喜欢的电影： 你可以多次输入，按 CTRL-C 退出shell脚本程序运行。\nuntil until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。until循环格式为：\n1 2 3 until [ command ]; do statements to be executed if command is false done command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。\n下面定义一个 until.sh shell脚本文件，以使用 until 命令输出 0 ~ 9 的数字：\n1 2 3 4 5 6 7 8 9 10 #!/bin/bash # 普通变量定义 counter=0 # until 循环输出 until [ ! $counter -lt 10 ]; do echo \u0026#34;当前计数器为：${counter}\u0026#34; counter=$[counter+1] done 执行 until.sh shell脚本文件，得到如下结果：\n1 2 3 4 5 6 7 8 9 10 11 $ sh until.sh 当前计数器为：0 当前计数器为：1 当前计数器为：2 当前计数器为：3 当前计数器为：4 当前计数器为：5 当前计数器为：6 当前计数器为：7 当前计数器为：8 当前计数器为：9 跳出循环 在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。\nbreak命令 break命令允许跳出所有循环（终止执行当前循环结构后面的所有循环）。下面来定义一个 break-while.sh shell脚本文件，以测试脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，就要使用break命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/bash while : ; do echo -n \u0026#34;输入1到5之间的数字: \u0026#34; read NUMBER case $NUMBER in 1|2|3|4|5) echo \u0026#34;你输入的数字是：${NUMBER}\u0026#34; ;; *) echo \u0026#34;你输入的数字不是1到5之间的数字游戏结束~\u0026#34; break ;; esac done 执行 break-while.sh shell脚本文件，得到如下结果：\n1 2 3 4 5 6 7 8 9 10 11 $ sh break-while.sh 输入1到5之间的数字: 3 你输入的数字是：3 输入1到5之间的数字: 2 你输入的数字是：2 输入1到5之间的数字: 5 你输入的数字是：5 输入1到5之间的数字: 5 你输入的数字是：5 输入1到5之间的数字: 6 你输入的数字不是1到5之间的数字游戏结束~ 在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：\n1 break n 表示跳出第n层循环。\ncontinue ","date":"2021-05-19","image":null,"permalink":"https://shaichunfeng.com/post/2021/05/19/post-9/","tags":["sh","shell"],"title":"shell编程快速入门"},{"categories":["Docker"],"contents":"如果你只有一台服务器，并且有多个服务需要NGINX代理提供服务，还想使用Docker服务跑你的NGINX服务器，那么你就应该单独管理你的NGINX服务容器，而不应该在其它应用部署时强耦合到项目下的docker-compose.yaml进行相应的部署，那应该如何优雅的管理你的NGINX服务呢? 那既然你能看到这篇博文，相信它必定对你管理NGINX服务容器有一定的启发~\n单独建立一个Docker下的NGINX管理项目 例如你可以建立一个如下目录结构的项目，项目名称随意，如docker-nginx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ tree . ├── config // 配置目录 │ ├── Dockerfile // Dockerfile │ ├── nginx.conf // NGINX配置文件 │ ├── ca // SSL证书目录 │ │ ├── api.wumoxi.com │ │ │ ├── cert.key │ │ │ └── cert.pem │ │ └── wumoxi.com │ │ ├── cert.key │ │ └── cert.pem │ └── ss // 服务(或者说虚拟主机)配置目录 │ ├── api.wumoxi.com.conf │ └── wumoxi.com.conf └── docker-compose.yaml // 容器管理工具配置文件 在这个项目目录下有一个docker-compose.yaml文件和一个config目录。来看一下主要的Docker相关的配置文件config/Dockerfile和docker-compose.yaml 的具体内容及NGINX配置文件。\nconfig/Dockerfile 1 2 3 4 5 6 7 8 9 10 FROM yobasystems/alpine-nginx # 拷贝证书和虚拟主机配置文件以及NGINX配置文件到容器环境内部. COPY ca /etc/nginx/ca COPY ss /etc/nginx/ss COPY nginx.conf /etc/nginx/nginx.conf # 暴露容器服务端口号(注意这里暴露了80和443，如果你配置域名的SSL暴露这个端口号是必须的). EXPOSE 80 EXPOSE 443 注意这里使用了yobasystems/alpine-nginx这个镜像。\ndocker-compose.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 version: \u0026#34;3.6\u0026#34; # docker composer 管理的服务 services: # nginx-server 是容器服务名称，例如：容器如与容器之间访问服务的话， # 需要指定这个服务名称，稍后讲一下config/ss/api.wumoxi.com.conf这个文件的时候你自然会明白。 nginx-server: # 指定这个nginx-server服务运行所在容器的名称。 container_name: nginx_server # 指定要构建镜像所使用的Dockerfile文件所在目录， # 构建出来的镜像名称会以 [项目名称_容器服务名称] 的形式存在， # 如该项目构建出来的镜像将会是 `dockernginx_nginx-server` 名称的镜像存在。 build: \u0026#39;./config\u0026#39; # 将Dockerfile指定的容器暴露端口号与宿主主机关联。 # 注意端口关联是以，[宿主主机端口号:容器暴露端口号] 的形式存在的， # 那你如果是刚开始接触Docker可能分不清，这里一定要明确哪个是宿主主机端口哪个是容器暴露端口。 # 可以有多个，这个要根据容器向外暴露的具体端口而定。 ports: - \u0026#39;80:80\u0026#39; - \u0026#39;443:443\u0026#39; # 指定容器的重启方式，可选值为[\u0026#34;no\u0026#34;, always, on-failure, unless-stopped] restart: always # 指定容器是不是对挂载目录有写入权限 privileged: true # 挂载宿主主机目录到容器，可以有多个，当然你也可以用容器数据卷进行挂载 volumes: - /usr/local/data/docker/nginx/www:/etc/nginx/html # 容器所使用的网络 networks: - default - externals # 网络定义，这个地方定义了一个名称为[externals]网络的外部网络 # 注意：让需要链接的容器同属一个外部网络，那现在这个nginx-server容器服务就在这个名称为 [externals] 的外部网络中。 # 那你要在这个NGINX容器服务中代理其它容器服务，例如有一个 [gin-app] 的容器服务，那么它们两个必须属于同一个网络。 networks: externals: external: true 要让nginx-server与gin-app这两个容器服务使用同一个外部网络externals,因此，需要在启动这两个容器之前通过以下命令创建外部网络：\n1 $ docker network create externals config/nginx.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # run nginx in foreground daemon off; #user nobody; worker_processes 1; error_log stderr error; error_log stderr notice; error_log stderr info; events { worker_connections 1024; } http { # Include mime types. include mime.types; # Default content type. default_type application/octet-stream; # Save access log to file. access_log /dev/stdout; # Hide NGINX server version. Ref: https://www.tecmint.com/hide-nginx-server-version-in-linux/ server_tokens off; # Auto send static file to browser. Ref: https://www.jianshu.com/p/70e1c396c320?utm_campaign sendfile on; # The first parameter sets a timeout during which a keep-alive client connection will stay open on the server side. # The zero value disables keep-alive client connections. keepalive_timeout 65; # Open gzip transfer. gzip on; # Include multipart server config files. include ./ss/*.conf; } 可以在这个文件的最后一行看到它会引入config/ss目录下的所有以.conf为后缀的虚拟主机配置文件。那具体到每一个虚拟主机是怎么代理容器服务的呢？下面以二级域名api.wumoxi.com的虚拟主机配置config/ss/api.wumoxi.com.conf 为例说明一下怎么代码容器服务。\n代理容器服务 如现有一个Golang项目并且其项目目录下定义了docker-compose.yaml文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#34;3.6\u0026#34; services: gin-app: container_name: wumoxi.com.server build: \u0026#34;.\u0026#34; ports: - \u0026#39;8859:8859\u0026#39; restart: always networks: - externals networks: externals: external: true 虚拟主机config/ss/api.wumoxi.com.conf`配置文件具体内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 server { listen 443 ssl; server_name api.wumoxi.com; # SSL signature. ssl_certificate /etc/nginx/ca/api.wumoxi.com/cert.pem; ssl_certificate_key /etc/nginx/ca/api.wumoxi.com/cert.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; # Http response body max size. client_max_body_size 8m; # Proxy application backend api service. location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 代理Golang项目，指定其host为容器服务名称[gin-app]加上服务端口号8859 proxy_pass http://gin-app:8859/; } location ~ /\\.ht { deny all; } } server { listen 80; server_name api.wumoxi.com; rewrite ^(.*) https://$host$1 permanent; } 在NGINX容器环境内代理服务，指定的服务host是通过服务名称指定的，这个一定要明确。还有就是这两个容器服务必须是在同一外部网络下，nginx-server和gin-app就是在同一外部网络externals所以可以链接成功。以完成容器与容器间的数据传输。\n使用NGINX容器服务 构建docker compose容器服务镜像 1 $ docker-compose build 运行docker compose容器服务 1 $ docker-compose up -d 停止docker compose容器服务 1 $ docker-compose down 本地测试线上使用 你在本地可以使用NGINX配置，待符合你的欲期的时候将项目上传到服务器你可以通过rsync，也可以版本库的方式。视具体情况而定。\n","date":"2020-05-23","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/23/how-to-gracefully-manage-your-nginx-with-docker/","tags":["nginx","container"],"title":"如何用Docker优雅地管理你的Nginx"},{"categories":["Golang"],"contents":"在项目中如果要用到第三方服务，第三方服务肯定会有一服务接口文档，难免不会有一些API接口是必须要通过POST方式请求，那么在Golang中如何发送POST请求到其它第三服务呢? 如果说有3种或4种方式，这种说法也不太确切，这个具体要看第三方服务接口接收数据的格式，如果只接收XML数据格式那你也就只能通过XML格式发送请求数据到第三方API接口，来看几种常用的POST请求方式~\n模拟第三方服务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type Product struct { Name string `json:\u0026#34;name\u0026#34; form:\u0026#34;name\u0026#34; xml:\u0026#34;name\u0026#34; binding:\u0026#34;required\u0026#34;` Number int `json:\u0026#34;number\u0026#34; form:\u0026#34;number\u0026#34; xml:\u0026#34;number\u0026#34; binding:\u0026#34;required\u0026#34;` } func main() { r := gin.Default() // 模拟第三方提供添加产品API接口 r.POST(\u0026#34;/product\u0026#34;, func(ctx *gin.Context) { var pro Product if err := ctx.ShouldBind(\u0026amp;pro); err != nil { ctx.AbortWithError(http.StatusBadRequest, err) return } ctx.JSON(http.StatusOK, pro) }) log.Fatal(r.Run(\u0026#34;:7586\u0026#34;)) } 这里定义一个 /product API接口用于模拟第三方服务提供添加产品服务，并且请求方式必须是POST。简单使用Gin框架对请求数据进行绑定，ctx.ShouldBind 方法会根据模型Product定义及请求数据格式自动推断绑定何种数据格式，由模型Product可知，可以绑定[JSON/XML/表单]请求格式数据。并且这个服务跑在7586这个端口，那么可以使用http://localhost:7586这个BaseURL来访问API服务。\n项目使用POST方式请求第三方API服务 例如你的项目API服务需要依赖第三方API服务，那么可以像下面这几种POST方式来访问第三方服务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) const AddProductAPI = \u0026#34;http://localhost:7586/product\u0026#34; func main() { r := gin.Default() r.POST(\u0026#34;/add-product-for-urlencoded\u0026#34;, AddProductForUrlencodedHandler) r.POST(\u0026#34;/add-product-for-post-form\u0026#34;, AddProductForPostFormHandler) r.POST(\u0026#34;/add-product-for-json\u0026#34;, AddProductForJSONHandler) r.POST(\u0026#34;/add-product-for-xml\u0026#34;, AddProductForXMLHandler) log.Fatal(r.Run(\u0026#34;:7587\u0026#34;)) } 假定你的项目跑在本地7587端口。\nUrlencoded数据格式请求POST接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func AddProductForUrlencodedHandler(ctx *gin.Context) { response, err := http.Post(AddProductAPI, \u0026#34;application/x-www-form-urlencoded\u0026#34;, strings.NewReader(`name=iPhoneX\u0026amp;number=100`)) if err != nil { ctx.AbortWithError(http.StatusBadRequest, err) return } defer response.Body.Close() all, err := ioutil.ReadAll(response.Body) if err != nil { ctx.AbortWithError(http.StatusInternalServerError, errors.New(\u0026#34;request api has error\u0026#34;)) return } ctx.Writer.WriteString(string(all)) } 使用Go内置包http的Post方法来构建一个POST请求，这个方法接收三个参数，分别是url、contentType、body，前两个都是string类型的参数，而body是一个io.Reader接口类型值，只需要指定一个io.Reader的实现类型即可，如这里指定了strings.NewReader。使用CURL工具请求/add-product-for-urlencodedAPI接口响应数据下如所示：\n1 2 $ curl -X POST localhost:7587/add-product-for-urlencoded {\u0026#34;name\u0026#34;:\u0026#34;iPhoneX\u0026#34;,\u0026#34;number\u0026#34;:100} PostForm数据格式请求POST接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func AddProductForPostFormHandler(ctx *gin.Context) { response, err := http.PostForm(AddProductAPI, url.Values{\u0026#34;name\u0026#34;: []string{\u0026#34;iMac\u0026#34;}, \u0026#34;number\u0026#34;: []string{\u0026#34;1000\u0026#34;}}) if err != nil { ctx.AbortWithError(http.StatusBadRequest, err) return } defer response.Body.Close() all, err := ioutil.ReadAll(response.Body) if err != nil { ctx.AbortWithError(http.StatusInternalServerError, errors.New(\u0026#34;request api has error\u0026#34;)) return } ctx.Writer.WriteString(string(all)) } 使用Go内置包http的PostForm方法来构建一个POST请求，这个方法接收两个参数，分别是url、data，第一个参数是string类型的指定一个API请求地址，而data是一个url.Values类型的值。\n由源码可知url.Values定义：\n1 type Values map[string][]string 它是一个键为string类型，值为[]string类型的字典。上面函数在指定data参数时具体值为 url.Values{\u0026quot;name\u0026quot;: []string{\u0026quot;iMac\u0026quot;}, \u0026quot;number\u0026quot;: []string{\u0026quot;1000\u0026quot;}}，当然也可以这么写 url.Values{\u0026quot;name\u0026quot;: {\u0026quot;iMac\u0026quot;}, \u0026quot;number\u0026quot;: {\u0026quot;1000\u0026quot;}} 不指定字段值类型，直接给定其字面值，这样写确定可以减少代码，不过不易读，本着代码可读性的原则这里指定了其值的明确类型。使用CURL工具请求/add-product-for-post-formAPI接口响应数据下如所示：\n1 2 $ curl -X POST localhost:7587/add-product-for-post-form {\u0026#34;name\u0026#34;:\u0026#34;iMac\u0026#34;,\u0026#34;number\u0026#34;:1000} JSON数据格式请求POST接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func AddProductForJSONHandler(ctx *gin.Context) { request, err := http.NewRequest(http.MethodPost, AddProductAPI, bytes.NewReader([]byte(`{\u0026#34;name\u0026#34;: \u0026#34;MacPro\u0026#34;, \u0026#34;number\u0026#34;: 10000}`))) if err != nil { ctx.AbortWithError(http.StatusBadRequest, err) return } request.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) client := new(http.Client) response, err := client.Do(request) if err != nil { ctx.AbortWithError(http.StatusInternalServerError, errors.New(\u0026#34;request api has error\u0026#34;)) return } defer response.Body.Close() all, err := ioutil.ReadAll(response.Body) if err != nil { ctx.AbortWithError(http.StatusInternalServerError, errors.New(\u0026#34;request api has error\u0026#34;)) return } ctx.Writer.WriteString(string(all)) } 使用Go内置包http的NewRequest构造方法来构建一个POST请求，这个构造方法接收三个参数，分别是method、url、body，前两个都是string类型的参数，而body是一个io.Reader接口类型值，只需要指定一个io.Reader的实现类型即可，这里指定了bytes.NewReader。并且指定了其请求数据格式类型为 application/json。使用CURL工具请求/add-product-for-jsonAPI接口响应数据下如所示：\n1 2 $ curl -X POST localhost:7587/add-product-for-json {\u0026#34;name\u0026#34;:\u0026#34;MacPro\u0026#34;,\u0026#34;number\u0026#34;:10000} XML数据格式请求POST接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func AddProductForXMLHandler(ctx *gin.Context) { request, err := http.NewRequest(http.MethodPost, AddProductAPI, bytes.NewReader([]byte(`\u0026lt;Product\u0026gt;\u0026lt;name\u0026gt;MacAir\u0026lt;/name\u0026gt;\u0026lt;number\u0026gt;100000\u0026lt;/number\u0026gt;\u0026lt;/Product\u0026gt;`))) if err != nil { ctx.AbortWithError(http.StatusBadRequest, err) return } request.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/xml\u0026#34;) client := new(http.Client) response, err := client.Do(request) if err != nil { ctx.AbortWithError(http.StatusInternalServerError, errors.New(\u0026#34;request api has error\u0026#34;)) return } defer response.Body.Close() all, err := ioutil.ReadAll(response.Body) if err != nil { ctx.AbortWithError(http.StatusInternalServerError, errors.New(\u0026#34;request api has error\u0026#34;)) return } ctx.Writer.WriteString(string(all)) } 与上面的[JSON数据格式请求POST接口]类似只是数据格式发生了变化,这里指定了其请求数据格式类型为 application/xml。使用CURL工具请求/add-product-for-xmlAPI接口响应数据下如所示：\n1 2 $ curl -X POST localhost:7587/add-product-for-xml {\u0026#34;name\u0026#34;:\u0026#34;MacAir\u0026#34;,\u0026#34;number\u0026#34;:100000} 正如你所见上面的4种示例方式中的请求数据都是写死的，真实项目是要获取请求数据然后再传递数据到第三方API接口服务的。\n","date":"2020-05-23","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/23/go-requests-third-party-api-interfaces-to-send-post-requests-in-several-ways/","tags":["openapi","http"],"title":"Golang请求第三方API接口发送POST请求的几种方式"},{"categories":["NuxtJS"],"contents":"记录一下Nuxt博客项目部署到Docker环境的过程，这可能对将要部署Nuxt应用到Docker环境的你有所帮助~\n编写Dockerfile文件 在你的Nuxt项目目录下编写Dockerfile如下示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 FROM node:12.16.2 # 创建容器工作目录 RUN mkdir -p /app WORKDIR /app # 拷贝package.json文件到容器工作目录， # 注意这个地方为什么没有拷贝yarn.lock或package-lock.json文件呢? # 原因是这样子的，如果你本地不是使用的淘宝的镜像源，而是使用的默认镜像源， # 这个时候你将它拷贝进来安装依赖的时候会有一个很大彩蛋，安装不成功！ # 拷贝不拷贝yarn.lock或package-lock.json文件自己决定哦 COPY package.json /app # 安装Nuxt项目依赖，如果你是中国用户这个配置镜像库源的操作是必须的要不然你安装依赖是不是成功的，大环境如此，汝之奈何! RUN yarn config set registry \u0026#39;https://registry.npm.taobao.org\u0026#39; RUN yarn install # 设置容器环境变量 ENV NODE_ENV=production ENV HOST 0.0.0.0 # 拷贝当前项目目录到容器内工作目录，注意添加.dockerignore文件忽略不必要的文件或目录 COPY . /app # 编辑Nuxt应用 RUN yarn build # 在容器内部向外(宿主机)暴露端口号 EXPOSE 3000 # 容器运行时要执行的命令，这里是启动Nuxt应用 CMD [\u0026#34;yarn\u0026#34;, \u0026#34;start\u0026#34;] 关于这个Dockerfile用到命令解释如下：\nFROM: 基础镜像，你现在要运行Nuxt应用是不是要用Node环境对吧！ RUN: 告诉Docker我要执行什么命令。 WORKDIR: 指定容器工作目录。 COPY: 将宿主主机文件拷贝到容器环境内。 ENV: 在容器内部设置环境变量。 EXPOSE: 指定容器内部向外(也就是宿主主机，何为宿主主机，就是运行你Docker服务的机器)暴露的端口。 CMD: CMD 容器启动命令。有两种格式，第一种：shell格式(如：CMD yarn start)，第二种：exec格式(如：CMD [\u0026ldquo;yarn\u0026rdquo;, \u0026ldquo;start\u0026rdquo;])，上面的Dockerfile使用的是exec格式。 编写docker-compose.yaml文件 为什么要用docker-compose.yaml文件来管理docker容器服务呢，方便，并且可定制的空间更大，其实有了上面的Dockerfile你就可以编译出一个镜像进行单独运行容器，不过单独运行容器有一个缺点那就是你要输入长的命令及参数来运行容器，管理起来在实属不便，你下次启动一个同样配置的容器是不是还要再次输入一遍，是不是很不便，那有了docker-compose.yaml文件这一切都将变的更美好了，编写好相关的配置参数后就可以通过简单的几个命令来管理容器服务，是不是很酷！来吧看一怎么写！不过你要使用docker compose来管理容器服务，需要先进行安装docker compose服务！如何安装可以参考官网DockerCompose安装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 version: \u0026#34;3.6\u0026#34; services: nuxt-server: container_name: nuxt-container build: \u0026#34;.\u0026#34; ports: - \u0026#39;3000:3000\u0026#39; restart: always networks: - nuxt-server-net - externals networks: nuxt-server-net: driver: bridge externals: external: true 关于这个docker-compose.yaml用到命令解释如下：\nversion: 指定docker compose file使用哪个版本的语法。 services: 指定这个docker compose file下有哪些服务。 nuxt-server: 指定当前docker compose file管理的应用服务，这里是nuxt-server当然你也可以指定其它名称。 container_name: 应用服务nuxt-server运行时所在的容器名称，这里是nuxt-container一般用提供目标命名。 build: 应用服务nuxt-server构建目标这里是当前项目下，它会在项目目录下找到Dockerfile作为构建依据来构建镜像。 ports: 应用服务nuxt-server内部暴露的端口号3000与宿主主机3000端口关联，注意：前面的是宿主主机端口号，后面是容器内部暴露的端口号。可以有多个要根据容器向外暴露而定。 restart: 可选值[\u0026ldquo;no\u0026rdquo;, always, on-failure, unless-stopped] networks: 使用的网络，这里定义了一个nuxt-server-net和externals网络，externals用于在容器与容器之间通信。 编译docker-compose.yaml文件 如果想要构建出镜像可以使用build命令\n1 $ docker-compose build 运行docker composer管理的容器服务 如果想要运行docker composer管理的容器服务可以使用up命令\n1 $ docker-compose up -d 停止docker composer管理的容器服务 如果想要停止docker composer管理的容器服务可以使用down命令\n1 $ docker-compose down 使用docker环境内的NGINX代理Nuxt服务 Docker下的NGINX容器服务不应该和某一个应用强度关联，那你要是一台服务器上就跑这Nuxt应用，你可以将在docker-composer.yaml中也构建出NGINX容器，不过我真是不建议这么做，因为如果你有一个NGINX容器向外与宿主主机已关联，那么你在启动新的NGINX容器与主机关联的时候80端口就不能再用了，那如果你一台服务都需要通过80提供服务，那你应该单独建立一个项目维护NGINX容器服务，可以参考我的另一篇博文《Docker下如何优雅的管理你的NGINX》。你只需求添加一个nginx服务配置文件即可！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 map $sent_http_content_type $expires { \u0026#34;text/html\u0026#34; epoch; \u0026#34;text/html; charset=utf-8\u0026#34; epoch; default off; } server { listen 443 ssl; server_name wumoxi.com; # SSL signature. ssl_certificate /etc/nginx/ca/wumoxi.com/cert.pem; ssl_certificate_key /etc/nginx/ca/wumoxi.com/cert.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; # Http response body max size. client_max_body_size 8m; gzip on; gzip_types text/plain application/xml text/css application/javascript; gzip_min_length 1000; # Match router of the root. location / { expires $expires; proxy_redirect off; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_read_timeout 1m; proxy_connect_timeout 1m; proxy_pass http://nuxt-server:3000; } # Media: images, icons, video, audio, HTC. location ~* \\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ { expires 1d; access_log off; add_header Cache-Control \u0026#34;public\u0026#34;; proxy_pass http://nuxt-server:3000; } # CSS and Javascript. location ~* \\.(?:css|js)$ { expires 1d; access_log off; add_header Cache-Control \u0026#34;public\u0026#34;; proxy_pass http://nuxt-server:3000; } # location ~ /\\.ht { # deny all; # } } server { listen 80; server_name wumoxi.com; rewrite ^(.*) https://$host$1 permanent; } 注意proxy_pass指定的是nuxt-server加端口，重新编译你的NGINX管理的docker-compose.yaml文件之后，启动服务即可！你现在可以访问域名进行验证啦~\n","date":"2020-05-22","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/22/nuxt-is-deployed-to-the-docker-environment/","tags":["vue","deploy"],"title":"Nuxt部署到Docker环境"},{"categories":["Docker"],"contents":"在启动Docker时并且上生产环境的时候必须要修改容器时区，要不然你产生的数据记录时间是比北京时间晚了8个小时的，因为Docker容器内默认采用的是UTC时间，但是时间是不对的，所以要修改容器时区为北京时间，时区为 Asia/shanghai，才可以~\n修改Docker容器时区的方式有三种：第一种使用Dockerfile制作镜像时配置，第二种启动单个容器时配置，第三种你的容器已经启动的情况进行修改。\n第一种、使用Dockerfile制作镜像时配置时区 优点是使用该镜像启动的新容器不需要再次修改，其原理就是将宿主主机的时区文件软链到容器内并且在容器内重写时区文件。在编写Dockerfile时添加如下代码：\n1 2 ENV TIMEZONE=Asia/Shanghai RUN ln -snf /usr/share/zoneinfo/$TIMEZONE /etc/localtime \u0026amp;\u0026amp; echo $TIMEZONE \u0026gt; /etc/timezone 第二种、启动单个容器时配置时区 例如启动一个MYSQL容器进行挂载宿主主机本地时区，这个是参考：STACK OVERFLOW，经过测试/etc/timezone不会改变，固而这种方式不可取，你有好的想法? 说说看?\n1 2 3 4 5 6 7 docker run --name mysql_tester \\ --restart always \\ -p 53306:3306 \\ -v /etc/localtime:/etc/localtime:ro \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=hello \\ -d mysql 第三种、你的容器已经启动的情况进行修改时区 这种方式，你每次启动新容器时都需要修改时区，那如果这个已经修改了时区的容器一直使用，或者说重启都没有什么问题。具体操作，首先进入到容器环境内部\n1 $ docker exec -it \u0026lt;ContainerID/ContainerName\u0026gt; /bin/bash 修改容器环境内部时间，将容器默认的本地时间，进行软链覆盖\n1 $ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 指定时区，通过输出重定向的方式将容器时区改写为Asia/Shanghai\n1 $ echo \u0026#34;Asia/Shanghai\u0026#34; \u0026gt; /etc/timezone ","date":"2020-05-21","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/21/change-the-docker-container-timezone/","tags":["timezone"],"title":"修改Docker容器时区"},{"categories":["Golang"],"contents":"写这篇文章的初衷是想总结一下Go项目开发中关于解决测试相对路径问题的思考，你可能在Go项目中遇到了这个问题，测试通过了运行服务之后，访问已运行的服务发现它依然存在问题找不到相关资源，那你简单的将资源路径改对了，去重启服务之后资源也能找到了，好开心有木有? 不好意思你不要开心这早好不好，敢不敢不再跑跑你的测试，咦~ 怎么又找不到资源了，what the hell，怎么搞好嘛~ 来来一起搞搞看好了~\n为什么会出现这种情况 原因是这样子的，比如这么说吧，在你的项目目录下有一个api目录，其中有一个markdown.go这个Go文件，在这个Go文件中定义了名为GetMarkdown的API接口，这个接口要访问项目目录下的static/markdown目录下的静态文件，那你可能在读取文件的时候直接给了一个文件路径如./static/markdown/article_1.md，你又在api目录下定义了一个测试文件markdown_test.go用于测试markdown相关的API接口，当你运行测试方法，测试GetMarkdown这个接口时，那么问题来了，当你跑测试的时候那当前测试程序是在项目api目录下，那这个测试程序它在访问资源的时候是以当前测试程序所在目录api为起点去查找相关资源的，这个时候你的api目录下并没有./static/markdown/article_1.md这个文件，所以它就找不到这个资源了，所以这个时候你有严谨的错误处理机制它就会被执行，把错误返回，告诉你 open ./static/markdown/article_1.md: no such file or directory。所以当你运行main.go的时候，访问GetMarkdown这个API接口它查找资源是在项目目录内，所以也就找到了static/markdown/article_1.md这个文件。这么说可能比较抽象，下面通过一个简单的示例项目说明这个问题。\n示例项目目录结构 这个简单示例项目目录结构如下所示，hello-demo为项目名称：\n1 2 3 4 5 6 7 8 9 10 11 $ tree . ├── api │ ├── markdown.go │ └── markdown_test.go ├── main.go └── static └── markdown ├── article_1.md ├── article_2.md └── article_3.md 示例项目简单使用了Gin框架、testify测试工具。其中static/markdown目录下静态资源文件内容依次是: article 1、article 2、article 3\n错误重现 main.go具体代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;hello-demo/api\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { markdownHandler := api.NewMarkdown() r := gin.Default() r.GET(\u0026#34;/:filename\u0026#34;, markdownHandler.GetMarkdown) log.Fatal(r.Run(\u0026#34;:8859\u0026#34;)) } api/markdown.go具体代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package api import ( \u0026#34;errors\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type MarkdownHandlerInterface interface { GetMarkdown(ctx *gin.Context) } type Markdown struct { } func NewMarkdown() *Markdown { return \u0026amp;Markdown{} } var files = []string{\u0026#34;article_1.md\u0026#34;, \u0026#34;article_2.md\u0026#34;, \u0026#34;article_3.md\u0026#34;} func (m *Markdown) GetMarkdown(ctx *gin.Context) { filename := ctx.Param(\u0026#34;filename\u0026#34;) if filename == \u0026#34;\u0026#34; { ctx.AbortWithError(http.StatusBadRequest, errors.New(\u0026#34;filename can\u0026#39;t empty\u0026#34;)) return } filename = strings.Join([]string{filename, \u0026#34;md\u0026#34;}, \u0026#34;.\u0026#34;) if has := m.checkFileExists(filename, files); !has { ctx.AbortWithError(http.StatusBadRequest, errors.New(\u0026#34;file not found\u0026#34;)) return } file, err := ioutil.ReadFile(m.filepath(filename)) if err != nil { ctx.AbortWithError(http.StatusInternalServerError, err) } ctx.Writer.WriteString(string(file)) } func (m *Markdown) filepath(filename string) string { return strings.Join([]string{\u0026#34;./static/markdown\u0026#34;, filename}, \u0026#34;/\u0026#34;) } func (m *Markdown) checkFileExists(filename string, files []string) bool { has := false for _, name := range files { if name == filename { has = true } } return has } 请注意，Markdown.filepath 方法，指定文件路径为./static/markdown！\napi/markdown_test.go具体代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package api import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/http/httptest\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;github.com/stretchr/testify/suite\u0026#34; ) func TestMarkdownSuite(t *testing.T) { suite.Run(t, new(MarkdownSuite)) } type MarkdownSuite struct { suite.Suite api *Markdown rec *httptest.ResponseRecorder ctx *gin.Context } func (m *MarkdownSuite) BeforeTest(suiteName, testName string) { m.api = NewMarkdown() m.rec = httptest.NewRecorder() m.ctx, _ = gin.CreateTestContext(m.rec) } func (m *MarkdownSuite) readResponseBody() { bytes, err := ioutil.ReadAll(m.rec.Body) assert.NoError(m.T(), err) m.T().Logf(\u0026#34;read response body content: %s\\n\u0026#34;, bytes) } func (m *MarkdownSuite) Test_GetMarkdown() { m.ctx.Params = gin.Params{{Key: \u0026#34;filename\u0026#34;, Value: \u0026#34;article_1\u0026#34;}} m.ctx.Request = httptest.NewRequest(http.MethodGet, \u0026#34;/article_1\u0026#34;, nil) m.api.GetMarkdown(m.ctx) assert.Equal(m.T(), http.StatusOK, m.rec.Code) m.readResponseBody() m.T().Logf(\u0026#34;gin has errors: %s\\n\u0026#34;, m.ctx.Errors.String()) } 在这个测试文件中需要说明一下testify这个测试工具包(相当不错，建议尝试使用哦)，它可以对一组方法进行一撸到底的测试，也可以运行单个的测试方法，你可以实现BeforeTest和AfterTest接口，用于在测试开始之前初始化一些对象和测试结束之后执行一些操作(如删除测试表，关闭文件，关闭测试数据库连接等等吧)\n运行测试，对api/markdown_test.go文件进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ go test ./... ? hello-demo\t[no test files] [GIN-debug] [WARNING] Running in \u0026#34;debug\u0026#34; mode. Switch to \u0026#34;release\u0026#34; mode in production. - using env:\texport GIN_MODE=release - using code:\tgin.SetMode(gin.ReleaseMode) --- FAIL: TestMarkdownSuite (0.00s) --- FAIL: TestMarkdownSuite/Test_GetMarkdown (0.00s) markdown_test.go:41: Error Trace:\tmarkdown_test.go:41 Error: Not equal: expected: 200 actual : 500 Test: TestMarkdownSuite/Test_GetMarkdown markdown_test.go:34: read response body content: markdown_test.go:43: gin has errors: Error #01: open ./static/markdown/article_1.md: no such file or directory FAIL FAIL\thello-demo/api\t0.015s FAIL 从测试结果来看它存在错误信息：open ./static/markdown/article_1.md: no such file or directory。\n运行main.go启动服务通过CURL进行API接口访问\n1 2 $ curl localhost:8859/article_1 article 1 通过CURL访问API接口正常，那么怎么来解决这个问题呢? 总结了一下有两种方式可以解决这个问题，第一种：传递资源路径；第二种：os.Getwd动态计算资源路径。\n第一种：传递资源路径 修改api/markdown.go文件 Markdown结构体添加一个ResourcePath字段：\n1 2 3 type Markdown struct { ResourcePath string } NewMarkdown构建函数添加一个resourcePath参数：\n1 2 3 func NewMarkdown(resourcePath string) *Markdown { return \u0026amp;Markdown{ResourcePath: resourcePath} } filepath方法使用结构体字段构造资源路径：\n1 2 3 func (m *Markdown) filepath(filename string) string { return strings.Join([]string{m.ResourcePath, filename}, \u0026#34;/\u0026#34;) } 修改api/markdown_test.go测试文件 BeforeTest方法，为NewMarkdown构造函数指定资源路径:\n1 2 3 4 5 func (m *MarkdownSuite) BeforeTest(suiteName, testName string) { m.api = NewMarkdown(\u0026#34;./../static/markdown\u0026#34;) m.rec = httptest.NewRecorder() m.ctx, _ = gin.CreateTestContext(m.rec) } 修改main.go文件 为NewMarkdown构造函数指定资源路径：\n1 2 3 4 5 6 func main() { markdownHandler := api.NewMarkdown(\u0026#34;./static/markdown\u0026#34;) r := gin.Default() r.GET(\u0026#34;/:filename\u0026#34;, markdownHandler.GetMarkdown) log.Fatal(r.Run(\u0026#34;:8859\u0026#34;)) } 请注意，测试文件api/markdown_test.go与main.go文件中指定的资源路径！\n验证 运行测试，对api/markdown_test.go文件进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 go test -v ./... ? hello-demo\t[no test files] === RUN TestMarkdownSuite === RUN TestMarkdownSuite/Test_GetMarkdown [GIN-debug] [WARNING] Running in \u0026#34;debug\u0026#34; mode. Switch to \u0026#34;release\u0026#34; mode in production. - using env:\texport GIN_MODE=release - using code:\tgin.SetMode(gin.ReleaseMode) --- PASS: TestMarkdownSuite (0.00s) --- PASS: TestMarkdownSuite/Test_GetMarkdown (0.00s) markdown_test.go:34: read response body content: article 1 markdown_test.go:43: gin has errors: PASS ok hello-demo/api\t0.014s 可以看到测试读取文件内容为article 1\n运行main.go启动服务通过CURL进行API接口访问\n1 2 $ curl localhost:8859/article_2 article 2 可以看到CURL访问API接口返回的资源内容为article 2, 关于测试相对路径与主程序相对路径访问资源的问题也就统一了，这个问题也就通过传递资源路径的方式解决了，再来看另一种方式：os.Getwd动态计算资源路径。\n第二种：os.Getwd动态计算资源路径 Go内置包os有一个函数Getwd，它返回当前运行程序所在路径，那有了这个路径是不是在判断一下当前运行程序所在目录是不是api目录，如果是就将目录访问到项目根目录这样岂不美哉，不错很好~\n添加一个工具包utils 并在utils.go(utils/utils.go)文件定义如下函数以及常量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package utils import ( \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) // API目录常量 const ApiDir = \u0026#34;api\u0026#34; // GetCurrentPath获取运行程序绝对路径，如：/Users/wumoxi/dev/go/src/hello-demo func GetCurrentPath() string { cur, _ := os.Getwd() return cur } // GetCurrentDir获取路径最后一级目录名称, 如：/Users/wumoxi/dev/go/src/hello-demo -\u0026gt; hello-demo func GetCurrentDir(path string) string { _, file := filepath.Split(path) return file } 修改api/markdown.go文件 filepath方法使用os.Getwd动态构造资源路径：\n1 2 3 4 5 6 7 8 func (m *Markdown) filepath(filename string) string { pathPrefix := \u0026#34;./\u0026#34; if utils.GetCurrentDir(utils.GetCurrentPath()) == utils.ApiDir { pathPrefix = \u0026#34;./../\u0026#34; } path := strings.Join([]string{pathPrefix, \u0026#34;static/markdown\u0026#34;, filename}, \u0026#34;/\u0026#34;) return path } 验证 运行测试，对api/markdown_test.go文件进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 go test -v ./... ? hello-demo\t[no test files] === RUN TestMarkdownSuite === RUN TestMarkdownSuite/Test_GetMarkdown [GIN-debug] [WARNING] Running in \u0026#34;debug\u0026#34; mode. Switch to \u0026#34;release\u0026#34; mode in production. - using env:\texport GIN_MODE=release - using code:\tgin.SetMode(gin.ReleaseMode) --- PASS: TestMarkdownSuite (0.00s) --- PASS: TestMarkdownSuite/Test_GetMarkdown (0.00s) markdown_test.go:34: read response body content: article 1 markdown_test.go:43: gin has errors: PASS ok hello-demo/api\t0.014s 可以看到测试读取文件内容为article 1\n运行main.go启动服务通过CURL进行API接口访问\n1 2 $ curl localhost:8859/article_3 article 3 可以看到CURL访问API接口返回的资源内容为article 3, 关于测试相对路径与主程序相对路径访问资源的问题也就统一了，这个问题就通过os.Getwd动态计算资源路径的方式解决了！键盘至此也就敲完了~😄，祝好~\n示例项目 hello-demo\n","date":"2020-05-20","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/20/how-to-solve-the-relative-path-problem-of-go-test/","tags":["relative","path","test"],"title":"如何解决Go测试相对路径问题？来来掰扯掰扯"},{"categories":["Golang"],"contents":"Go不允许存在包的循环引入，你是不是也在项目开发时遇到过 import cycle not allowed 编译错误呢? 你找到好的解决方案了没有呢? 下文也许可能会对你解决这个问题有所帮助~\n何为包的循环引入 如在项目中有bar包和foo包，假如bar包用到了foo包代码，并且foo包也用到了bar包代码，那么这时就会产生编译错误import cycle not allowed意为\u0026quot;不允许循环引入\u0026quot;。\n假定示例项目结构如下：\n1 2 3 4 5 6 7 8 9 $ depend git:(master) tree . ├── bar │ └── bar.go ├── foo │ └── foo.go └── main.go 2 directories, 3 files bar/bar.go代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package bar import ( \u0026#34;depend/foo\u0026#34; \u0026#34;fmt\u0026#34; ) type Bar struct { Name string Description string } func NewBar(name string, description string) *Bar { return \u0026amp;Bar{Name: name, Description: description} } func (b *Bar) Info() { fmt.Printf(\u0026#34;name is %s, description is: %s\\n\u0026#34;, b.Name, b.Description) } func (b *Bar) PrintFooInfo() { f := foo.NewFoo(\u0026#34;Foo\u0026#34;, \u0026#34;Foo is struct object\u0026#34;) f.Info() } foo/foo.go代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package foo import ( \u0026#34;depend/bar\u0026#34; \u0026#34;fmt\u0026#34; ) type Foo struct { Name string Description string } func NewFoo(name string, description string) *Foo { return \u0026amp;Foo{Name: name, Description: description} } func (f *Foo) Info() { fmt.Printf(\u0026#34;name is %s, description is: %s\\n\u0026#34;, f.Name, f.Description) } func (f *Foo)PrintBarInfo() { b := bar.NewBar(\u0026#34;Bar\u0026#34;, \u0026#34;Bar is struct object\u0026#34;) b.Info() } main.go 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;depend/bar\u0026#34; \u0026#34;depend/foo\u0026#34; ) func main() { b := bar.NewBar(\u0026#34;Bar\u0026#34;, \u0026#34;Bar is struct object\u0026#34;) b.PrintFooInfo() f := foo.NewFoo(\u0026#34;Foo\u0026#34;, \u0026#34;Foo is struct object\u0026#34;) f.PrintBarInfo() } 那么这个时候你运行main函数会得到如下编译错误提示信息：\n1 2 3 4 5 import cycle not allowed package depend imports depend/bar imports depend/foo imports depend/bar 如何解决包的循环引入 使用接口解决，网上有也博文说明使用分包的解决方案但是个人觉得不太理想，这是只说一下使用接口解决循环引入问题。\n使用接口解决 在项目目录下新建一个inter(inter/inter.go)代码包并定义一个接口：\n1 2 3 4 5 package inter type PrintInfo interface { Info() } 那么这个时候是不是 bar 包和 foo 包是不是已经实现了这个PrintInfo接口，因为各包都有Info方法实现对不对！这个时候稍加对bar和foo代码包修改即可！\n修改bar/bar.go代码包方法PrintFooInfo如下：\n1 2 3 func (b *Bar) PrintFooInfo(pi inter.PrintInfo) { pi.Info() } 修改foo/foo.go代码包方法PrintBarInfo如下：\n1 2 3 func (f *Foo)PrintBarInfo(pi inter.PrintInfo) { pi.Info() } 从上面修改可知PrintFooInfo和PrintBarInfo方法现在接收一个inter.PrintInfo接口类型的值，那好了，在main函数调用时直接将要调用的接口类型值传递进去，这个问题也解决掉了。\n修改main.go主函数main如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import ( \u0026#34;depend/bar\u0026#34; \u0026#34;depend/foo\u0026#34; ) func main() { b := bar.NewBar(\u0026#34;Bar\u0026#34;, \u0026#34;Bar is struct object\u0026#34;) f := foo.NewFoo(\u0026#34;Foo\u0026#34;, \u0026#34;Foo is struct object\u0026#34;) b.PrintFooInfo(f) f.PrintBarInfo(b) } 现在运行main.go得到如下输出：\n1 2 name is Foo, description is: Foo is struct object name is Bar, description is: Bar is struct object 那么循环引入问题也就通过接口完美解决了，循环引入的本质就是包与包相互引入，那接口就避免了这个问题，而是通过调用接口类型的值，只要一个类型实现了这个接口，就可以调用这个接口类型的值所定义的方法。\n","date":"2020-05-19","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/19/how-do-i-solve-the-go-package-loop-introduction-problem/","tags":["package","reference"],"title":"如何解决Golang包循环引入问题？"},{"categories":["Golang"],"contents":"在Go项目中如果你想在局域网访问Go运行的服务器，那么就不应该指定其地址为 localhost:port 或者 127.0.0.1:port，应该指定为 :port 或 0.0.0.0:port 的形式！为什么呢？\n说整明白这是怎么回事，这时候就是考验你网络基础的时候了，上大学的时候计算机专业都是有学过的哦(《计算机网络》想起来了吧)，来复习一下几个概念：\n本地环回地址 域名解析 默认路由 何为本地环回地址 运用本地环回机制，便可在主机上运行网络服务，期间不须安装实体网络接口卡(也就是物理网卡)，也无须将该服务开放予主机所在的网络。例如，在设置好本地安装的网站后，可通过 http://localhost 这一网址，来访问本地网站！\n域名解析一般会将localhost解析为IPv4本地环回地址 127.0.0.1 和IPv6本地环回地址 [::1]。\nlocalhost是一个在计算机网络中用于表示 \u0026ldquo;此计算机\u0026rdquo; 的主机名。它被用于通过本地环回网络接口，来访问本机运行的服务，并且将会绕过任何物理网络接口硬件。—维基百科\n何为域名解析 简单粗暴的解释就是从IP到域名转换。\n由以上概念可知，localhost或127.0.0.1只能在本地主机里玩耍，玩的再嗨别的主机也不知道你玩什么，那么怎么也让别的主机知道你在玩什么呢? 或者说访问本地主机跑的服务，那这个时候就需要在复习一下什么是默认路由哦~\n何为默认路由 默认路由(Default route)，是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由。目的地不丰路由器的路由表里的所有数据包都会使用默认路由。这条路由一般会连去另一个路由器，而这个路由器也同样处理数据包；如果知道应该怎么路由这个数据包，则数据包会被转发到已知的路由；否则，数据包会被转发到默认路由，从而到达另一个路由器。每次转发，路由都增加了一跳的距离。当到达了一个知道如何到达目的地址的路由器时，这个路由器就会根据最长前缀匹配来选择有效的路由。子网掩码匹配目的IP地址而且又最长的网络会被选择。用无类别域间路由标记表示的IPv4默认路由是0.0.0.0/0。—维基百科\n由上可知 0.0.0.0 为默认路由，要想局域网内的其它主机访问当前主机要必须使用默认路由而不能使用localhost或127.0.0.1， :port 表示的就是0.0.0.0、localhost、127.0.0.1 之和，所示说，当前启动一个Go服务器的时候，要么明确指定 0.0.0.0:port 要么指定 :port 局域网内的其它主机方可访问到~\nGo服务示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.GET(\u0026#34;/\u0026#34;, func(ctx *gin.Context) { ctx.JSON(http.StatusOK, gin.H{\u0026#34;info\u0026#34;:\u0026#34;Hello gin framework~\u0026#34;}) }) // log.Fatal(r.Run(\u0026#34;:8859\u0026#34;)) log.Fatal(r.Run(\u0026#34;0.0.0.0:8859\u0026#34;)) } 使用 go run server.go 启动服务器之后，在局域网内的其它主机方可通过服务提供者主机IP+PORT的方式访问到服务提供者主机。例如：服务提供者主机IP为192.168.0.103，那么局域网内的主机访问当前这个服务的地址URL就是 http://192.168.0.103:8859，就这样子！\n","date":"2020-05-18","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/18/can-not-access-the-server-lan-built-by-go/","tags":["lan","server"],"title":"Golang 搭建的服务器局域网不能访问?"},{"categories":["RESTful"],"contents":"RESTFul接口设计时，添加记录时如果已存在资源时应该返回什么状态码比较合适? 400? 合适吗?\n添加记录 RESTFul接口设计时，对于添加记录或者说是资源时，HTTP请求类型应该是POST方式，那么如果这个资源同名了，应该返回409比较合适，原意为资源冲突，当然话又说过来，对于添加资源更加严谨的流程应该是前端用户输入资源名称后去调用后端API接口检测是否存在同名资源，这样也有利于提高用户体验(这个要看具体的设计，不过一般也都会采用这样机制)，这里仅仅讨论的是后端处理已有资源时应该返回什么样的状态码比较合适的问题~，个人觉得 Conflict 还是比较合适的，你有更好的想法，请留言一起探讨哦~/:ok\n","date":"2020-05-17","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/17/what-status-code-should-an-existing-resource-return-when-adding-a-record/","tags":["post","conflict"],"title":"RESTFul接口设计时，添加记录时已存在资源应该返回什么状态码?"},{"categories":["RESTful"],"contents":"退出登录就是用户注销其在系统中的登录身份(或者说状态)，那么在开发的时候这个退出(logout)接口应该定义成什么样的请求类型呢？是GET还是POST?\n关于注销登录 在各个系统中对于处理注销登录的机制也大同小异，说到注销登录就不得不说一下登录的机制，登录的机制在早期的后端开发中一般情况下是使用SESSION机制，进行标识一个用户登录状态。时下最流行的前后端分离开发模式，后端程序一般都会使用JWT做为认证机制，不管怎么说吧，这些登录机制就是在系统中进行标识用户登录状态，用户注销登录的时候，请求注销接口携带一个用户唯一标识如用户手机号，后端程序根据这个唯一标识去找到登录时在系统签发的唯一标识(一般存放在Redis这种内存级数据库)，将其进行过期或者删除登录标识，这个流程也就完毕了，用户也就退出了系统！\n注销接口是该使用GET还是POST 这个问题从安全角度考虑应该使用POST，为什么这么说呢，那就应该从POST请求方式的本质来可虑了，我们都知道它是通过HTTP-Body进行数据携带而不是通过URL，所以应该使用POST请求方式做用户注销接口的定义，那为什么不用GET请求方式做用户注销登录接口的定义呢？原因主要是GET请求浏览器会进行URL缓存操作，所以使用GET请求不够安全！你也可以去验证一下大公司在做用户注销登录的时候，使用什么HTTP请求方式，如：京东，淘宝 之类的！\n","date":"2020-05-16","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/16/whether-to-logout-using-a-get-request-or-a-post-request/","tags":["POST","GET"],"title":"RESTFul接口设计时，退出登录是使用GET请求还是使用POST请求?"},{"categories":["MYSQL"],"contents":"在日常工作中，我们有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。（QEP：sql生成一个执行计划query Execution plan）。\n1 2 3 4 5 6 7 mysql\u0026gt; explain select * from servers; +----+-------------+---------+------+---------------+------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+---------+------+---------------+------+---------+------+------+-------+ | 1 | SIMPLE | servers | ALL | NULL | NULL | NULL | NULL | 1 | NULL | +----+-------------+---------+------+---------------+------+---------+------+------+-------+ row in set (0.03 sec) expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra,下面对这些字段出现的可能进行解释：\n一、id 我的理解是SQL执行的顺序的标识,SQL从大到小的执行\nid相同时，执行顺序由上至下。 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。 id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行。 二、select_type 查询中每个select子句的类型\nSIMPLE：(简单SELECT,不使用UNION或子查询等)。 PRIMARY：(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)。 UNION：(UNION中的第二个或后面的SELECT语句)。 DEPENDENT UNION：(UNION中的第二个或后面的SELECT语句，取决于外面的查询)。 UNION RESULT：(UNION的结果)。 SUBQUERY：(子查询中的第一个SELECT)。 DEPENDENT SUBQUERY：(子查询中的第一个SELECT，取决于外面的查询)。 DERIVED：(派生表的SELECT, FROM子句的子查询)。 UNCACHEABLE SUBQUERY：(一个子查询的结果不能被缓存，必须重新评估外链接的第一行。 三、table 显示这一行的数据是关于哪张表的，有时不是真实的表名字,看到的是derivedx(x是个数字,我的理解是第几步执行的结果)\n1 2 3 4 5 6 7 8 mysql\u0026gt; explain select * from (select * from ( select * from t1 where id=2602) a) b; +----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ | 1 | PRIMARY | \u0026lt;derived2\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | | | 2 | DERIVED | \u0026lt;derived3\u0026gt; | system | NULL | NULL | NULL | NULL | 1 | | | 3 | DERIVED | t1 | const | PRIMARY,idx_t1_id | PRIMARY | 4 | | 1 | | +----+-------------+------------+--------+-------------------+---------+---------+------+------+-------+ 四、type 表示MySQL在表中找到所需行的方式，又称“访问类型”。\n常用的类型有： ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）\nALL: Full Table Scan， MySQL将遍历全表以找到匹配的行 index: Full Index Scan，index与ALL区别为index类型只遍历索引树 range: 只检索给定范围的行，使用一个索引来选择行 ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件 const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。 五、possible_keys 指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用\n该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询。\n六、Key key列显示MySQL实际决定使用的键（索引）\n如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。\n七、key_len 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）\n不损失精确性的情况下，长度越短越好。\n八、ref 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。\n九、rows 表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数。\n十、Extra 该列包含MySQL解决查询的详细信息,有以下几种情况：\nUsing where：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤 Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询 Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序” Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。 Impossible where：这个值强调了where语句会导致没有符合条件的行。 Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行 总结： EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况。 EXPLAIN不考虑各种Cache。 EXPLAIN不能显示MySQL在执行查询时所作的优化工作。 部分统计信息是估算的，并非精确值。 EXPALIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划。 原文链接 MySQL Explain详解 ","date":"2020-05-15","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/15/mysql-explain/","tags":["explain"],"title":"[转载]Mysql Explain"},{"categories":["IDEA"],"contents":"IntelliJ家族的IDE在设置代码自动换行时菜单是一致的，你如果用过其中一个特定的IDE如 IDEA，那么对于其它的IntelliJ家族编辑器也同样适用~\n代码自动换行 分为单个文件或整个项目！\n单个文件 设置菜单依次是: View -\u0026gt; Active Editor -\u0026gt; Soft-Wrap\n整个项目 设置菜单依次是: Goland -\u0026gt; Preferences... -\u0026gt; Editor -\u0026gt; General -\u0026gt; Soft-Wrap，这个可以个性化定制对特定扩展名的文件进行设置自动换行！\n","date":"2020-05-14","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/14/goland-code-wraps-automatically/","tags":["goland","code","automatically"],"title":"Goland 代码自动换行"},{"categories":["NuxtJS"],"contents":"在VUE项目中读取项目根目录下的.env文件可以直接通过 process.env.VUE_APP_EXAMPLE 的访问读取到 .env 配置文件的中 VUE_APP_EXAMPLE 配置项的具体值，在Nuxt项目中还直接这么干是读取不到滴~\n那么在Nuxt项目中怎么读取 .env 的配置项呢？直接安装一个 dotenv 依赖包就可以解决！\n安装dotenv 1 $ yarn add dotenv 加载env配置文件 修改nuxt.config.js，引入dotenv模块\n1 const env = require(\u0026#39;dotenv\u0026#39;).config(); 在 module.exports 对象中添加如下属性即可\n1 2 3 4 5 6 7 8 module.exports = { //...... // Setting env env: env.parsed, //...... } 好了，这样你就可以像在VUE项目中那样使用 process.env.VUE_APP_EXAMPLE 读取配置项啦~\n","date":"2020-05-13","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/13/nuxt-reads-the-env-configuration-file/","tags":["configuration","env"],"title":"NuxtJS读取.env配置文件"},{"categories":["MYSQL"],"contents":"比如有这么一个需求，获取当前文章记录数据并且返回当前记录的上一条记录ID和下一条记录ID，用于前端文章详情页的上一篇和下一篇文章获取，其实也特别的简单，顺便记录一下！\n简略数据源如下：\n查询分析 要获取当前查询记录ID为1000的记录的上一条记录ID: 999，可以在ID小于1000的范围内获取ID最大值；获取下一条记录ID: 1001，可以在大于1000的范围内获取ID最小值，那么这个事件也就算是完成了！\n注意：获取上一条记录ID和下一条记录ID的临界点就是当前查询记录ID为1000的记录哦~\n获取上一条记录ID 1 2 3 4 5 6 7 mysql\u0026gt; select max(id) as last_id from article where id \u0026lt; 1000; +---------+ | last_id | +---------+ | 999 | +---------+ 1 row in set (0.00 sec) 获取下一条记录ID 1 2 3 4 5 6 7 mysql\u0026gt; select min(id) as next_id from article where id \u0026gt; 1000; +---------+ | next_id | +---------+ | 1001 | +---------+ 1 row in set (0.01 sec) 获取当前记录数据包含上一条和下一条记录ID 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u0026gt; select -\u0026gt; id, -\u0026gt; title, -\u0026gt; (select max(id) from article where id \u0026lt; 1000) as last_id, -\u0026gt; (select min(id) from article where id \u0026gt; 1000) as next_id -\u0026gt; from -\u0026gt; article -\u0026gt; where -\u0026gt; id = 1000\\G *************************** 1. row *************************** id: 1000 title: HelloWorld 🎉🎉🎉 last_id: 999 next_id: 1001 1 row in set (0.00 sec) ","date":"2020-05-12","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/12/gets-the-previous-record-and-the-next-record-id-of-the-current-query-record/","tags":["query","previous","next"],"title":"获取当前查询记录的上一条记录和下一条记录ID"},{"categories":["Golang"],"contents":"JSON-RPC，是一个无状态且轻量级的远程过程调用传送协议，其传递内容主要以JSON数据为主，相较于一般的 RESTFul 通过 URL 地址，如 GET /student 调用远程服务器，JSON-RPC直接在内容中定义了想要调用的方法名称如，@@{\u0026ldquo;id\u0026rdquo;: 123456, \u0026ldquo;method\u0026rdquo;: \u0026ldquo;Service.Division\u0026rdquo;, \u0026ldquo;params\u0026rdquo;: [{\u0026ldquo;A\u0026rdquo;: 88, \u0026ldquo;B\u0026rdquo;: 6}]}@@，这也令开发者不会陷于该使用 PUT 还是 POST 的问题中。在RPC服务定义中主要定义一些数据结构及其相关的处理规则。在Golang中所有注册的RPC服务方法需要满足三个条件，第一方法有一个输入参数，第二方法有一个指针类型的输出参数，第三方法返回一个error类型的返回值，满足这三个条件即可注册为RPC服务方法。在Golang中如何使用请看以下内容\u0026hellip;\n示例项目目录结构 1 2 3 4 5 6 7 8 9 10 11 12 $ tree . ├── README.md ├── client │ └── demo │ └── demo.go ├── server │ └── demo │ └── demo.go └── services └── demo └── demo.go 定义RPC服务方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // services/demo/demo.go package demo import \u0026#34;errors\u0026#34; // 定义RPC服务参数类型 type Args struct { A, B int } // 定义RPC服务 type Service struct {} // Division 计算args参数之除法运算 func (*Service) Division(args Args, result *float64) error { if args.B == 0 { return errors.New(\u0026#34;division by zero\u0026#34;) } *result = float64(args.A) / float64(args.B) return nil } 上面定义了一个名为 Service 的服务，注意这是在 services/demo 包中进行的定义的，这个服务有一个方法 Division，这个方法就是进行简单的业务处理也就是进行除法运算，并把运算结果写入到 result 变量内。\n注册RPC服务 编写RPC服务端程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // server/demo/demo.go package main import ( \u0026#34;GO-JSON-RPC/services/demo\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) func main() { // Errors recover defer func() { if e := recover(); e != nil { log.Printf(\u0026#34;demo JSON RPC server has errors: %s\\n\u0026#34;, e) } }() // 服务端注册RPC服务 err := rpc.Register(new(demo.Service)) if err != nil { panic(err) } // 监听服务端口 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8859\u0026#34;) if err != nil { panic(err) } // 接受连接并处理服务调用 for { accept, err := listener.Accept() if err != nil { log.Printf(\u0026#34;accpet has errors: %s\\n\u0026#34;, err) continue } go jsonrpc.ServeConn(accept) } } 在这段程序中主要做了以下三件事情，第一就是注册RPC服务，第二就是通过 tcp 方式监听服务端口，以供外部调用之网络端口(说白了就是使用一个tcp网络协议8859端口提供RPC服务)，第三就是通过Goroutine的方式等待客户端连接到JSON-RPC服务。\n那么这时一个简单的JSON-RPC服务也构建完毕了，服务构建完成之后那就需要使用，一个不使用的服务存在是没有意义的，我们可以通过telnet工具对其RPC服务端程序进行验证，也可以通过在其它项目中对RPC服务进行调用，为了简单起见，将客户端程序定义到 client/demo/demo.go 中，请接着向下看~\n调用RPC服务 调用RPC服务首先要将RPC服务程序运行，可以通过以下命令将其运行：\n1 $ go run server/server.go 使用telnet工具进行RPC服务调用(也就是手动调用模式) 打开另一终端，输入telnet命令对RPC服务进行调用\n1 2 3 4 $ telnet 127.0.0.1 8859 Trying 127.0.0.1... Connected to localhost. Escape character is \u0026#39;^]\u0026#39;. 输入以JSON格式的参数数据，进行JSON-RPC服务调用：\n1 {\u0026#34;id\u0026#34;: 123456, \u0026#34;method\u0026#34;: \u0026#34;Service.Division\u0026#34;, \u0026#34;params\u0026#34;: [{\u0026#34;A\u0026#34;: 88, \u0026#34;B\u0026#34;: 6}]} 关于JSON格式的参数数据说明如下：\nid: 字段为调用编号，调用结束后服务端会原样返回(可供调用者根据此ID进行其它的业务处理)。 method: 字段为要调用的RPC服务方法。 params: 字段为调用RPC服务方法需要传递的参数。 如果调用成功返回JSON格式的结果如下所示：\n1 {\u0026#34;id\u0026#34;:123456,\u0026#34;result\u0026#34;:14.666666666666666,\u0026#34;error\u0026#34;:null} 使用RPC客户端进行RPC服务调用(也就是自动调用模式) 对于RPC服务也不可能只是通过telnet进行简单的调用，更多的是面向其它的服务，举个例了，比如说在一个大型电商项目中，有很多服务如 订单，派送，短信等等吧，这些服务的业务都是相对独立的，如用户下单是不是要生成订单，发送短信等等事件，那再一步说这些事件它肯定也不是同步的一个一个去完成，一般都会把下单之后的事件操作放入到消息中间件去异步处理，消息中间件再处理各个场景事件时再去调用其它的服务，这个时候就需要用到RPC调用，因为各个服务相对独立(如：不同地域服务，不同主机或端口号，不同服务器实例或Docker容器)，在这个示例中以 client/demo/demo.go 模拟其它项目中的调用，程序定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;GO-JSON-RPC/services/demo\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/rpc/jsonrpc\u0026#34; ) func main() { // Errors recover defer func() { if e := recover(); e != nil { log.Printf(\u0026#34;demo JSON RPC client has errors: %s\\n\u0026#34;, e) } }() // 连接到远程RPC服务 conn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;:8859\u0026#34;) if err != nil { panic(err) } // 声明JSON-RPC调用回复结果变量 var reply float64 // 创建JSON-RPC客户端 client := jsonrpc.NewClient(conn) // 调用RPC服务方法 err = client.Call(\u0026#34;Service.Division\u0026#34;, demo.Args{A: 88, B: 6}, \u0026amp;reply) if err != nil { panic(err) } log.Printf(\u0026#34;call result: %f\\n\u0026#34;, reply) } 运行客户端程序模拟其它项目对JSON-RPC服务调用：\n1 $ go run client/demo/demo.go 调用结果如下所示：\n1 2020/04/06 18:50:47 JSON-RPC call result: 14.666667 这便是Golang中JSON-RPC如何使用的简单示例，当然你也可以使用gRPC框架进行RPC服务开发~\n示例代码 https://github.com/helloshaohua/Go-JSON-RPC\n","date":"2020-05-11","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/11/golang-json-rpc-use/","tags":["JSON","RPC"],"title":"Golang JSON RPC 使用"},{"categories":["VUE"],"contents":"说到如何获取HTTP响应头数据，就不得到说一下对于CORS请求，默认情况下，浏览器只能访问 Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma 这些Header头，那如果想访问服务器端自定义的Header头应该如何处理呢？\n如果像axios这种请求工具想获取到HTTP自定义响应头如 X-Access-Token， 那么服务端首先应该对响应头 Access-Control-Expose-Headers 字段进行定义，如：Access-Control-Expose-Headers: X-Access-Token，axios就可以根据headers属性获取到HTTP自定义响应头数据。\n","date":"2020-05-10","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/10/how-does-axios-get-http-response-header-data/","tags":["axios","AJAX"],"title":"axios如何获取HTTP响应头数据?"},{"categories":["Golang"],"contents":"在Golang中一个文件大小一般是int64类型的整数，这个类型的对程序而言是好的，不过如果提供前端展示性的数据的话，直接返回过去多少有点太那什么了\u0026hellip;\u0026hellip;这个还需要你和前端同学协商，不官怎么说总得有一方去处理，那这么Go在如何优雅的处理这个转换过程序呢？\n可定义如下函数以进行转换操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // ByteCountBinary format byte size to human readable format. func ByteCountBinary(size int64) string { const unit int64 = 1024 if size \u0026lt; unit { return fmt.Sprintf(\u0026#34;%dB\u0026#34;, size) } div, exp := unit, 0 for n := size / unit; n \u0026gt;= unit; n /= unit { div *= unit exp++ } return fmt.Sprintf(\u0026#34;%.1f%cB\u0026#34;, float64(size)/float64(div), \u0026#34;KMGTPE\u0026#34;[exp]) } 具体的程序测试结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import ( \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;github.com/stretchr/testify/suite\u0026#34; ) func TestFileSuite(t *testing.T) { suite.Run(t, new(FileSuite)) } type FileSuite struct { suite.Suite } func (f *FileSuite) Test_CalculateFileSize() { assert.Equal(f.T(), \u0026#34;1.8MB\u0026#34;, ByteCountBinary(int64(1933728))) assert.Equal(f.T(), \u0026#34;18.3MB\u0026#34;, ByteCountBinary(int64(19233728))) assert.Equal(f.T(), \u0026#34;123.2MB\u0026#34;, ByteCountBinary(int64(129233728))) assert.Equal(f.T(), \u0026#34;1.1GB\u0026#34;, ByteCountBinary(int64(1229233728))) } 没有问题，也很好用✌️\n","date":"2020-05-09","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/09/golang-formats-file-size-to-visual-size/","tags":["format","size"],"title":"Golang格式化文件大小到可视化大小"},{"categories":["MacOS"],"contents":"远程服务开放端口是否是可用，比如说阿里云ECS有一个自定义端口8859对外开放服务，但是如果说只在ECS中使用 firewall 开放了端口，ECS的安全组没有配置其8859规则的话，外部网络是无法访问到ECS内部8859提供的服务的，也就是说对于阿里云ECS来说开放一个端口，你需要做两件事情，第一是在ECS内部添加开放商品，第二是在阿里云控制台对ECS实例添加安全组规则！\n如果你在ECS内部开放了端口，你可以会忘记到阿里云ECS安全组添加开放端口无则，这时候你在本地系统中怎么连接都不能成功，你这时可能会非常之疑惑，唉，我明明在ECS内部开放了端口为什么就是不行呢？真是见鬼了，哈哈😄，稍安勿躁，只需 nc 命令去检测一下远程端口号是否可被访问，这个问题也就会明了多了，比如说远程服务器的IP地址为 10.8.9.256，你在ECS上添加了一个开放端口 8859，这时可以执行：\n1 nc -z -w 1 10.8.9.256 8859 如果可以访问的话会提示如下：\n1 Connection to 10.8.9.256 port 8859 [tcp/armcenterhttps] succeeded! 否则，端口不可访问，这时你也许会想到阿里云ECS还有一个东东叫实例安全组，添加对应的安全组规则之后，再次使用 nc 检测，这个问题也就解决了！\n说明 nc 命令是一个 Linux 命令，在 Mac 系统中可以通过 brew 进行安装，在类UNIX系统中内置该命令！\n参考 Linux nc command\n","date":"2020-05-06","image":null,"permalink":"https://shaichunfeng.com/post/2020/05/06/mac-detects-if-the-remote-service-port-is-available/","tags":["remote","service","port"],"title":"MacOS 检测远程服务端口是否可用"},{"categories":["Linux"],"contents":"超文本传输协议安全（HTTPS）是HTTP的安全版本，HTTP是用于在Web浏览器和网站之间发送数据的主要协议。HTTPS被加密，以提高数据传输的安全性。当用户传输敏感数据（例如通过登录银行帐户，电子邮件服务或健康保险提供商）时，这一点尤其重要。\n任何网站，尤其是那些需要登录凭据的网站，都应使用HTTPS。在现代网络浏览器（例如Chrome）中，未使用HTTPS的网站与带有HTTPS的网站的标记有所不同。在网址栏中寻找绿色的挂锁，以表示该网页是安全的。Web浏览器非常重视HTTPS。Google Chrome浏览器和其他浏览器将所有非HTTPS网站标记为不安全。\n获取证书 你可以到阿里云获取赛门铁克免费证书，亦或购买安全级别高的SSL证书！\n配置NGINX 在你的nginx配置目录(如: server.d|servers)下，添加如example.com.conf文件，内容配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 server { listen 443 ssl; server_name example.com; # SSL signature. ssl_certificate /etc/nginx/ca/example.com/cert.pem; ssl_certificate_key /etc/nginx/ca/example.com/cert.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; # Http response body max size. client_max_body_size 8m; # Proxy application backend api service. location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://0.0.0.0:8859/; } } server { listen 80; server_name example.com; rewrite ^(.*) https://$host$1 permanent; } 注意哦，在这个配置文件中有两个server, 主 server 是配置443端口监听服务，子 server 是配置的路由重写，意思是说，当访问 http://example.com , 子 server 会重写URL到 https://example.com。\n加载NGINX配置文件 你可以通过执行 sudo nginx -s reload 加载配置文件，而无需重新启动NGINX服务。\n更多信息 NGINX配置其实也是相当简单的，关于NGINX的更多信息请参考NGINX官方文档进行更深入的学习。预祝学习愉快~\n","date":"2020-04-08","image":null,"permalink":"https://shaichunfeng.com/post/2020/04/08/how-does-nginx-server-configure-https/","tags":["https","nginx"],"title":"NGINX服务器如何配置HTTPS"},{"categories":["Linux"],"contents":"记录一下CentOS7日常操作，以便后期查看，温故之用，好记性不如烂笔头哦！🎉🎉🎉\n开机启动服务 添加服务到chkconfig配置 1 $ chkconfig --add servername 开启服务开机启动 1 $ chkconfig docker on 资源管理 查看系统内存大小及使用情况 1 $ free -h 查看系统磁盘大小及使用情况 1 $ df -h 文件处理 查看文件的前几行 1 $ head -n number file 查看文件的后几行 1 $ tail -n number file 从文件后几行开始实时查看文件内容 这个很常用，一般文件都是追加写，而不是从头插入写，尤其是调试、监控时很有用\n1 $ tail -f -n number file 查看文件的中间部分行 1 $ sed -n \u0026#39;StartNumber,EndNumber(p)\u0026#39; filename 用户管理 查看所有用户 1 $ cat /etc/passwd 查看所有用户组 1 $ cat /etc/group 端口占用 netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。\n查看系统TCP端口占用情况 1 $ netstat -lntp 查看系统UDP端口占用情况 1 $ netstat -lnup 进程信息 lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。\n在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。\n查看所有进程打开的文件 1 $ lsof 查看所有TCP进程打开的文件 1 $ lsof -i tcp 查看所有UDP进程打开的文件 1 $ lsof -i udp 查看某个端口TCP进程打开的文件 1 $ lsof -i tcp:3306 查看某个端口UDP进程打开的文件 1 $ lsof -i udp:323 Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。\n要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。\n显示所有进程信息 1 $ ps -A 显示指定用户进程信息 1 $ ps -u root 显示所有进程信息，连同命令行 1 $ ps -ef ps与grep组合使用，查找特定进程 1 $ ps -ef | grep mysql 将与这次登入的 PID 与相关信息列示出来 1 $ ps -l 列出目前所有的正在内存中的程序 1 $ ps aux ","date":"2020-04-05","image":null,"permalink":"https://shaichunfeng.com/post/2020/04/05/centos7-related-operations/","tags":["shell"],"title":"CentOS7 相关操作"},{"categories":["Linux"],"contents":"在基于RHEL7的服务器，提供了一个firewall的动态管理的防火墙，其支持IPv4和IPv6，还支持以太网桥，并有分离运行时间和永久性配置选择。它还具备一个通向服务或者应用程序以直接增加防火墙规则的接口。\n加入开放端口到配置文件 1 $ firewall-cmd --zone=public --add-port=80/tcp --permanent 参数说明：\n--zone=public: 添加时区 --add-port=80/tcp: 添加端口 --permanent: 永久生效 重新加载防火墙配置文件 以 root 身份输入以下命令，重新加载防火墙，并不中断用户连接，即不丢失状态信息.\n1 $ firewall-cmd --reload ","date":"2020-03-28","image":null,"permalink":"https://shaichunfeng.com/post/2020/03/28/centos7-open-port-number/","tags":["port","open"],"title":"CentOS7开放端口号"}]